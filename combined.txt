### ğŸŒ³ Codebase File Tree (Excluding ignored directories)

â”œâ”€â”€ Game/
â””â”€â”€ â”œâ”€â”€ Application/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BackGround.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BackGround.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Block/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Block.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Block.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ BlockType.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Enemy/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyBase.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyBase.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyFactory.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyFactory.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyType.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FlyingEnemy.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FlyingEnemy.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ NormalEnemy.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ NormalEnemy.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Map/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CsvLoader.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CsvLoader.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Map.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Map.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelList.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelList.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PlayContext.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ PlayContext.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Player.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StageType.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StageType.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ UI/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ DamageFeedBack.cpp
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ DamageFeedBack.h
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ GamePlayHUD.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ GamePlayHUD.h
â””â”€â”€ â”œâ”€â”€ Camera/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Camera.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Camera.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraController.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraController.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StartCamPhase.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ StartCamPhase.h
â””â”€â”€ â”œâ”€â”€ Collision/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collider.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collider.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CollisionManager.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ CollisionManager.h
â””â”€â”€ â”œâ”€â”€ Loader/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LevelLoader.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ LevelLoader.h
â””â”€â”€ â”œâ”€â”€ Particle/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelParticleManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelParticleManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticlePresets.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticlePresets.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleSystem.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ ParticleSystem.h
â””â”€â”€ â””â”€â”€ Scene/
â””â”€â”€     â”œâ”€â”€ GamePlayScene.cpp
â””â”€â”€     â”œâ”€â”€ GamePlayScene.h
â””â”€â”€     â”œâ”€â”€ MyGame.cpp
â””â”€â”€     â”œâ”€â”€ MyGame.h
â””â”€â”€     â”œâ”€â”€ Pause/
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PauseSystem.cpp
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PauseSystem.h
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ PauseUI.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ PauseUI.h
â””â”€â”€     â”œâ”€â”€ SceneSelectGraph/
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ StageSelectGraph.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ StageSelectGraph.h
â””â”€â”€     â”œâ”€â”€ SceneTransition/
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ SceneTransition.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ SceneTransition.h
â””â”€â”€     â”œâ”€â”€ StageClearScene.cpp
â””â”€â”€     â”œâ”€â”€ StageClearScene.h
â””â”€â”€     â”œâ”€â”€ StageSelectScene.cpp
â””â”€â”€     â”œâ”€â”€ StageSelectScene.h
â””â”€â”€     â”œâ”€â”€ TitleScene.cpp
â””â”€â”€     â””â”€â”€ TitleScene.h
â”œâ”€â”€ Lib/
â”œâ”€â”€ MyEngine.vcxproj
â”œâ”€â”€ MyEngine.vcxproj.filters
â”œâ”€â”€ engine/
â””â”€â”€ â”œâ”€â”€ 2d/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RenderTexture.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RenderTexture.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SpriteCommon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ SpriteCommon.h
â””â”€â”€ â”œâ”€â”€ 3d/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelCommon.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelCommon.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3D.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3D.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3DCommon.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3DCommon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ SkyBox/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SkyBox.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ SkyBox.h
â””â”€â”€ â”œâ”€â”€ Audio/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Audio.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ Audio.h
â””â”€â”€ â”œâ”€â”€ InsideScene/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ AbstractSceneFactory.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ AbstractSceneFactory.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BaseScene.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BaseScene.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Framework.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Framework.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SceneFactory.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SceneFactory.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SceneManager.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ SceneManager.h
â””â”€â”€ â”œâ”€â”€ base/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ D3DResourceLeakChecker.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ D3DResourceLeakChecker.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DirectXCommon.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DirectXCommon.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ImGuiManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ImGuiManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Input.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Input.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Logger.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Logger.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SrvManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SrvManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StringUtility.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StringUtility.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TextureManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TextureManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ WinAPI.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ WinAPI.h
â””â”€â”€ â””â”€â”€ math/
â””â”€â”€     â”œâ”€â”€ MakeMatrix.cpp
â””â”€â”€     â”œâ”€â”€ MakeMatrix.h
â””â”€â”€     â””â”€â”€ MyMath.h
â””â”€â”€ main.cpp
================================================================================


============================================================
File Path: Game/Application/BackGround.cpp
============================================================
#include "BackGround.h"
#ifdef USE_IMGUI
#include "engine/base/ImGuiManager.h"
#endif
void BackGround::Initialize()
{
	titleBackGround3 = std::make_unique<Object3D>();
	titleBackGround3->Initialize();
	titleBackGround3->SetModel("Back3.obj");
	titleBackGround3Transform = {
		{ 30.0f,50.0f,1.0f },
		{ 0.0f,0.0f,0.0f },
		{ 7.5f,-4.0f,200.0f }
	};
	titleBackGround3->SetTransform(titleBackGround3Transform);

	// å³ã«ç¹‹ã’ã‚‹
	titleBackGround3_2 = std::make_unique<Object3D>();
	titleBackGround3_2->Initialize();
	titleBackGround3_2->SetModel("Back3.obj");
	titleBackGround3_2Transform = {
		{ 30.0f,50.0f,1.0f },
		{ 0.0f,0.0f,0.0f },
		{ 170.0f,-4.0f,200.0f }
	};
	titleBackGround3_2->SetTransform(titleBackGround3_2Transform);




	titleBackGround2 = std::make_unique<Object3D>();
	titleBackGround2->Initialize();
	titleBackGround2->SetModel("back2.obj");
	titleBackGround2Transform = {
		{ 30.0f,60.0f,1.0f },
		{ 0.0f,0.0f,0.0f },
		{ 7.5f,-4.0f,150.0f }
	};

	titleBackGround2->SetTransform(titleBackGround2Transform);

	titleBackGround2_2 = std::make_unique<Object3D>();
	titleBackGround2_2->Initialize();
	titleBackGround2_2->SetModel("back2.obj");
	titleBackGround2_2Transform = {
		{ 30.0f,60.0f,1.0f },
		{ 0.0f,0.0f,0.0f },
		{ 170.0f,-4.0f,150.0f }
	};
	titleBackGround2_2->SetTransform(titleBackGround2_2Transform);
	titleBackGround2_3 = std::make_unique<Object3D>();
	titleBackGround2_3->Initialize();
	titleBackGround2_3->SetModel("back2.obj");
	titleBackGround2_3Transform = {
		{ 30.0f,60.0f,1.0f },
		{ 0.0f,-0.0f,0.0f },
		{ 350.0f,-4.0f,150.0f }
	};
	titleBackGround2_3->SetTransform(titleBackGround2_3Transform);



	titleBackGround1 = std::make_unique<Object3D>();
	titleBackGround1->Initialize();
	titleBackGround1->SetModel("back1.obj");
	titleBackGround1Transform = {
		{ 1.0f,20.0f,10.0f },
		{ 0.0f,-1.5f,0.0f },
		{ 7.5f,-2.0f,50.0f }
	};
	titleBackGround1->SetTransform(titleBackGround1Transform);

	titleBackGround1_2 = std::make_unique<Object3D>();
	titleBackGround1_2->Initialize();
	titleBackGround1_2->SetModel("back1.obj");
	titleBackGround1_2Transform = {
		{ 1.0f,20.0f,10.0f },
		{ 0.0f,1.5f,0.0f },
		{ 65,-2.0f,50.0f }
	};
	titleBackGround1_2->SetTransform(titleBackGround1_2Transform);
	titleBackGround1_3 = std::make_unique<Object3D>();
	titleBackGround1_3->Initialize();
	titleBackGround1_3->SetModel("back1.obj");
	titleBackGround1_3Transform = {
		{ 1.0f,20.0f,10.0f },
		{ 0.0f,-1.5f,0.0f },
		{ 120,-2.0f,50.0f }
	};
	titleBackGround1_3->SetTransform(titleBackGround1_3Transform);

	titleBackGround1_4 = std::make_unique<Object3D>();
	titleBackGround1_4->Initialize();
	titleBackGround1_4->SetModel("back1.obj");
	titleBackGround1_4Transform = {
		{ 1.0f,20.0f,10.0f },
		{ 0.0f,1.5f,0.0f },
		{ 178,-2.0f,50.0f }
	};
	titleBackGround1_4->SetTransform(titleBackGround1_4Transform);

	skyBack = std::make_unique<Object3D>();
	skyBack->Initialize();
	skyBack->SetModel("BackSky.obj");
	skyBackTransform = {
		{ 400.0f,100.0f,1.0f },
		{ 0.0f,0.0f, 0.0f },
		{ 7.5f,0.0f,250.0f }
	};
	skyBack->SetTransform(skyBackTransform);

	// è¶³å ´ã€€åœŸ
	soil = std::make_unique<Object3D>();
	soil->Initialize();
	soil->SetModel("Grass.obj");
	soilTransform = {
		{ 40.0f,1.0f,2.0f },
		{ 0.0f,0.0f,0.0f },
		{ 0.0f,-8.0f,20.0f }
	};
	soil->SetTransform(soilTransform);
}


void BackGround::Update()
{
	skyBack->Update();

	// èƒŒæ™¯
	// å°‘ã—ã¥ã¤å·¦ã«æµã™ æ›´æ–°
	

	titleBackGround3->Update();
	titleBackGround3_2->Update();
	// 2
	//titleBackGround2Transform.translate.x -= 0.05f;
	//titleBackGround2_2Transform.translate.x -= 0.05f;
	//titleBackGround2_3Transform.translate.x -= 0.05f;
	//titleBackGround2->SetTransform(titleBackGround2Transform);
	//titleBackGround2_2->SetTransform(titleBackGround2_2Transform);
	//titleBackGround2_3->SetTransform(titleBackGround2_3Transform);
	titleBackGround2->Update();
	titleBackGround2_2->Update();
	titleBackGround2_3->Update();
	// 1

	titleBackGround1->Update();
	titleBackGround1_2->Update();
	titleBackGround1_3->Update();
	titleBackGround1_4->Update();
	soil->Update();

	DrawImgui();
}


void BackGround::Draw()
{
	skyBack->Draw();
	titleBackGround3->Draw();
	titleBackGround3_2->Draw();
	titleBackGround2->Draw();
	titleBackGround2_2->Draw();
	titleBackGround2_3->Draw();
	titleBackGround1->Draw();
	titleBackGround1_2->Draw();
	titleBackGround1_3->Draw();
	titleBackGround1_4->Draw();
	soil->Draw();
}

void BackGround::DrawImgui()
{
	// ImGuiã§å„èƒŒæ™¯ã®ä½ç½®èª¿æ•´

#ifdef USE_IMGUI

	// è¨­å®šã¨ã—ã¦ä¿å­˜
	ImGui::Begin("BackGround Transform");
	// èƒŒæ™¯3 srt
	Transform backGround3Transform = titleBackGround3->GetTransform();
	ImGui::DragFloat3("titleBackGround3 Scale", &backGround3Transform.scale.x, 0.1f);
	ImGui::DragFloat3("titleBackGround3 Rotate", &backGround3Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("titleBackGround3 Translate", &backGround3Transform.translate.x, 0.1f);
	titleBackGround3->SetTransform(backGround3Transform);


	ImGui::DragFloat3("titleBackGround3_2 Translate", &titleBackGround3_2Transform.translate.x, 0.1f);
	ImGui::DragFloat3("titleBackGround3_2 Rotate", &titleBackGround3_2Transform.rotate.x, 0.1f);
	titleBackGround3_2->SetTransform(titleBackGround3_2Transform);

	

	//èƒŒæ™¯2 srt
	titleBackGround2Transform = titleBackGround2->GetTransform();
	ImGui::DragFloat3("titleBackGround2 Translate", &titleBackGround2Transform.translate.x, 0.1f);
	titleBackGround2->SetTransform(titleBackGround2Transform);

	titleBackGround2_2Transform = titleBackGround2_2->GetTransform();
	ImGui::DragFloat3("titleBackGround2_2 Translate", &titleBackGround2_2Transform.translate.x, 0.1f);
	titleBackGround2_2->SetTransform(titleBackGround2_2Transform);
	
	titleBackGround2_3Transform = titleBackGround2_3->GetTransform();
	ImGui::DragFloat3("titleBackGround2_3 Translate", &titleBackGround2_3Transform.translate.x, 0.1f);
	titleBackGround2_3->SetTransform(titleBackGround2_3Transform);
	// èƒŒæ™¯1 srt
	Transform backGround1Transform = titleBackGround1->GetTransform();
	ImGui::DragFloat3("titleBackGround1 Scale", &backGround1Transform.scale.x, 0.1f);
	ImGui::DragFloat3("titleBackGround1 Rotate", &backGround1Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("titleBackGround1 Translate", &backGround1Transform.translate.x, 0.1f);
	titleBackGround1->SetTransform(backGround1Transform);
		



	// ã‚¹ã‚«ã‚¤ãƒãƒƒã‚¯ã€€
	ImGui::DragFloat3("SkyBack Translate", &skyBackTransform.translate.x, 0.1f);
	skyBack->SetTransform(skyBackTransform);
	// rotate
	ImGui::DragFloat3("SkyBack Rotate", &skyBackTransform.rotate.x, 0.1f);
	skyBack->SetTransform(skyBackTransform);
	// scale
	ImGui::DragFloat3("SkyBack Scale", &skyBackTransform.scale.x, 0.1f);
	skyBack->SetTransform(skyBackTransform);

	// Grassã®ä½ç½®èª¿æ•´
	ImGui::DragFloat3("Soil Translate", &soilTransform.translate.x, 0.1f);
	soil->SetTransform(soilTransform);
	// rotate
	ImGui::DragFloat3("Soil Rotate", &soilTransform.rotate.x, 0.1f);
	soil->SetTransform(soilTransform);
	// scale
	ImGui::DragFloat3("Soil Scale", &soilTransform.scale.x, 0.1f);
	soil->SetTransform(soilTransform);
	ImGui::End();
	


#endif


}


============================================================
File Path: Game/Application/BackGround.h
============================================================
#pragma once
#include "engine/3d/Object3D.h"
#include "engine/math/MyMath.h"
#include <memory>
/// <summary>
/// èƒŒæ™¯ã‚¯ãƒ©ã‚¹
/// å„ã‚¹ãƒ†ãƒ¼ã‚¸ã®èƒŒæ™¯ã‚’ç®¡ç†ã™ã‚‹
/// </summary>

class BackGround
{
public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();
	/// <summary>
	/// Imguiä¸€æ‹¬ç®¡ç† / æç”»é–¢æ•°
	/// </summary>
	void DrawImgui();
private:
	// ã‚¿ã‚¤ãƒˆãƒ«èƒŒæ™¯
	std::unique_ptr<Object3D> titleBackGround3;
	Transform titleBackGround3Transform;

	std::unique_ptr<Object3D> titleBackGround3_2;
	Transform titleBackGround3_2Transform;

	std::unique_ptr<Object3D> titleBackGround2;
	Transform titleBackGround2Transform;

	std::unique_ptr<Object3D> titleBackGround2_2;
	Transform titleBackGround2_2Transform;

	std::unique_ptr<Object3D> titleBackGround2_3;
	Transform titleBackGround2_3Transform;

	std::unique_ptr<Object3D> titleBackGround1;
	Transform titleBackGround1Transform;

	std::unique_ptr<Object3D> titleBackGround1_2;
	Transform titleBackGround1_2Transform;

	std::unique_ptr<Object3D> titleBackGround1_3;
	Transform titleBackGround1_3Transform;

	std::unique_ptr<Object3D> titleBackGround1_4;
	Transform titleBackGround1_4Transform;

	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆèƒŒæ™¯
	std::unique_ptr<Object3D> skyBack;
	Transform skyBackTransform;

	// è¶³å ´ã€€åœŸ
	std::unique_ptr<Object3D> soil;
	Transform soilTransform;
};



============================================================
File Path: Game/Application/Block/Block.cpp
============================================================
#include "Block.h"
#include "engine/3d/ModelManager.h"

void Block::OnCollision(Collider* other)
{

}


void Block::Initialize(BlockType blockType, Vector3 position) {

	/// ãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–
	this->blockType = blockType;
	blockModel = std::make_unique<Object3D>();
	blockModel->Initialize();
	transform = {
		// Scale
		{1.0f, 1.0f, 1.0f},
		// Rotate
		{0.0f, 0.0f, 0.0f},
		// Translate
		position
	};


	switch (this->blockType) {
	case BlockType::Air:
		break;
	case BlockType::GrassBlock:
		blockModel->SetModel("Grass.obj");
		break;
	case BlockType::SoilBlock:
		blockModel->SetModel("soil.obj");
		break;
	case BlockType::breakBlock:
		blockModel->SetModel("breakBlock.obj");
		break;
	case BlockType::moveBlock:
		blockModel->SetModel("moveBlock.obj");
		break;
	case BlockType::sandBlock:
		blockModel->SetModel("sand.obj");
		break;
	case BlockType::kGoalUp:
		blockModel->SetModel("GoalUp.obj");
		break;
	case BlockType::kGoalDown:
		blockModel->SetModel("GoalDown.obj");
		break;
	case BlockType::Unbreakable:
		blockModel->SetModel("Unbreakable.obj");
		break;
	default:
		blockModel->SetModel("null.obj");
		break;
	}
	blockModel->SetTransform(transform);


}



void Block::Update() {
	if (blockType == BlockType::Air || !isAlive_) return;
	// ç§»å‹•ãƒ–ãƒ­ãƒƒã‚¯ã®å‡¦ç†
	if (blockType == BlockType::moveBlock) {
		if (moveRight_) {
			moveTime_ += moveSpeed_;
			if (moveTime_ > 1.0f) {
				moveTime_ = 1.0f;
				moveRight_ = false; // å³ç«¯ã«åˆ°é”ã—ãŸã‚‰å·¦ã¸
			}
		} else {
			moveTime_ -= moveSpeed_;
			if (moveTime_ < 0.0f) {
				moveTime_ = 0.0f;
				moveRight_ = true; // å·¦ç«¯ã«åˆ°é”ã—ãŸã‚‰å³ã¸
			}
		}

		// ---- ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆeaseInOutSineï¼‰ ----
		// 0ï½1 â†’ 0ï½1ã¸æ»‘ã‚‰ã‹ã«è£œé–“
		float eased = 0.5f - 0.5f * cosf(moveTime_ * 3.14159f);

		// -range ï½ +range ã®ç¯„å›²ã§å¾€å¾©
		transform.translate.x = (eased * 2.0f - 1.0f) * moveRange_;

		// ãƒ¢ãƒ‡ãƒ«ã«åæ˜ 
		blockModel->SetTransform(transform);
	}
	blockModel->Update();
}

void Block::Draw() {
	// ãƒ–ãƒ­ãƒƒã‚¯ã®æç”» / æç”»å¯¾è±¡ãŒç„¡ã„å ´åˆã¨å£Šã‚Œã¦ã„ã‚‹å ´åˆã¯æç”»ã—ãªã„
	if (blockType == BlockType::Air || !isAlive_) return;
	blockModel->Draw();
}

Block* Block::CreateBlock(BlockType blockType, Vector3 position)
{
	// ãƒ–ãƒ­ãƒƒã‚¯ã®ç”Ÿæˆ
	Block* newBlock = new Block();
	// åˆæœŸåŒ–
	newBlock->Initialize(blockType, position);
	// ç”Ÿæˆã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿”ã™
	return newBlock;
}


============================================================
File Path: Game/Application/Block/Block.h
============================================================
#pragma once
#include "engine/3d/Object3D.h"
#include "BlockType.h"
#include "Game/Collision/Collider.h"
#include <memory>
class Block : public Collider
{
public: // åˆ¤å®š
	///
	///
	/// 
	void OnCollision(Collider* other) override;

	/// <summary>
	/// AABBã‚’å–å¾—
	/// </summary>
	/// <returns>AABB</returns>
	AABB GetAABB() const override {
		const Vector3 half = transform.scale * 0.5f; // â† ã“ã“ã‚’ *0.5f ã«
		return { transform.translate - half, transform.translate + half };
	}

	/// <summary>
	/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ç¨®é¡ã‚’å–å¾—
	/// </summary>
	Type GetType() const override { return Type::Static; }

public:
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize(BlockType blockType, Vector3 position);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®ç”Ÿæˆ
	/// </summary>
	static Block* CreateBlock(BlockType blockType, Vector3 position);

public:	// Setter / Getter
	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®SRTã‚’å–å¾—
	/// </summary>
	/// <returns>ãƒ–ãƒ­ãƒƒã‚¯ã®SRT</returns>
	const Transform& GetTransform() const { return transform; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®ç¨®é¡ã‚’å–å¾—
	/// </summary>
	/// <returns>ãƒ–ãƒ­ãƒƒã‚¯ã®ç¨®é¡</returns>
	BlockType GetBlockType() const { return blockType; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®Scaleã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	void SetScale(const Vector3& scale) { transform.scale = scale; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®Rotateã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	void SetRotate(const Vector3& rotate) { transform.rotate = rotate; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®Positionã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	void SetTranslate(const Vector3& position) { transform.translate = position; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®SRTã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	void SetTransform(const Transform& transform) { this->transform = transform; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ãŒå£Šã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹
	/// </summary>
	bool GetAliveBlock() const { return isAlive_; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã‚’å£Šã™
	/// </summary>
	void SetBroken() { isAlive_ = false; }


private:

	/// ãƒ–ãƒ­ãƒƒã‚¯ãƒ¢ãƒ‡ãƒ«
	std::unique_ptr<Object3D> blockModel;
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®ä½ç½®
	Transform transform;
	/// è¡¨ç¤ºã™ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã®ç¨®é¡
	BlockType blockType;
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
	AABB aabb;

	// ç§»å‹•ãƒ–ãƒ­ãƒƒã‚¯ç”¨å¤‰æ•°
	float moveRange_ = 3.0f;     // ç§»å‹•ç¯„å›²
	float moveSpeed_ = 0.01f;    // åŸºæœ¬é€Ÿåº¦
	float moveTime_ = 0.0f;      // æ™‚é–“ã‚«ã‚¦ãƒ³ã‚¿
	bool moveRight_ = true;      // ç¾åœ¨ã®ç§»å‹•æ–¹å‘ï¼ˆtrue:å³ / false:å·¦ï¼‰

	// ãƒ–ãƒ­ãƒƒã‚¯ãŒå£Šã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹
	bool isAlive_ = true;    

};



============================================================
File Path: Game/Application/Block/BlockType.h
============================================================
#pragma once

/// <summary>
/// ãƒ–ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ—åˆ—æŒ™å‹
/// ãƒ–ãƒ­ãƒƒã‚¯ã®ç¨®é¡ã‚’å®šç¾©ã™ã‚‹
/// </summary>

enum class BlockType
{
	Air = 0,
	GrassBlock = 1,
	SoilBlock = 2,
	kGoalUp = 3,
	kGoalDown = 4,
	breakBlock = 5,
	moveBlock = 6,
	sandBlock = 7,
	Unbreakable = 8,
	// ç¯„å›²æ¤œç´¢ã®æœ€çµ‚å€¤
	/// æ¤œç´¢ã‚’è¡Œã†éš›ã«Countã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ç¯„å›²æ¤œç´¢ã‚’å¯èƒ½ã«ã§ãã‚‹
	Count,	
};




// æ–°ã—ã„ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ ã™ã‚‹ã¨ãã¯ã€ä¸‹ã®ãƒªã‚¹ãƒˆã‚’ä¸Šã‹ã‚‰é †ã«ãƒã‚§ãƒƒã‚¯ã™ã‚Œã°OK
//
// BlockType ã«è¿½åŠ 
//
// enum class BlockType ã« Count ã®å‰ã§è¿½åŠ 
//
//	æ—¢å­˜ã®æ•°å€¤ã¯å¤‰ãˆãªã„
//
//	Map ã‚¯ãƒ©ã‚¹ ã® ImGui è¡¨ç¤ºåã‚’è¿½åŠ 
//
//	blockTypeNames[] ã« "NewBlockName" ã‚’è¿½åŠ 
//
//	ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ enum ã®å€¤ãŒå¯¾å¿œã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
//
//	è‰²ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¿½åŠ 
//
//	GetBlockColorByType(BlockType) ã® switch ã« case ã‚’è¿½åŠ 
//
//	ã‚°ãƒªãƒƒãƒ‰ãƒ»ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è‰²ã¯ã“ã“ã‚’ä½¿ã†ã‚ˆã†ã«çµ±ä¸€ã—ã¦ãŠã
//
//	ãƒãƒƒãƒ—ç”Ÿæˆ / è¦‹ãŸç›®
//
//	GenerateMapBlock() ãªã©ã®ãƒ–ãƒ­ãƒƒã‚¯ç”Ÿæˆå‡¦ç†ã® switch ã« case ã‚’è¿½åŠ 
//
//	æŒ™å‹• / å½“ãŸã‚Šåˆ¤å®šï¼ˆå¿…è¦ãªã‚‰ï¼‰
//
//	ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚„ã‚®ãƒŸãƒƒã‚¯ã®åˆ¤å®šã§ switch (blockType) ç­‰ã« case ã‚’è¿½åŠ 
//
//	CSVã®äº’æ›æ€§ãƒã‚§ãƒƒã‚¯
//
//	æ—¢å­˜ã® CSV ã‚’èª­ã¿è¾¼ã‚“ã§æƒ³å®šé€šã‚Šã®ãƒãƒƒãƒ—ã‹ç¢ºèª
//
//	ãŠã‹ã—ã‹ã£ãŸã‚‰ enum ã®é †ç•ªã‚„å€¤ã‚’ã„ã˜ã£ã¦ã„ãªã„ã‹ç¢ºèª

============================================================
File Path: Game/Application/Enemy/EnemyBase.cpp
============================================================
#include "EnemyBase.h"




============================================================
File Path: Game/Application/Enemy/EnemyBase.h
============================================================
#pragma once
#include "engine/math/MyMath.h"
#include "engine/3d/Object3D.h"
#include "Game/Collision/Collider.h"

/// <summary>
/// ã‚¨ãƒãƒŸãƒ¼ã®åŸºæœ¬æ§‹é€ 
/// ç¶™æ‰¿å…ƒã¨ã—ã¦ä½¿ç”¨ã™ã‚‹
/// </summary>

/// ã‚¨ãƒãƒŸãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
struct Stats {
	/// åº§æ¨™
	Transform transform;
	/// ç”Ÿå­˜ãƒ•ãƒ©ã‚°
	bool isAlive = true;
	/// é€Ÿåº¦
	Vector3 velocity;
	/// ä½“åŠ›
	uint32_t health;
	/// æ”»æ’ƒåŠ›
	int32_t attackPower;
};

class EnemyBase : public Collider
{

public:
	/// <summary>
	/// Enemy ã‚¯ãƒ©ã‚¹ã®ä»®æƒ³ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ­£ã—ãç ´æ£„ã•ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼
	/// </summary>
	virtual ~EnemyBase() = default;

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®åˆæœŸåŒ–
	/// </summary>
	virtual void Initialize() = 0;

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°å‡¦ç†
	/// </summary>
	virtual void Update() = 0;

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®æç”»å‡¦ç†
	/// </summary>
	virtual void Draw() = 0;

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®å‹•ä½œå‡¦ç†
	/// </summary>
	virtual void Move() = 0;

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®æ”»æ’ƒå‡¦ç†
	/// </summary>
	virtual void Action() = 0;

	/// Collider ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å®Ÿè£…
	Type GetType()const override { return Type::Enemy; }

	/// AABBã®å–å¾—
	AABB GetAABB() const override {
		const auto& t = stats.transform;
		return { t.translate - t.scale * 0.5f,
				t.translate + t.scale * 0.5f };
	}

	/// <summary>
	/// è¡çªæ™‚ã®å‡¦ç†
	/// </summary>
	/// <param name="other">ã©ã‚Œã¨åˆ¤å®šã‚’ã¨ã‚‹ã‹</param>
	void OnCollision(Collider* other) override {
		// è¡çªæ™‚ã®å‡¦ç†ã‚’å®Ÿè£…
		if (other->GetType() == Type::Player) {
			if (stats.health <= 0) {
				stats.isAlive = false; // ã‚¨ãƒãƒŸãƒ¼ãŒæ­»äº¡
			}
		}
	}

	/// ã‚¨ãƒãƒŸãƒ¼ã®ç”Ÿå­˜ãƒ•ãƒ©ã‚°è¨­å®š/å–å¾—
	bool IsAlive() const { return stats.isAlive; }


	/// ã‚¨ãƒãƒŸãƒ¼ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ è¨­å®š/å–å¾—
	virtual void SetTransform(const Transform& transform) { stats.transform = transform; }
	virtual Transform GetTransform() const { return stats.transform; }
	/// ã‚¨ãƒãƒŸãƒ¼ã®SRTè¨­å®š/å–å¾—
	virtual void SetScale(const Vector3& scale) { stats.transform.scale = scale; }
	virtual Vector3 GetScale() const { return stats.transform.scale; }
	virtual void SetRotate(const Vector3& rotate) { stats.transform.rotate = rotate; }
	virtual Vector3 GetRotate() const { return stats.transform.rotate; }
	virtual void SetTranslate(const Vector3& translate) { stats.transform.translate = translate; }
	virtual Vector3 GetTranslate() const { return stats.transform.translate; }

protected:
	/// ã‚¨ãƒãƒŸãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	Stats stats;
	/// ã‚¨ãƒãƒŸãƒ¼ã®3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3D> model;
};



============================================================
File Path: Game/Application/Enemy/EnemyFactory.cpp
============================================================
#include "EnemyFactory.h"
#include <Logger.h>

std::unique_ptr<EnemyBase> EnemyFactory::CreateEnemy(const std::string& type)
{
	if(type == "NormalEnemy")
	{
		auto enemy = std::make_unique<NormalEnemy>();
		return enemy;
	}
	else if(type == "FlyingEnemy")
	{
		auto enemy = std::make_unique<FlyingEnemy>();
		return enemy;
	}
	Logger::Log("\nEnemy generation failed\nNo matching data found\n		or\nSpelling error\n\n");
	return nullptr; // å¯¾å¿œã™ã‚‹ã‚¨ãƒãƒŸãƒ¼ãŒãªã„å ´åˆã¯nullptrã‚’è¿”ã™
}


============================================================
File Path: Game/Application/Enemy/EnemyFactory.h
============================================================
#pragma once
#include <memory>

/// <summary>
/// ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¡ã‚½ãƒƒãƒ‰ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼éƒ¨åˆ†
/// ã‚¨ãƒãƒŸãƒ¼ã‚’ç”Ÿæˆã™ã‚‹
/// </summary>

/// ã‚¨ãƒãƒŸãƒ¼å…¨ã¦ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚¯ãƒ©ã‚¹
#include "EnemyBase.h"
#include "NormalEnemy.h"
#include "FlyingEnemy.h"
class EnemyFactory
{
public:
	/// <summary>
	///  ã‚¨ãƒãƒŸãƒ¼ã‚’ç”Ÿæˆã™ã‚‹ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
	/// </summary>
	/// <param name="type">ç”Ÿæˆã™ã‚‹ã‚¨ãƒãƒŸãƒ¼ã®åå‰</param>
	/// <returns>ã‚¨ãƒãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹</returns>
	static std::unique_ptr<EnemyBase> CreateEnemy(const std::string& type);

};



============================================================
File Path: Game/Application/Enemy/EnemyType.h
============================================================
#pragma once


enum class EnemyType {

	None = 0,
	NormalEnemy = 1,
	FlyingEnemy = 2,
};

============================================================
File Path: Game/Application/Enemy/FlyingEnemy.cpp
============================================================
#include "FlyingEnemy.h"

void FlyingEnemy::Initialize()
{
	/// @ä»®ã‚¹ã‚¿ãƒƒãƒ„
	stats = {
		// scale
		{{1.0f, 1.0f, 1.0f},
		// Rotate
		{0.0f, 0.0f, 0.0f},
		// Translate
		//{5.0f, -3.0f, 0.0f},
		},
		// ç”Ÿå­˜ãƒ•ãƒ©ã‚°
		true,
		// é€Ÿåº¦
		{0.1f, 0.1f, 0.0f},
		// ä½“åŠ›
		1,
		// æ”»æ’ƒåŠ›
		1
	};
	
	timer = 0.0f;
	

	/// Object3Dã®åˆæœŸåŒ–
	model = std::make_unique<Object3D>();
	model->Initialize();
	/// ãƒ¢ãƒ‡ãƒ«ã®è¨­å®š
	model->SetModel("Tentativeenemy.obj");
	/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®è¨­å®š
	model->SetTransform(stats.transform);

	baseY = stats.transform.translate.y;
}


void FlyingEnemy::Update()
{
	if (stats.isAlive) {
		/// æŒ™å‹•å‡¦ç†
		Move();
		/// æ”»æ’ƒå‡¦ç†
		Action();
		/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®åæ˜ 
		model->SetTransform(stats.transform);
		/// ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
		model->Update();
	}
}

void FlyingEnemy::Draw()
{
	if (stats.isAlive) {
		/// ãƒ¢ãƒ‡ãƒ«ã®æç”»
		model->Draw();
	}
}

void FlyingEnemy::Move()
{
	/// ä¸Šä¸‹ç§»å‹•é‡
	const float amplitude = 3.0f;   
	const float frequency = 0.01f;  

	timer += frequency; 
	float offsetY = std::sin(timer * 2.0f * 3.14159265f) * amplitude;

	stats.transform.translate.y = baseY + offsetY;

	model->SetTransform(stats.transform);
	
}

void FlyingEnemy::Action()
{
	
}



============================================================
File Path: Game/Application/Enemy/FlyingEnemy.h
============================================================
#pragma once
#include "EnemyBase.h"
/// åŸºåº•ã‚¯ãƒ©ã‚¹<BaseEnemy>ã‚’ç¶™æ‰¿
class FlyingEnemy :
    public EnemyBase
{
    public:
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize() override;
    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update() override;
    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    void Draw() override;
    /// <summary>
    /// å‹•ä½œå‡¦ç†
    /// </summary>
    void Move() override;
    /// <summary>
    /// æ”»æ’ƒå‡¦ç†
    /// </summary>
	void Action() override;


private:
    /// å…ƒã®é«˜ã•ï¼ˆåˆæœŸä½ç½®Yï¼‰
    float baseY;         
    float timer = 0.0f;


    


};



============================================================
File Path: Game/Application/Enemy/NormalEnemy.cpp
============================================================
#include "NormalEnemy.h"

void NormalEnemy::Initialize()
{
	/// @ä»®ã‚¹ã‚¿ãƒƒãƒ„
	stats = {
		// scale
		{{1.0f, 1.0f, 1.0f},
		// Rotate
		{0.0f, 0.0f, 0.0f},
		// Translate
		{4.0f, -3.0f, 20.0f}
		},
		// ç”Ÿå­˜ãƒ•ãƒ©ã‚°
		true,
		// é€Ÿåº¦
		{0.1f, 0.1f, 0.0f},
		// ä½“åŠ›
		1,
		// æ”»æ’ƒåŠ›
		1
	};

	/// Object3Dã®åˆæœŸåŒ–
	model = std::make_unique<Object3D>();
	model->Initialize();
	/// ãƒ¢ãƒ‡ãƒ«ã®è¨­å®š
	model->SetModel("Tentativeenemy.obj");
	/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®è¨­å®š
	model->SetTransform(stats.transform);
}

void NormalEnemy::Update()
{
	if (stats.isAlive) {
		/// æŒ™å‹•å‡¦ç†
		Move();
		/// æ”»æ’ƒå‡¦ç†
		Action();
		/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®åæ˜ 
		model->SetTransform(stats.transform);
		/// ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
		model->Update();
	}
	
}

void NormalEnemy::Draw()
{
	if (stats.isAlive) {
		/// ãƒ¢ãƒ‡ãƒ«ã®æç”»
		model->Draw();
	}
}

void NormalEnemy::Move()
{
}

void NormalEnemy::Action()
{
}


============================================================
File Path: Game/Application/Enemy/NormalEnemy.h
============================================================
#pragma once
#include "EnemyBase.h"
/// åŸºåº•ã‚¯ãƒ©ã‚¹<Bas8eEnemy>ã‚’ç¶™æ‰¿
/// ãƒãƒ¼ãƒãƒ«ã‚¨ãƒãƒŸãƒ¼ã‚¯ãƒ©ã‚¹
class NormalEnemy :
	public EnemyBase
{
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize() override;
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;
	/// <summary>
	///  æç”»å‡¦ç†
	/// </summary>
	void Draw() override;
	/// <summary>
	/// å‹•ä½œå‡¦ç†
	/// </summary>
	void Move() override;
	/// <summary>
	/// æ”»æ’ƒå‡¦ç†
	/// </summary>
	void Action() override;



};



============================================================
File Path: Game/Application/Map/CsvLoader.cpp
============================================================
#include "CsvLoader.h"
#include "Game/Application/Block/Block.h"

const std::string CsvLoader::frontFilePath = "resources/MapData/";
const std::string CsvLoader::extensionCsv_ = ".csv";



std::vector<std::vector<int>> CsvLoader::LoadMapInt(const std::string& filePath)
{
	// èª­ã¿è¾¼ã‚“ã ã‚‚ã®ã‚’æ ¼ç´ã™ã‚‹å¤‰æ•°
	std::vector<std::vector<int>> mapData;
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	std::ifstream file(frontFilePath+filePath);

	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸå ´åˆã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
	if (!file.is_open()) {
		throw std::runtime_error("CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ã¾ã›ã‚“: " + filePath);
	}
	// 1è¡Œãšã¤èª­ã¿è¾¼ã‚€
	std::string line;
	while (std::getline(file, line)) {
		std::vector<int> row;
		std::stringstream ss(line);
		std::string value;

		while (std::getline(ss, value, ',')) {

			// æ–‡å­—åˆ—ã‚’æ•´æ•°ã«å¤‰æ›
			row.push_back(std::stoi(value));

		}
		mapData.push_back(row);
	}
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã‚‹
	file.close();
	// èª­ã¿è¾¼ã‚“ã ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
	return mapData;

}

std::vector<std::vector<BlockType>> CsvLoader::LoadMapBlockType(const std::string& filePath)
{
	// èª­ã¿è¾¼ã‚“ã ç‰©ã‚’æ ¼ç´ã™ã‚‹å¤‰æ•°	
	std::vector<std::vector<BlockType>> mapData;
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	std::ifstream file(frontFilePath + filePath + extensionCsv_);
	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸå ´åˆã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
	if (!file.is_open()) {
		// ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ãŒå­˜åœ¨ã—ãªã„ã‚‚ã—ãã¯é–‹ã‘ãªã‹ã£ãŸå ´åˆã®ã‚¨ãƒ©ãƒ¼å‡¦ç†
		throw std::runtime_error("CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ã¾ã›ã‚“: " + filePath);
	}
	// 1è¡Œãšã¤èª­ã¿è¾¼ã‚€
	std::string line;
	// å„è¡Œã‚’ã‚«ãƒ³ãƒã§åŒºåˆ‡ã£ã¦å‡¦ç†
	while (std::getline(file, line)) {
		std::vector<BlockType> row;
		std::stringstream ss(line);
		std::string value;
		// ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸå„å€¤ã‚’å‡¦ç†
		while (std::getline(ss, value, ',')) {
			// æ–‡å­—åˆ—ã‚’intã«å¤‰æ›ã—ã€ãã‚Œã‚’BlockTypeã¸å¤‰æ›
			int intVal = std::stoi(value);
			BlockType type = static_cast<BlockType>(intVal);
			row.push_back(type);
		}
		// è¡Œã‚’mapDataã«è¿½åŠ 
		mapData.push_back(row);
	}

	file.close();
	return mapData;
}

std::vector<std::vector<EnemyType>> CsvLoader::LoadMapEnemyType(const std::string& filePath)
{
	// èª­ã¿è¾¼ã‚“ã ç‰©ã‚’æ ¼ç´ã™ã‚‹å¤‰æ•°	
	std::vector<std::vector<EnemyType>> enemyData;
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	std::ifstream file(frontFilePath + filePath + extensionCsv_);
	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸå ´åˆã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
	if (!file.is_open()) {
		throw std::runtime_error("CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ã¾ã›ã‚“: " + filePath);
	}
	// 1è¡Œãšã¤èª­ã¿è¾¼ã‚€
	std::string line;
	// å„è¡Œã‚’ã‚«ãƒ³ãƒã§åŒºåˆ‡ã£ã¦å‡¦ç†
	while (std::getline(file, line)) {
		std::vector<EnemyType> row;
		std::stringstream ss(line);
		std::string value;
		// ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸå„å€¤ã‚’å‡¦ç†
		while (std::getline(ss, value, ',')) {
			// æ–‡å­—åˆ—ã‚’intã«å¤‰æ›ã—ã€ãã‚Œã‚’BlockTypeã¸å¤‰æ›
			int intVal = std::stoi(value);
			EnemyType type = static_cast<EnemyType>(intVal);
			row.push_back(type);
		}
		// è¡Œã‚’enemyDataã«è¿½åŠ 
		enemyData.push_back(row);
	}

	file.close();
	return enemyData;
}

void CsvLoader::SaveMapBlockType(
	const std::string& filePath,
	const std::vector<std::vector<BlockType>>& mapData)
{
	// frontFilePath ã‚’ä½¿ã£ã¦ã„ã‚‹ãªã‚‰èª­ã¿è¾¼ã¿ã¨åŒã˜ã‚ˆã†ã«
	std::string filePathFull = frontFilePath + filePath;
	std::ofstream file(filePathFull);

	if (!file.is_open()) {
		throw std::runtime_error("CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãè¾¼ã¿ç”¨ã«é–‹ã‘ã¾ã›ã‚“: " + filePath);
	}
	// è¡Œã”ã¨ã«ãƒ«ãƒ¼ãƒ—
	const uint32_t height = static_cast<uint32_t>(mapData.size());
	for (uint32_t y = 0; y < height; ++y) {
		const uint32_t width = static_cast<uint32_t>(mapData[y].size());
		for (uint32_t x = 0; x < width; ++x) {
			int val = static_cast<int>(mapData[y][x]);
			file << val;
			if (x < width - 1) {
				file << ",";        // ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š
			}
		}
		file << "\n";               // è¡Œã”ã¨ã«æ”¹è¡Œ
	}
}

void CsvLoader::SaveMapEnemyType(
	const std::string& filePath, 
	const std::vector<std::vector<EnemyType>>& enemyData)
{

	// frontFilePath ã‚’ä½¿ã£ã¦ã„ã‚‹ãªã‚‰èª­ã¿è¾¼ã¿ã¨åŒã˜ã‚ˆã†ã«
	std::string filePathFull = frontFilePath + filePath;
	std::ofstream file(filePathFull);
	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸå ´åˆã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
	if (!file.is_open()) {
		throw std::runtime_error("CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãè¾¼ã¿ç”¨ã«é–‹ã‘ã¾ã›ã‚“: " + filePath);
	}
	// è¡Œã”ã¨ã«ãƒ«ãƒ¼ãƒ—
	const uint32_t height = static_cast<uint32_t>(enemyData.size());
	for (uint32_t y = 0; y < height; ++y) {
		const uint32_t width = static_cast<uint32_t>(enemyData[y].size());
		for (uint32_t x = 0; x < width; ++x) {
			int val = static_cast<int>(enemyData[y][x]);
			file << val;
			if (x < width - 1) {
				file << ",";        // ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š
			}
		}
		file << "\n";               // è¡Œã”ã¨ã«æ”¹è¡Œ
	}

}



============================================================
File Path: Game/Application/Map/CsvLoader.h
============================================================
#pragma once
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include "Game/Application/Block/BlockType.h"
#include "Game/Application/Enemy/EnemyType.h"

class CsvLoader
{
public:
	CsvLoader() = default;
	~CsvLoader() = default;
	/// <summary>
	/// csvãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="filePath"></param>
	/// <returns></returns>
	std::vector<std::vector<int>> LoadMapInt(const std::string& filePath);
	std::vector<std::vector<BlockType>> LoadMapBlockType(const std::string& filePath);

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	/// </summary>
	std::vector<std::vector<EnemyType>> LoadMapEnemyType(const std::string& filePath);

	/// <summary>
	/// ç¾åœ¨ã®ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜
	/// </summary>
	static void SaveMapBlockType(const std::string& filePath,
		const std::vector<std::vector<BlockType>>& mapData);

	static void SaveMapEnemyType(const std::string& filePath,
		const std::vector<std::vector<EnemyType>>& enemyData);
private:
	static const std::string frontFilePath;
	static const std::string extensionCsv_;

};



============================================================
File Path: Game/Application/Map/Map.cpp
============================================================
#include "Map.h"
#ifdef USE_IMGUI
#include "engine/base/ImGuiManager.h"
#endif
#include "Game/Particle/ParticleManager.h"

#ifdef USE_IMGUI
// ãƒ–ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸè‰²ã‚’å–å¾—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
ImVec4 GetBlockColorByType(BlockType blockType) {
	switch (blockType) {
	case BlockType::Air:         return ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
	case BlockType::GrassBlock: return ImVec4(0.4f, 0.4f, 0.8f, 1.0f);
	case BlockType::SoilBlock:   return ImVec4(0.8f, 0.4f, 0.4f, 1.0f);
	case BlockType::kGoalUp:     return ImVec4(0.4f, 0.8f, 0.4f, 1.0f);
	case BlockType::kGoalDown:   return ImVec4(0.4f, 0.8f, 0.8f, 1.0f);
	case BlockType::breakBlock:  return ImVec4(0.8f, 0.8f, 0.4f, 1.0f);
	case BlockType::moveBlock:   return ImVec4(0.8f, 0.4f, 0.8f, 1.0f);
	case BlockType::sandBlock:   return ImVec4(0.7f, 0.6f, 0.3f, 1.0f);
	case BlockType::Unbreakable: return ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
	default:                     return ImVec4(0.5f, 0.5f, 0.5f, 1.0f);
	}
}
#endif

void Map::Initialize(const std::string& mapFilePath)
{
	// ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	mapChipData_.mapData.resize(kMapHeight, std::vector<BlockType>(kMapWidth, BlockType::Air));

	// ãƒãƒƒãƒ—ç•ªå·ã®ä¿å­˜
	mapNumber_ = mapFilePath;

	// ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	LoadMapData(mapFilePath);

	// ãƒãƒƒãƒ—ãƒ–ãƒ­ãƒƒã‚¯ã®ç”Ÿæˆ
	GenerateMapBlock();

	// ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®å¤‰æ›´æ¤œçŸ¥
	previousMapData_ = mapChipData_;

	ParticleManager::GetInstance()->CreateParticleGroup(
        "BreakParticle", "resources/BackSky.png");
	breakParticleEmitter_ = std::make_unique<ParticleSystem>();
	breakParticleEmitter_->SetParticleName("BreakParticle");
	breakParticleEmitter_->SetScale({ 0.2f, 0.2f, 0.2f });
    
}


void Map::Update()
{
    //breakParticleEmitter_->Update();
    // ãƒãƒƒãƒ—ã®æ›´æ–°
    for (std::vector <Block*>& row : blockArray_) {
        for (Block* block : row) {
            if (!block) {
                continue;
            }
            block->Update();
        }
    }
	
#ifdef USE_IMGUI
    //  ã“ã“ã‹ã‚‰ ImGui éƒ¨åˆ†ã‚’ã€Œ1ã¤ã®ã‚¿ãƒ–ä»˜ãã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã€ã«çµ±åˆ

    // 1ã¤ã®ã‚¿ãƒ–ã«ã¾ã¨ã‚ã‚‹
    ImGui::Begin("Map Tools"); 

    if (ImGui::BeginTabBar("MapTabs"))
    {
        // ã‚¿ãƒ–1: Map Info
        if (ImGui::BeginTabItem("Info"))
        {
            ImGui::Text("Map Width: %d", GetWidth());
            ImGui::Text("Map Height: %d", GetHeight());
            ImGui::EndTabItem();
        }

        
        // ã‚¿ãƒ–2: Block Editor 
        if (ImGui::BeginTabItem("Block Editor"))
        {
            // â‘  ä¸€ç•ªä¸Šã«ã€Œä¿å­˜ / ãƒ­ãƒ¼ãƒ‰ã¾ã‚ã‚Šã€ã®UI
            static char mapFileName[256] = ".csv"; 
            static std::string mapFileMessage;

            ImGui::Text("Map CSV File:");
            ImGui::SameLine();
            ImGui::InputText("##MapFile", mapFileName, IM_ARRAYSIZE(mapFileName));

            // --- ä¿å­˜ãƒœã‚¿ãƒ³ ---
            if (ImGui::Button("Save Map CSV")) {
                try {
                    CsvLoader::SaveMapBlockType(mapFileName, mapChipData_.mapData);
                    mapFileMessage = std::string("Saved: ") + mapFileName;
                }
                catch (const std::exception& e) {
                    mapFileMessage = std::string("Save Failed: ") + e.what();
                }
            }

            ImGui::SameLine();

            // --- ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ ---
            if (ImGui::Button("Load Map CSV")) {
                try {
                    // "1_1.csv" â†’ "1_1" ã«å¤‰æ›ã—ã¦ã€ã‚²ãƒ¼ãƒ æœ¬ç·¨ã¨åŒã˜å½¢å¼ã§èª­ã‚€
                    std::string baseName = mapFileName;
                    size_t dotPos = baseName.rfind('.');
                    if (dotPos != std::string::npos) {
                        baseName = baseName.substr(0, dotPos);
                    }

                    // ãƒãƒƒãƒ—ï¼†ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å†èª­ã¿è¾¼ã¿
                    LoadMapData(baseName.c_str());

                    // ãƒãƒƒãƒ—ãƒ–ãƒ­ãƒƒã‚¯ã‚‚ä½œã‚Šç›´ã™
                    GenerateMapBlock();

                    mapFileMessage = std::string("Loaded: ") + mapFileName;
                }
                catch (const std::exception& e) {
                    mapFileMessage = std::string("Load Failed: ") + e.what();
                }
            }

            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
            if (!mapFileMessage.empty()) {
                ImGui::SameLine();
                ImGui::Text("%s", mapFileMessage.c_str());
            }

            ImGui::Separator();

            // â‘¡ ã“ã“ã‹ã‚‰ä¸‹ã¯ã€Œç·¨é›†UIã€ã¨ã€Œã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºã€

            // ãƒ–ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ—é¸æŠç”¨ã®ã‚³ãƒ³ãƒœ
            static int currentTypeInt = 0;
            const char* blockTypeNames[] = {
                "Air",
                "GrassBlock",
                "SoilBlock",
                "GoalUp",
                "GoalDown",
                "BreakBlock",
                "MoveBlock",
                "SandBlock",
				"Unbreakable",
            };

            ImGui::Text("Paint Type:");
            ImGui::SameLine();
            ImGui::Combo("##PaintType",
                &currentTypeInt,
                blockTypeNames,
                IM_ARRAYSIZE(blockTypeNames));

            ImGui::Separator();
            ImGui::Text("Map Grid");

            ImGui::BeginChild("MapGrid", ImVec2(0, 260), true, ImGuiWindowFlags_HorizontalScrollbar);

            const float cellSize = 20.0f;
            uint32_t mapHeight = GetHeight();
            uint32_t mapWidth = GetWidth();

            for (uint32_t y = 0; y < mapHeight; ++y) {
                for (uint32_t x = 0; x < mapWidth; ++x) {

                    BlockType& cell = mapChipData_.mapData[y][x];

                    ImGui::PushID(static_cast<int>(y * mapWidth + x));

                    ImVec4 color = GetBlockColorByType(cell);
                    ImGui::PushStyleColor(ImGuiCol_Button, color);
                    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, color);
                    ImGui::PushStyleColor(ImGuiCol_ButtonActive, color);

                    std::string label = std::to_string(static_cast<int>(cell));

                    // ãƒœã‚¿ãƒ³ã¯è¦‹ãŸç›®ç”¨ã¨ã—ã¦æŠ¼ã™ã ã‘
                    ImGui::Button(label.c_str(), ImVec2(cellSize, cellSize));

                    // ã‚¨ãƒãƒŸãƒ¼ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã¨åŒã˜ãƒ‰ãƒ©ãƒƒã‚°å¡—ã‚Š
                    if (ImGui::IsItemHovered() && ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
                        cell = static_cast<BlockType>(currentTypeInt);
                        isMapDataChanged_ = true;
                    }

                    ImGui::PopStyleColor(3);
                    ImGui::PopID();

                    if (x < mapWidth - 1) {
                        ImGui::SameLine();
                    }
                }
            }

            ImGui::EndChild();


            

            ImGui::EndTabItem();
        }


        // ã‚¿ãƒ–3: Enemy Layer
        if (ImGui::BeginTabItem("Enemy Layer"))
        {
            // ã‚¨ãƒãƒŸãƒ¼ã‚¿ã‚¤ãƒ—ä¸€è¦§
            static int currentEnemyTypeInt = 0;
            const char* enemyTypeNames[] = {
                "None",
                "NormalEnemy",
                "FlyingEnemy",
            };

            ImGui::Text("Paint Enemy Type:");
            ImGui::SameLine();
            ImGui::Combo("##EnemyType",
                &currentEnemyTypeInt,
                enemyTypeNames,
                IM_ARRAYSIZE(enemyTypeNames));

            // ãƒ•ã‚¡ã‚¤ãƒ«åå…¥åŠ›ï¼‹ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰
            static char enemyFileName[256] = "stage01_EnemyLayer.csv";
            ImGui::InputText("EnemyLayer File", enemyFileName, IM_ARRAYSIZE(enemyFileName));

            static std::string enemyLayerMessage;

            // ã‚»ãƒ¼ãƒ–ãƒœã‚¿ãƒ³
            if (ImGui::Button("Save Enemy CSV")) {
                try {
                    CsvLoader::SaveMapEnemyType(enemyFileName, enemyLayerData_.enemyData);
                    enemyLayerMessage = std::string("Saved: ") + enemyFileName;
                }
                catch (const std::exception& e) {
                    enemyLayerMessage = std::string("Save Failed: ") + e.what();
                }
            }

            ImGui::SameLine();

            // ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
            if (ImGui::Button("Load Enemy CSV")) {
                try {
                    // æ‹¡å¼µå­ .csv ã‚’å¤–ã—ã¦ Load ç”¨ã®ãƒ™ãƒ¼ã‚¹åã‚’ä½œã‚‹
                    std::string baseName = enemyFileName;
                    size_t dotPos = baseName.rfind('.');
                    if (dotPos != std::string::npos) {
                        baseName = baseName.substr(0, dotPos);
                    }

                    CsvLoader loader;
                    // LoadMapEnemyType ã¯ frontFilePath + baseName + ".csv" ã‚’èª­ã‚€
                    enemyLayerData_.enemyData = loader.LoadMapEnemyType(baseName);

                    // æ•µãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ›´æ–°ã•ã‚ŒãŸã“ã¨ã‚’è¨˜éŒ²
                    enemyLayerDirty_ = true;

                    enemyLayerMessage = std::string("Loaded: ") + enemyFileName;
                }
                catch (const std::exception& e) {
                    enemyLayerMessage = std::string("Load Failed: ") + e.what();
                }
            }

            if (!enemyLayerMessage.empty()) {
                ImGui::Text("%s", enemyLayerMessage.c_str());
            }

            // ã‚¨ãƒãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å‚ç…§
            auto& enemyLayer = enemyLayerData_.enemyData;

            // ã‚°ãƒªãƒƒãƒ‰æç”»å‰ã«ç©ºãƒã‚§ãƒƒã‚¯
            if (enemyLayer.empty() || enemyLayer[0].empty()) {
                ImGui::Text("Enemy layer is empty or not loaded.");
            } else {
                uint32_t enemyLayerHeight = static_cast<uint32_t>(enemyLayer.size());
                uint32_t enemyLayerWidth = static_cast<uint32_t>(enemyLayer[0].size());

                const float cellSize = 20.0f;

                // ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
                ImGui::BeginChild("EnemyLayerGrid", ImVec2(0, 260), true, ImGuiWindowFlags_HorizontalScrollbar);

                for (uint32_t y = 0; y < enemyLayerHeight; ++y) {
                    for (uint32_t x = 0; x < enemyLayerWidth; ++x) {

                        EnemyType& cell = enemyLayer[y][x];
                        uint32_t cellInt = static_cast<uint32_t>(cell);

                        ImGui::PushID(static_cast<int>(y * enemyLayerWidth + x));

                        ImVec4 color;
                        switch (cell) {
                        case EnemyType::NormalEnemy: color = ImVec4(0.2f, 0.8f, 0.2f, 1.0f); break;
                        case EnemyType::FlyingEnemy: color = ImVec4(0.2f, 0.4f, 1.0f, 1.0f); break;
                        default:                     color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f); break;
                        }

                        ImGui::PushStyleColor(ImGuiCol_Button, color);
                        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, color);
                        ImGui::PushStyleColor(ImGuiCol_ButtonActive, color);

                        std::string label = std::to_string(cellInt);
                        ImGui::Button(label.c_str(), ImVec2(cellSize, cellSize));

                        // å·¦ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒä¹—ã£ã¦ã„ãŸã‚‰å¡—ã‚‹
                        if (ImGui::IsItemHovered() && ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
                            cell = static_cast<EnemyType>(currentEnemyTypeInt);
                        }

                        ImGui::PopStyleColor(3);
                        ImGui::PopID();

                        if (x < enemyLayerWidth - 1) {
                            ImGui::SameLine();
                        }
                    }
                }

                ImGui::EndChild();
            }

            ImGui::EndTabItem();
        }
		// ã‚¿ãƒ–4: Map Preview
        if (ImGui::BeginTabItem("Map Preview"))
        {
            ImGui::Text("Map Preview (Read-Only)");
            ImGui::BeginChild("MapPreview", ImVec2(0, 400), true, ImGuiWindowFlags_HorizontalScrollbar);
            const float cellSize = 20.0f;
            uint32_t mapHeight = GetHeight();
            uint32_t mapWidth = GetWidth();
            for (uint32_t y = 0; y < mapHeight; ++y) {
                for (uint32_t x = 0; x < mapWidth; ++x) {
                    BlockType cell = mapChipData_.mapData[y][x];
                    ImGui::PushID(static_cast<int>(y * mapWidth + x));
                    ImVec4 color = GetBlockColorByType(cell);
                    ImGui::PushStyleColor(ImGuiCol_Button, color);
                    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, color);
                    ImGui::PushStyleColor(ImGuiCol_ButtonActive, color);
                    std::string label = std::to_string(static_cast<int>(cell));
                    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒœã‚¿ãƒ³ï¼ˆæŠ¼ã›ãªã„ï¼‰
                    ImGui::Button(label.c_str(), ImVec2(cellSize, cellSize));
                    ImGui::PopStyleColor(3);
                    ImGui::PopID();
                    if (x < mapWidth - 1) {
                        ImGui::SameLine();
                    }
                }
            }
            ImGui::EndChild();
            ImGui::EndTabItem();
		}

        ImGui::EndTabBar();
    }

    ImGui::End(); // "Map Tools"

    // â–²â–²â–² ImGui çµ±åˆã“ã“ã¾ã§ â–²â–²â–²

#endif // USE_IMGUI
    // æœ«å°¾ã«è¿½åŠ ï¼šæ­»ã‚“ã ãƒ–ãƒ­ãƒƒã‚¯ã ã‘å›å
    for (auto& row : blockArray_) {
        for (Block*& block : row) {
            if (block && !block->GetAliveBlock()) {
                delete block;
                block = nullptr;
            }
        }
    }

}



void Map::Draw()
{
	// ãƒãƒƒãƒ—ã®æç”»
	for (std::vector <Block*>& row : blockArray_) {
		for (Block* block : row) {
			if (!block) {
				continue;
			}
			block->Draw();
		}
	}
	
}

void Map::Finalize()
{
	// ãƒãƒƒãƒ—ãƒ–ãƒ­ãƒƒã‚¯ã®è§£æ”¾
	for (std::vector <Block*>& row : blockArray_) {
		for (Block* block : row) {
			if (block) {
				delete block;
				block = nullptr;
			}
		}
	}
}

void Map::GenerateMapBlock()
{
	const uint32_t h = GetHeight();
	const uint32_t w = GetWidth();

	// æ—¢å­˜ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾
	for (auto& row : blockArray_) {
		for (Block*& block : row) {
			if (block) {
				delete block;
				block = nullptr;
			}
		}
	}
	// ãƒã‚¤ãƒ³ã‚¿ã‚’è§£æ”¾ã—ãŸã®ã§é…åˆ—è‡ªä½“ã‚‚ã‚¯ãƒªã‚¢
	blockArray_.clear();

	// æ–°ã—ã„ã‚µã‚¤ã‚ºã§é…åˆ—ã‚’ä½œã‚Šç›´ã™
	blockArray_.assign(h, std::vector<Block*>(w, nullptr));

	// ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆ
	for (uint32_t y = 0; y < h; ++y) {
		for (uint32_t x = 0; x < w; ++x) {
			const BlockType type = mapChipData_.mapData[y][x];
			if (type == BlockType::Air) {
				continue;
			}
			// ãƒ–ãƒ­ãƒƒã‚¯ã®ç”Ÿæˆ
			Vector3 pos = GetMapChipPositionByIndex(x, y);
			pos.x += blockOffset_;
			pos.y -= blockOffset_;
			blockArray_[y][x] = Block::CreateBlock(type, pos);
		}
	}
}

void Map::GenerateEnemyLayer()
{
	const uint32_t h = GetHeight();
	const uint32_t w = GetWidth();

	// ã‚¨ãƒãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ•µã‚’ç”Ÿæˆ
	for (uint32_t y = 0; y < h; y++) {
		for(uint32_t x = 0; x < w; x++) {
			const EnemyType type = enemyLayerData_.enemyData[y][x];
			if (type == EnemyType::None) {
				continue;
			}
			// æ•µã®ç”Ÿæˆ
			Vector3 pos = GetMapChipPositionByIndex(x, y);
			pos.x += blockOffset_;
			pos.y -= blockOffset_;
		}
	}
}


void Map::LoadMapData(const std::string& mapFilePath)
{
	// CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
	CsvLoader csvLoader;
	mapChipData_.mapData = csvLoader.LoadMapBlockType(mapFilePath);

	std::string enemyLayerFilePath = mapFilePath + std::string("_EnemyLayer");
	// æ•µãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	enemyLayerData_.enemyData = csvLoader.LoadMapEnemyType(enemyLayerFilePath);


}





IndexSet Map::GetMapChipIndexSetByPosition(const Vector3& position)
{
	IndexSet indexSet{};

	// åº§æ¨™ã‹ã‚‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
	float x = std::floor(position.x / kBlockWidth);
	float y = std::floor((GetHeight() - 1) - (position.y / kBlockHeight));

	// åº§æ¨™ãŒãƒãƒƒãƒ—å¤–ã®å ´åˆã¯æœ€å¤§å€¤ã‚’è¿”ã™
	int ix = static_cast<int>(x);
	int iy = static_cast<int>(y);

	// ãƒãƒƒãƒ—å¤–ãƒã‚§ãƒƒã‚¯ / ãƒãƒƒãƒ—å¤–ãªã‚‰ç¯„å›²å¤–ã‚’ç¤ºã™ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™
	if (ix < 0 || ix >= static_cast<int>(GetWidth()) ||
		iy < 0 || iy >= static_cast<int>(GetHeight())) {
		indexSet.xIndex = GetWidth();
		indexSet.yIndex = GetHeight();
		return indexSet;
	}
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ã‚»ãƒƒãƒˆ
	indexSet.xIndex = static_cast<uint32_t>(ix);
	indexSet.yIndex = static_cast<uint32_t>(iy);

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™
	return indexSet;
}

BlockType Map::GetMapChipTypeByIndex(uint32_t xIndex, uint32_t yIndex)
{
	// ãƒãƒƒãƒ—å¤–ãƒã‚§ãƒƒã‚¯
	uint32_t w = GetWidth();
	uint32_t h = GetHeight();
	// ãƒãƒƒãƒ—å¤–ãªã‚‰Airã‚’è¿”ã™
	if (xIndex >= w || yIndex >= h) {
		return BlockType::Air;
	}
	// æŒ‡å®šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡ã‚’è¿”ã™
	return mapChipData_.mapData[yIndex][xIndex];
}


Rect Map::GetRectByIndex(uint32_t xIndex, uint32_t yIndex)
{
	Vector3 center = GetMapChipPositionByIndex(xIndex, yIndex);
	Rect rect{};
	rect.left = center.x - (kBlockWidth / 2);
	rect.right = center.x + (kBlockWidth / 2);
	rect.bottom = center.y - (kBlockHeight / 2);
	rect.top = center.y + (kBlockHeight / 2);
	return rect;
}

Vector3 Map::GetMapChipPositionByIndex(uint32_t xIndex, uint32_t yIndex)
{
	const uint32_t h = GetHeight();
	return Vector3(kBlockWidth * xIndex,
		kBlockHeight * (h - 1 - yIndex),
		0.0f);
}

void Map::BreakBlock(uint32_t xIndex, uint32_t yIndex)
{
	// ãƒãƒƒãƒ—å¤–ãƒã‚§ãƒƒã‚¯
    if (yIndex >= mapChipData_.mapData.size() ||
        xIndex >= mapChipData_.mapData[yIndex].size()) {
        return;
    }
	// ç ´å£Šå¯èƒ½ãƒ–ãƒ­ãƒƒã‚¯ã‹ãƒã‚§ãƒƒã‚¯
    if (mapChipData_.mapData[yIndex][xIndex] != BlockType::breakBlock) {
        return;
    }

    // è©²å½“ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãæ›ãˆ / Airã«å¤‰æ›´
    
    isMapDataChanged_ = true;

    // å®Ÿä½“ï¼ˆæç”»/æ›´æ–°ï¼‰ã‚’ãã®å ´ã§æ¶ˆã™ï¼ˆMapå…¨å†ç”Ÿæˆã—ãªã„ï¼‰
    if (yIndex < blockArray_.size() && xIndex < blockArray_[yIndex].size()) {
        if (blockArray_[yIndex][xIndex]) {
            // ç”Ÿå­˜ãƒ•ãƒ©ã‚°æ–¹å¼ï¼ˆæ¼”å‡ºã‚’æŒŸã‚€ãªã‚‰ Kill ã®ã¿ã«ã—ã¦ã‚‚OKï¼‰
            blockArray_[yIndex][xIndex]->SetBroken();

			// ç ´å£Šä½ç½®ã®å–å¾—
			Vector3 breakPos = GetMapChipPositionByIndex(xIndex, yIndex);
            // ç ´å£Šæ™‚ã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç™ºç”Ÿ
           ModelParticleManager::GetInstance().EmitBlockDebris(
                breakPos,
                Vector4(1.0f, 1.0f, 1.0f, 1.0f),
			   15);
			// è©²å½“ã®BreakBlockã‚’Airã«å¤‰æ›´
            mapChipData_.mapData[yIndex][xIndex] = BlockType::Air;
        }
    }
}



============================================================
File Path: Game/Application/Map/Map.h
============================================================
#pragma once
#include <vector>
#include "MyMath.h"
#include "Game/Application/Block/Block.h"
#include "Game/Application/Block/BlockType.h"
#include "Game/Application/Enemy/EnemyType.h"
#include "Game/Particle/ParticleSystem.h"
#include "Game/Particle/ModelParticleManager.h"
#include <cstdint>
#include <string>
#include "Game/Application/Map/CsvLoader.h"
/// ãƒãƒƒãƒ—ã‚¯ãƒ©ã‚¹

/// ãƒãƒƒãƒ—ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
struct MapChipData {
	std::vector<std::vector<BlockType>> mapData;
};
struct EnemyLayerData {
	std::vector<std::vector<EnemyType>> enemyData;
};

/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ§‹é€ ä½“
struct IndexSet {
	uint32_t xIndex;
	uint32_t yIndex;
};

/// çŸ©å½¢æ§‹é€ ä½“
struct Rect {
	float left;
	float right;
	float bottom;
	float top;
};

class Map
{
public:
	// ï¼‘ãƒ–ãƒ­ãƒƒã‚¯ã®å¤§ãã•
	static inline const float kBlockWidth = 1.0f;
	static inline const float kBlockHeight = 1.0f;
	//ãƒãƒƒãƒ—ã®å¤§ãã•
	// æ¨ª
	static inline const uint32_t kMapWidth = 100;
	// é«˜ã•
	static inline const uint32_t kMapHeight = 20;

	// å¯å¤‰ã‚µã‚¤ã‚ºã®ãƒãƒƒãƒ—ã®å¤§ãã•
	uint32_t GetWidth()const {
		if (mapChipData_.mapData.empty()) { return 0; }
		return (uint32_t)mapChipData_.mapData[0].size();
	}
	uint32_t GetHeight()const {
		return (uint32_t)mapChipData_.mapData.size();
	}
public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize(const std::string& mapFilePath);

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();

	/// <summary>
	/// ãƒãƒƒãƒ—ãƒ–ãƒ­ãƒƒã‚¯ç”Ÿæˆ
	/// </summary>
	void GenerateMapBlock();

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”Ÿæˆ
	/// </summary>
	void GenerateEnemyLayer();

	/// <summary>
	/// ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	/// </summary>
	void LoadMapData(const std::string& mapFilePath);


public:	// Setter / Getter
	/// <summary>
	/// åº§æ¨™ã‹ã‚‰ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
	/// </summary>
	/// <param name="position">å–å¾—ã—ãŸã„ãƒãƒƒãƒ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åº§æ¨™</param>
	IndexSet GetMapChipIndexSetByPosition(const Vector3& position);

	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡ã‚’å–å¾—
	/// </summary>
	/// <param name="xIndex/yIndex">å–å¾—ã—ãŸã„ãƒãƒƒãƒ—ã®åº§æ¨™ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	/// <returns>æŒ‡å®šã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡</returns>
	BlockType GetMapChipTypeByIndex(uint32_t xIndex, uint32_t yIndex);


	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰çŸ©å½¢æƒ…å ±ã‚’å–å¾—
	/// </summary>
	/// <param name="xIndex/yIndex">ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åº§æ¨™</param>
	/// <returns>æŒ‡å®šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åº§æ¨™ã®ãƒ–ãƒ­ãƒƒã‚¯ã®çŸ©å½¢æƒ…å ±</returns>
	Rect GetRectByIndex(uint32_t xIndex, uint32_t yIndex);

	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ä¸­å¿ƒåº§æ¨™ã‚’å–å¾—
	/// </summary>
	/// <param name="xIndex/yIndex">ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åº§æ¨™</param>
	/// <returns>æŒ‡å®šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åº§æ¨™ã®ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­å¿ƒåº§æ¨™</returns>
	Vector3 GetMapChipPositionByIndex(uint32_t xIndex, uint32_t yIndex);

	/// <summary>
	/// ãƒãƒƒãƒ—ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	/// </summary>
	const EnemyLayerData& GetEnemyLayerData() const { return enemyLayerData_; }

	/// <summary>
	/// ç·¨é›†ç”¨ãƒãƒƒãƒ—ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	/// </summary>
	EnemyLayerData& GetEnemyLayerData() { return enemyLayerData_; }

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼å¤‰æ›´æ¤œçŸ¥ãƒ•ãƒ©ã‚°ã‚’æ¶ˆè²»
	/// </summary>
	/// <returns></returns>
	bool ConsumeEnemyLayerDirtyFlag() {
		bool result = enemyLayerDirty_;
		enemyLayerDirty_ = false;
		return result;
	}

	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡ã‚’è¨­å®š
	/// </summary>
	/// <param name="xIndex/yIndex">è¨­å®šã—ãŸã„ãƒãƒƒãƒ—ã®åº§æ¨™ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	/// <param name="type">è¨­å®šã™ã‚‹ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡</param>
	void SetMapChipTypeByIndex(uint32_t xIndex, uint32_t yIndex, BlockType type) {
		if (yIndex < mapChipData_.mapData.size() && xIndex < mapChipData_.mapData[yIndex].size()) {
			mapChipData_.mapData[yIndex][xIndex] = type;
			isMapDataChanged_ = true;
		}
	}

	/// <summary>
	/// ç ´å£Šå¯èƒ½ãƒ–ãƒ­ãƒƒã‚¯ã‚’å£Šã™
	/// </summary>
	/// <param name="xIndex">å½“ãŸã£ãŸå£Šã›ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã®æ¨ªIndexã®ç•ªå·</param>
	/// <param name="yIndex">å½“ãŸã£ãŸå£Šã›ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã®ç¸¦Indexã®ç•ªå·</param>
	void BreakBlock(uint32_t xIndex, uint32_t yIndex);

private:
	// ãƒãƒƒãƒ—ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿
	MapChipData mapChipData_;
	// ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿
	EnemyLayerData enemyLayerData_;

	// å¤‰æ›´æ¤œçŸ¥
	bool isMapDataChanged_ = false;
	MapChipData previousMapData_;

	// ãƒãƒƒãƒ—ãƒ–ãƒ­ãƒƒã‚¯ã®é…åˆ—
	std::vector<std::vector<Block*>> blockArray_;

	// å¯å¤‰ã‚µã‚¤ã‚ºã®ãƒãƒƒãƒ—ã®å¤§ãã•
	uint32_t width_ = 0;
	uint32_t height_ = 0;

	// ãƒ–ãƒ­ãƒƒã‚¯ã‚’å°‘ã—ãšã‚‰ã™
	float blockOffset_ = 0.5f;

	// ãƒãƒƒãƒ—ç•ªå·
	std::string mapNumber_;

	// ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼å¤‰æ›´æ¤œçŸ¥ãƒ•ãƒ©ã‚°
	bool enemyLayerDirty_ = false;


	// ç ´å£Šå¯èƒ½ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨
	std::unique_ptr<ParticleSystem> breakParticleEmitter_;

};


============================================================
File Path: Game/Application/ModelList.cpp
============================================================
#include "ModelList.h"
#include "ModelManager.h"
void ModelList::LoadAllModel()
{
	/// LoadModelList
	ModelManager::GetInstance().LoadModel("cubeR.obj");
	ModelManager::GetInstance().LoadModel("Cube.obj");
							   
							   
	/// TitleScene			   
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	ModelManager::GetInstance().LoadModel("Player.obj");
	// ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒ³		 
	ModelManager::GetInstance().LoadModel("RainbowPlane.obj");
	// ã‚¿ã‚¤ãƒˆãƒ«ãƒ­ã‚´			   
	ModelManager::GetInstance().LoadModel("title.obj");
	// ã‚¿ã‚¤ãƒˆãƒ«èƒŒæ™¯			   
	ModelManager::GetInstance().LoadModel("Back3.obj");
	ModelManager::GetInstance().LoadModel("back2.obj");
	ModelManager::GetInstance().LoadModel("back1.obj");
	ModelManager::GetInstance().LoadModel("BackSky.obj");
	ModelManager::GetInstance().LoadModel("soil.obj");
							   
	/// StageSelectScene	   
	ModelManager::GetInstance().LoadModel("SelectBaseGround.obj");
	ModelManager::GetInstance().LoadModel("Node.obj");
	ModelManager::GetInstance().LoadModel("RoutePlane.obj");
							   
	/// GamePlayScene		   
	ModelManager::GetInstance().LoadModel("Grass.obj");
	ModelManager::GetInstance().LoadModel("SceneChange.obj");
	ModelManager::GetInstance().LoadModel("nullBlock.obj");
	ModelManager::GetInstance().LoadModel("XYZLabel.obj");
	ModelManager::GetInstance().LoadModel("breakBlock.obj");
	ModelManager::GetInstance().LoadModel("moveBlock.obj");
	ModelManager::GetInstance().LoadModel("sand.obj");
	ModelManager::GetInstance().LoadModel("Unbreakable.obj");
							   
	ModelManager::GetInstance().LoadModel("GoalUp.obj");
	ModelManager::GetInstance().LoadModel("GoalDown.obj");
							   
	ModelManager::GetInstance().LoadModel("Tentativeenemy.obj");
}


============================================================
File Path: Game/Application/ModelList.h
============================================================
#pragma once
class ModelList
{

public:
	void LoadAllModel();
};



============================================================
File Path: Game/Application/PlayContext.cpp
============================================================
#include "PlayContext.h"


============================================================
File Path: Game/Application/PlayContext.h
============================================================
#pragma once
#include <cstdint>
#include <string>

/// <summary>
/// ãƒ—ãƒ¬ã‚¤ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆ
/// </summary>
class PlayContext
{
public:
	// ãƒ—ãƒ¬ã‚¤ä¸­ã®ã‚¹ãƒ†ãƒ¼ã‚¸IDå–å¾—
	static PlayContext& GetInstance() {
		static PlayContext instance;
		return instance;
	}
	/// <summary>
	/// é¸æŠä¸­ã®ã‚¹ãƒ†ãƒ¼ã‚¸IDå–å¾—
	/// </summary>
	/// <param name="id">ã‚¹ãƒ†ãƒ¼ã‚¸ã®åå‰</param>
	void SetSelectedStageId(uint32_t id) { selectedStageId_ = id; }

	/// <summary>
	/// é¸æŠä¸­ã®ã‚¹ãƒ†ãƒ¼ã‚¸è¨­å®š
	/// </summary>
	/// <param name="id">ã‚»ãƒƒãƒˆã™ã‚‹ã‚¹ãƒ†ãƒ¼ã‚¸id</param>
	/// <param name="key">ã‚»ãƒƒãƒˆã™ã‚‹ã‚¹ãƒ†ãƒ¼ã‚¸ã‚­ãƒ¼</param>
	void SetSelectedStage(uint32_t id,const std::string& key){
		selectedStageId_ = id;
		selectedStageKey_ = key;
	}

	/// <summary>
	/// é¸æŠä¸­ã®ã‚¹ãƒ†ãƒ¼ã‚¸IDå–å¾—
	/// </summary>
	/// <returns>é¸æŠä¸­ã®ã‚¹ãƒ†ãƒ¼ã‚¸IDã‚’è¿”ã™</returns>
	uint32_t GetSelectedStageId()const { return selectedStageId_; }

	/// <summary>
	/// é¸æŠä¸­ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚­ãƒ¼å–å¾—
	/// </summary>
	/// <returns>é¸æŠä¸­ã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚­ãƒ¼ã‚’è¿”ã™</returns>
	const std::string& GetSelectedStageKey()const { return selectedStageKey_; }
private:
	// ã‚¹ãƒ†ãƒ¼ã‚¸ID
	uint32_t selectedStageId_ = 0;
	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒ†ãƒ¼ã‚¸ã‚­ãƒ¼
	std::string selectedStageKey_ = "1-1";
};



============================================================
File Path: Game/Application/Player/Player.cpp
============================================================
#include "Player.h"
#include <algorithm>
#include "Input.h"
#include "Game/Particle/ParticlePresets.h"
#ifdef USE_IMGUI
#include "engine/base/ImGuiManager.h"
#endif


Collider::Type Player::GetType() const
{
	// åˆ¤å®šã‚¿ã‚¤ãƒ—ãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã‚ã‚‹ã“ã¨ã‚’è¿”ã™
	return Collider::Type::Player;
}

AABB Player::GetAABB() const
{
	AABB aabb{};

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­å¿ƒ
	Vector3 pos = playerModel_->GetTranslate();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¹…ã¨é«˜ã•ã‚’å–å¾—
	float halfWidth = status_.kWidth / 2.0f;
	float halfHeight = status_.kHeight / 2.0f;

	// å¥¥è¡Œã¯æ°—ã«ã—ãªã„
	float halfDepth = 0.5f;

	// AABBã®æœ€å°åº§æ¨™ã¨æœ€å¤§åº§æ¨™ã‚’è¨­å®š
	aabb.min = { pos.x - halfWidth, pos.y - halfHeight, pos.z - halfDepth };
	aabb.max = { pos.x + halfWidth, pos.y + halfHeight, pos.z + halfDepth };

	// AABBã‚’è¿”ã™
	return aabb;
}

void Player::OnCollision(Collider* other)
{
	// è¡çªç›¸æ‰‹ãŒå­˜åœ¨ã—ãªã‹ã£ãŸã‚‰å‡¦ç†ã—ãªã„
	if (!other)return;

	switch (other->GetType())
	{
		// æ•µã«è¡çªã—ãŸã‚‰
	case Collider::Type::Enemy:
		//  
		if (isEnemyHit_) {
			// ã™ã§ã«å½“ãŸã£ã¦ã„ã‚‹ãªã‚‰ä½•ã‚‚ã—ãªã„ / ç„¡æ•µæ™‚é–“
			break;
		}
		// ã‚¨ãƒãƒŸãƒ¼è¡çªå‡¦ç†
		EnemyCollision();
		break;
	default:
		// ç‰¹ã«ä½•ã‚‚ã—ãªã„
		break;
	}
}

void Player::EnemyCollision()
{
	// ç‚¹æ»…ã‚¹ã‚¿ãƒ¼ãƒˆã®åˆæœŸåŒ–ã®ã¿
	isEnemyHit_ = true;
	flashingFrameCount_ = 0;
	isVisible_ = true;
}

void Player::FlashingUpdate()
{
	// ã‚¨ãƒãƒŸãƒ¼ã«ãƒ’ãƒƒãƒˆã—ã¦ã„ãŸã‚‰ç‚¹æ»…å‡¦ç† / ç„¡æ•µæ™‚é–“
	if (isEnemyHit_) {
		// ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°
		flashingFrameCount_++;
		// ç‚¹æ»…å‡¦ç†
		if (flashingFrameCount_ <= maxFlashingFlame_) {
			// ä¸€å®šé–“éš”ã§è¡¨ç¤ºãƒ»éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
			if (flashingFrameCount_ % flashingIntervalFrame_ == 1) {
				isVisible_ = !isVisible_;
			}
		} else {
			// çµ‚äº†å‡¦ç†
			isEnemyHit_ = false;
			isVisible_ = true;
			flashingFrameCount_ = 0;
		}
	}
}

void Player::PlayerTurn()
{
	switch (direction_)
	{
	case Direction::kRight:

		// å³å‘ã
		targetYaw_ = 0.0f;

		break;
	case Direction::kLeft:
		// å·¦å‘ã
		targetYaw_ = 3.5f;

		break;

	default:
		break;
	}

	// ç¾åœ¨ã®å›è»¢ã‚’å–å¾—
	Vector3 currentRotate = playerModel_->GetRotate();
	// è£œé–“ä¿‚æ•°ã®è¨ˆç®—
	float t = 1.0f - std::pow(0.5f, static_cast<float>(1.0f) / (status_.kTurnTime * 60.0f));
	// ãƒ¨ãƒ¼è§’ã®è£œé–“
	currentRotate.y += (targetYaw_ - currentRotate.y) * t;
	// å›è»¢ã®è¨­å®š
	playerModel_->SetRotate(currentRotate);

}

void Player::UpdateDashEffect()
{
	// ç¾åœ¨ã®ãƒ€ãƒƒã‚·ãƒ¥çŠ¶æ…‹ã‚’å–å¾—
	const bool movingRight = Input::GetInstance()->PushKey(DIK_D) && !Input::GetInstance()->PushKey(DIK_A);
	const bool movingLeft = Input::GetInstance()->PushKey(DIK_A) && !Input::GetInstance()->PushKey(DIK_D);
	// ãƒ€ãƒƒã‚·ãƒ¥çŠ¶æ…‹ã®åˆ¤å®š
	const bool dashActiveRight = isDash_ && (dashDirection_ == +1) && movingRight;
	const bool dashActiveLeft = isDash_ && (dashDirection_ == -1) && movingLeft;
	const bool dashActive = dashActiveRight || dashActiveLeft;

	// åœ°é¢ã«æ¥åœ°ã—ã¦ã„ã‚‹ã‹
	const bool canShowEffect = dashActive && onGround_;

	Vector3 playerPos = playerModel_->GetTranslate();

	// ãƒ€ãƒƒã‚·ãƒ¥é–‹å§‹æ™‚ã®è¡æ’ƒæ³¢ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	if (!wasDashing_ && canShowEffect) {
		dashStartEffect_->SetTranslate(playerPos);
		// ç™ºç”Ÿ
		dashStartEffect_->Play();
	}

	// ãƒ€ãƒƒã‚·ãƒ¥ä¸­ã®ç¶™ç¶šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	if (canShowEffect) {
		// è¶³å…ƒã®ä½ç½®ã‚’è¨ˆç®—
		Vector3 smokePos = playerPos;
		// ç™ºç”Ÿä½ç½®ã‚’è¶³å…ƒã‚‰ã¸ã‚“ã«
		smokePos.y -= particleSpawnPosOffset_;

		// é€²è¡Œæ–¹å‘ã¨ã¯é€†æ–¹å‘ã«
		if (dashDirection_ == +1) {
			smokePos.x -= particleSpawnPosOffset_;
		} else if (dashDirection_ == -1) {
			smokePos.x += particleSpawnPosOffset_;
		}

		// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ä½ç½®æ›´æ–°
		dashSmokeEffect_->SetTranslate(smokePos);

		// ç™ºç”Ÿ
		if (!wasDashing_) {
			dashSmokeEffect_->Play();
		}
	} else {
		// ãƒ€ãƒƒã‚·ãƒ¥ã—ã¦ã„ãªã„ã¨ãã¯ç…™ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’åœæ­¢
		dashSmokeEffect_->Stop();
	}
	// å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®çŠ¶æ…‹ã‚’ä¿æŒ
	wasDashing_ = canShowEffect;
}



void Player::Initialize(Vector3 position)
{
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ‡ãƒ«ã®ç”Ÿæˆã¨åˆæœŸåŒ–
	playerModel_ = std::make_unique<Object3D>();
	playerModel_->Initialize();
	playerModel_->SetTranslate(position);
	playerModel_->SetModel("Player.obj");
	// æ­»ã¬é«˜ã•ã®è¨­å®š
	SetDeathHeight(-1.0f);

	// ãƒ€ãƒƒã‚·ãƒ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ–
	// è¶³å…ƒã®ç…™ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	dashSmokeEffect_ = ParticlePresets::CreateSmoke(position);
	// åˆæœŸã¯åœæ­¢
	dashSmokeEffect_->Pause();
	dashSmokeEffect_->SetEmissionRate(15.0f);
	dashSmokeEffect_->SetLoop(true);
	dashSmokeEffect_->SetColor(Vector4(0.7f, 0.6f, 0.4f, 1.0f));
	// ãƒ€ãƒƒã‚·ãƒ¥é–‹å§‹æ™‚ã®è¡æ’ƒæ³¢
	dashStartEffect_ = ParticlePresets::CreateSparks(position);
	dashStartEffect_->Pause();
	// ä¸€æ°—ã«
	dashStartEffect_->SetEmissionRate(50.0f);
	// ä¸€åº¦ã®ç™ºç”Ÿã®ãŸã‚ãƒ«ãƒ¼ãƒ—ã¯ã—ãªã„
	dashStartEffect_->SetLoop(false);

}


void Player::Update()
{
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æŒ™å‹•æ›´æ–°
	UpdateBehavior();
	// ãƒ€ãƒƒã‚·ãƒ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ›´æ–°
	UpdateDashEffect();
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢
	PlayerTurn();
	// ã‚¨ãƒãƒŸãƒ¼ã«ãƒ’ãƒƒãƒˆã—ãŸã‚‰
	FlashingUpdate();

#ifdef USE_IMGUI
	ImGui();
#endif 
	// ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
	playerModel_->Update();

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®æ›´æ–°
	if (dashSmokeEffect_)dashSmokeEffect_->Update();
	if (dashStartEffect_)dashStartEffect_->Update();
}



void Player::Draw()
{
	// ãƒ¢ãƒ‡ãƒ«ã®æç”»
	if (isVisible_) {
		playerModel_->Draw();
	}
}

void Player::UpdateBehavior()
{
	// ãƒãƒƒãƒ—ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã‹ã£ãŸã‚‰å‡¦ç†ã—ãªã„
	if (!map_)return;

	// æ­»äº¡ã—ã¦ã„ãŸã‚‰ãƒªã‚»ãƒƒãƒˆå‡¦ç†
	if (isDead_) {
		DebugPlayerReset();
		return;
	}

	// ç§»å‹•å‡¦ç†
	Move();
	// ã‚¸ãƒ£ãƒ³ãƒ—å‡¦ç†
	Jump();

	// å½“ãŸã‚Šåˆ¤å®šå‡¦ç†
	CollisionMapInfo collisionInfo;

	// åœ°é¢ã«ã„ãªã‹ã£ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
	if (playerModel_->GetTranslate().y < deathHeight_ && !onGround_)
	{
		// æ­»äº¡ãƒ•ãƒ©ã‚°
		isDead_ = true;
	}

	// ç§»å‹•é‡ã®åæ˜ 
	collisionInfo.move = velocity_;

	// ä¸Šæ˜‡ä¸­ã¯ç¢ºå®Ÿã«åœ°é¢ã‹ã‚‰é›¢ã‚Œã¦ã„ã‚‹ï¼ˆè¿½åŠ ï¼‰
	if (velocity_.y > 0.0f) {
		onGround_ = false;
	}

	// ãƒãƒƒãƒ—è¡çªãƒã‚§ãƒƒã‚¯
	MapCollision(collisionInfo);
	// å¤©äº•è¡çªå‡¦ç†
	CellingCollisionMove(collisionInfo);
	// åºŠè¡çªå‡¦ç†
	LandingCollisionMove(collisionInfo);
	// å£è¡çªå‡¦ç†
	WallCollisionMove(collisionInfo);
	// é€Ÿåº¦åæ˜ 
	PlayerCollisionMove(collisionInfo);
}

void Player::Move()
{
	// æ“ä½œãƒ­ãƒƒã‚¯ä¸­ï¼šå…¥åŠ›ã¯ç„¡è¦–ã—ã¦é€Ÿåº¦æ¸›è¡°ã®ã¿è¡Œã†
	if (!controlEnabled_) {
		// èµ°ã‚Šç¶šã‘é˜²æ­¢ï¼ˆã‚­ãƒ¼æŠ¼ã—ã£ã±ãªã—è§£é™¤ç›´å¾Œã®äº‹æ•…å¯¾ç­–ï¼‰
		velocity_.x *= (1.0f - status_.kAttenuation);

		// ãƒ€ãƒƒã‚·ãƒ¥çŠ¶æ…‹ã‚‚è§£é™¤
		isDash_ = false;
		dashDirection_ = 0;
		rightTapTimer_ = 0;
		leftTapTimer_ = 0;

		return;
	}


	auto* input = Input::GetInstance();

	// ------------------------
	// å…¥åŠ›çŠ¶æ…‹
	// ------------------------
	const bool rightHold = input->PushKey(DIK_D);
	const bool leftHold = input->PushKey(DIK_A);

	const bool rightTrig = input->TriggerKey(DIK_D);
	const bool leftTrig = input->TriggerKey(DIK_A);

	// ------------------------
	// ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ç”¨ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
	// ------------------------
	if (rightTapTimer_ > 0) { --rightTapTimer_; }
	if (leftTapTimer_ > 0) { --leftTapTimer_; }

	// å³ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®š
	if (rightTrig) {
		// ä¸€å®šæ™‚é–“å†…ã«2å›ç›®ãŒæ¥ãŸã‚‰ãƒ€ãƒƒã‚·ãƒ¥é–‹å§‹
		if (rightTapTimer_ > 0) {
			isDash_ = true;
			dashDirection_ = +1;
		}
		// ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
		rightTapTimer_ = status_.kDashDoubleTapFrame;
		// åå¯¾å´ã¯ãƒªã‚»ãƒƒãƒˆ
		leftTapTimer_ = 0;
	}

	// å·¦ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®š
	if (leftTrig) {
		if (leftTapTimer_ > 0) {
			isDash_ = true;
			dashDirection_ = -1;
		}
		leftTapTimer_ = status_.kDashDoubleTapFrame;
		rightTapTimer_ = 0;
	}

	// ------------------------
	// ãƒ€ãƒƒã‚·ãƒ¥ç¶™ç¶šï¼è§£é™¤åˆ¤å®š
	// ------------------------
	const bool movingRight = rightHold && !leftHold;
	const bool movingLeft = leftHold && !rightHold;

	// å…¥åŠ›ãŒæ­¢ã¾ã£ãŸã‚‰ãƒ€ãƒƒã‚·ãƒ¥è§£é™¤
	if (!movingRight && !movingLeft) {
		isDash_ = false;
		dashDirection_ = 0;
	} else if (isDash_) {
		// é€†æ–¹å‘ã«å…¥åŠ›ã—ãŸã‚‰ãƒ€ãƒƒã‚·ãƒ¥è§£é™¤
		if ((dashDirection_ == +1 && movingLeft) ||
			(dashDirection_ == -1 && movingRight)) {
			isDash_ = false;
			dashDirection_ = 0;
		}
	}

	// ------------------------
	// å®Ÿéš›ã®é€Ÿåº¦æ›´æ–°
	// ------------------------
	Vector3 acceleration{};

	// å·¦å³ã®ã©ã¡ã‚‰ã®æ–¹å‘ã«ãƒ€ãƒƒã‚·ãƒ¥ã—ã¦ã„ã‚‹ã‹åˆ¤åˆ¥
	const bool dashActiveRight = isDash_ && (dashDirection_ == +1) && movingRight;
	const bool dashActiveLeft = isDash_ && (dashDirection_ == -1) && movingLeft;
	// ã©ã¡ã‚‰ã«å‘ã„ã¦ã„ã‚‹ã‹ã‚’æŒã¤
	const bool dashActive = dashActiveRight || dashActiveLeft;


	// ãƒ€ãƒƒã‚·ãƒ¥ä¸­ã ã‘å°‘ã—é€Ÿãã™ã‚‹
	float dashScale = dashActive ? status_.kDashSpeedScale : 1.0f;
	float maxSpeed = status_.kMaxSpeed * dashScale;


	// æ¨ªæ–¹å‘é€Ÿåº¦æ›´æ–°
	if (movingRight) {
		// å·¦ã«å‹•ã„ã¦ã„ãŸå ´åˆã¯å°‘ã—æ¸›é€Ÿ
		if (velocity_.x < 0.0f) {
			velocity_.x *= (1.0f - status_.kAttenuation);
		}
		acceleration.x += status_.kAcceleration * dashScale;

		// æŠ¼ã•ã‚ŒãŸæ–¹å‘ã«ãƒ‡ã‚£ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‘ã‘ã‚‹
		direction_ = Direction::kRight;
	} else if (movingLeft) {
		if (velocity_.x > 0.0f) {
			velocity_.x *= (1.0f - status_.kAttenuation);
		}
		acceleration.x -= status_.kAcceleration * dashScale;

		// æŠ¼ã•ã‚ŒãŸæ–¹å‘ã«ãƒ‡ã‚£ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‘ã‘ã‚‹
		direction_ = Direction::kLeft;
	} else {
		// å…¥åŠ›ãŒãªã„ã¨ãã¯æ¸›é€Ÿã®ã¿ï¼ˆãƒ€ãƒƒã‚·ãƒ¥å€ç‡ã¯ã‹ã‘ãªã„ï¼‰
		velocity_.x *= (1.0f - status_.kAttenuation);
	}

	// åŠ é€Ÿåº¦åæ˜ 
	velocity_.x += acceleration.x;

	// é€Ÿåº¦ã«å¿œã˜ã¦å›è»¢
	Vector3 rotate = playerModel_->GetRotate();
	rotate -= {0.0f, 0.0f, velocity_.x};
	// å›è»¢ãŒè¦å®šå€¤ã§ã‚ã‚‹playerTurnAround_ãŒ6.3fã«ãªã£ãŸã‚‰å›è»¢ã®å€¤ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹
	if (-playerTurnAround_ >= rotate.z && movingRight ||
		playerTurnAround_ <= rotate.z && movingLeft) {
		rotate.z = 0.0f;
	}
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢
	playerModel_->SetRotate(rotate);

	// æœ€å¤§é€Ÿåº¦ã‚’ãƒ€ãƒƒã‚·ãƒ¥çŠ¶æ…‹ã«å¿œã˜ã¦å¤‰ãˆã‚‹
	velocity_.x = std::clamp(velocity_.x, -maxSpeed, maxSpeed);
}


void Player::Jump()
{
	// æ“ä½œãƒ­ãƒƒã‚¯ä¸­ï¼šã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›ã¯ç„¡è¦–
	if (!controlEnabled_) {
		// é‡åŠ›ã ã‘ã¯é€šå¸¸é€šã‚Šæ›ã‘ã‚‹ï¼ˆç©ºä¸­ã§åœæ­¢ã—ãªã„ã‚ˆã†ã«ï¼‰
		if (!onGround_) {
			velocity_.y += -status_.kGravity;
			velocity_.y = (std::max)(velocity_.y, -status_.kMaxFallSpeed);
		}
		return;
	}

	// åœ°é¢ã«ã„ã‚‹å ´åˆ
	if (onGround_) {
		// ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸã‚‰
		if (Input::GetInstance()->PushKey(DIK_SPACE) || Input::GetInstance()->PushKey(DIK_W)) {
			// ã‚¸ãƒ£ãƒ³ãƒ—å‡¦ç†
			velocity_.y = status_.kJumpPower;
		}
	} else {
		// é‡åŠ›é©å¿œå‡¦ç†
		velocity_.y += -status_.kGravity;
		velocity_.y = (std::max)(velocity_.y, -status_.kMaxFallSpeed);
	}

}



void Player::MapCollision(CollisionMapInfo& collisionInfo)
{
	CollisionMapInfoDirection(
		collisionInfo,
		CollisionType::kRight,
		{ kRightTop,kRightBottom },
		Vector3(status_.kEpsilon, 0.0f, 0.0f),
		[](const CollisionMapInfo& info) {
			return info.move.x > 0.0f;
		});

	CollisionMapInfoDirection(
		collisionInfo,
		CollisionType::kLeft,
		{ kLeftTop,kLeftBottom },
		Vector3(-status_.kEpsilon, 0.0f, 0.0f),
		[](const CollisionMapInfo& info) {
			return info.move.x < 0.0f;
		});

	CollisionMapInfoDirection(
		collisionInfo,
		CollisionType::kTop,
		{ kRightTop,kLeftTop },
		Vector3(0.0f, 0.0f, 0.0f),
		[](const CollisionMapInfo& info) {
			return info.move.y > 0.0f;
		});

	CollisionMapInfoDirection(
		collisionInfo,
		CollisionType::kBottom,
		{ kRightBottom,kLeftBottom },
		Vector3(0.0f, -status_.kEpsilon, 0.0f),
		[](const CollisionMapInfo& info) {
			return info.move.y < 0.0f;
		});
}

void Player::CellingCollisionMove(CollisionMapInfo& collisionInfo)
{
	// å¤©äº•ã«è¡çªã—ã¦ã„ã‚‹ã‹ã©ã†ã‹
	if (collisionInfo.celling) {
		// å¤©äº•ã«è¡çªã—ãŸã‚‰ç§»å‹•é‡ã‚’èª¿æ•´
		velocity_.y = 0.0f;

		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é ­ã«å½“ãŸã£ãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’èª¿ã¹ã‚‹
		Vector3 position = playerModel_->GetTranslate();

		// é ­ã®2ç‚¹ã®ä½ç½®ã‚’è¨ˆç®—
		std::array<Vector3, 2> topCorners = {
			CornerPosition(position,kLeftTop),
			CornerPosition(position,kRightTop)
		};
		// å„ã‚³ãƒ¼ãƒŠãƒ¼ã®æ–°ã—ã„ä½ç½®ã§å½“ãŸã£ãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’èª¿ã¹ã‚‹
		for (const auto& cornerPosition : topCorners) {
			IndexSet indexSet = map_->GetMapChipIndexSetByPosition(cornerPosition);
			BlockType blockType = map_->GetMapChipTypeByIndex(indexSet.xIndex, indexSet.yIndex - 1);

			// Break Blockã ã£ãŸå ´åˆç ´å£Šã™ã‚‹ 
			if (IsHitBlockBreakableTable(blockType)) {
				// ãƒ–ãƒ­ãƒƒã‚¯ç ´å£Š
				map_->BreakBlock(indexSet.xIndex, indexSet.yIndex - 1);
			}
		}

	}
}

void Player::LandingCollisionMove(CollisionMapInfo& collisionInfo)
{
	// ç€åœ°åˆ¤å®šï¼ˆç©ºä¸­ã‹ã‚‰åœ°é¢ã¸ã®è¡çªï¼‰
	if (!onGround_ && collisionInfo.landing) {
		// åºŠã«è¡çªã—ãŸã‚‰ç§»å‹•é‡ã‚’èª¿æ•´
		velocity_.y = 0.0f;
		onGround_ = true;
		return;  // ç€åœ°ã—ãŸã‚‰ã“ã“ã§çµ‚äº†
	}

	// åœ°é¢ã«ã„ã‚‹å ´åˆã®ç¶™ç¶šåˆ¤å®š
	if (onGround_) {
		// ä¸‹æ–¹å‘ã«é€Ÿåº¦ãŒãªã„å ´åˆã®ã¿ãƒã‚§ãƒƒã‚¯ï¼ˆå®‰å®šåŒ–ï¼‰
		if (velocity_.y <= 0.0f) {
			// ç¾åœ¨ã®åº§æ¨™ã§åˆ¤å®šï¼ˆä¿®æ­£ï¼šç§»å‹•å¾Œã§ã¯ãªãç¾åœ¨ä½ç½®ã§ï¼‰
			Vector3 position = playerModel_->GetTranslate();

			// è¶³å…ƒã®2ç‚¹ã®ä½ç½®ã‚’å–å¾—
			Vector3 leftBottom = CornerPosition(position, kLeftBottom);
			Vector3 rightBottom = CornerPosition(position, kRightBottom);

			// å°‘ã—ä¸‹ã®ä½ç½®ã§ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ˆã‚Šç¢ºå®Ÿã«ï¼‰
			Vector3 checkOffset = Vector3(0.0f, -status_.kEpsilon * 2.0f, 0.0f);  // â† 2å€ã«

			// å·¦ç‚¹ã®åˆ¤å®š
			IndexSet leftIndex = map_->GetMapChipIndexSetByPosition(leftBottom + checkOffset);
			BlockType leftBlock = map_->GetMapChipTypeByIndex(leftIndex.xIndex, leftIndex.yIndex);

			// å³ç‚¹ã®åˆ¤å®š
			IndexSet rightIndex = map_->GetMapChipIndexSetByPosition(rightBottom + checkOffset);
			BlockType rightBlock = map_->GetMapChipTypeByIndex(rightIndex.xIndex, rightIndex.yIndex);

			// ã©ã¡ã‚‰ã‹ã®ç‚¹ãŒåœ°é¢ã«æ¥è§¦ã—ã¦ã„ã‚Œã°OK
			bool leftHit = IsHitBlockTable(leftBlock);
			bool rightHit = IsHitBlockTable(rightBlock);

			// ã‚´ãƒ¼ãƒ«ãƒ–ãƒ­ãƒƒã‚¯ã®åˆ¤å®š
			if (IsHitGoalBlockTable(leftBlock) || IsHitGoalBlockTable(rightBlock)) {
				isGoal_ = true;
			}

			// ä¸¡æ–¹ã®ç‚¹ãŒåœ°é¢ã‹ã‚‰é›¢ã‚ŒãŸå ´åˆã®ã¿ã€åœ°é¢ã‹ã‚‰é›¢ã‚ŒãŸã¨ã™ã‚‹
			if (!leftHit && !rightHit) {
				onGround_ = false;
			}
		}
	}
}

void Player::WallCollisionMove(CollisionMapInfo& collisionInfo)
{
	if (collisionInfo.hitWall) {
		// å£ã«è¡çªã—ãŸã‚‰ç§»å‹•é‡ã‚’èª¿æ•´
		velocity_.x *= (1.0f - status_.kEpsilon);
	}
}

void Player::PlayerCollisionMove(const CollisionMapInfo& info)
{
	// ç§»å‹•é‡ã‚’åæ˜ 
	// åˆ¤å®šã‚’å–ã£ãŸå¾Œã®ç§»å‹•é‡ã‚’å–å¾—
	Vector3 position = playerModel_->GetTranslate();
	// ç§»å‹•é‡ã‚’åŠ ç®—
	position += info.move;
	// ä½ç½®ã‚’è¨­å®š
	playerModel_->SetTranslate(position);
}

void Player::CollisionMapInfoDirection(
	CollisionMapInfo& collisionInfo,
	CollisionType type,
	const std::array<Corner, 2>& checkCorners,
	const Vector3& offset,
	std::function<bool(const CollisionMapInfo&)> moveCondition)
{
	// ç§»å‹•é‡ãŒ0ãªã‚‰å‡¦ç†ã—ãªã„
	if (!moveCondition(collisionInfo))return;
	// ç¾åœ¨ã®ä½ç½®ã«ç§»å‹•é‡ã‚’åŠ ç®—ã—ãŸä½ç½®ã‚’å–å¾—
	Vector3 position = playerModel_->GetTranslate() + collisionInfo.move;

	// ï¼’ã¤ã®ã‚³ãƒ¼ãƒŠãƒ¼ä½ç½®ã®å½“ãŸã‚Šåˆ¤å®šã‚’å–å¾—
	std::array<Vector3, 2> points = {
		CornerPosition(position, checkCorners[0]) + offset,
		CornerPosition(position, checkCorners[1]) + offset
	};
	// å½“ãŸã‚Šåˆ¤å®šãŒã‚ã£ãŸã‹
	if (CheckCollisionPoints(points, static_cast<CollisionType>(type), collisionInfo)) {
		// å¿…è¦ã§ã‚ã‚Œã°ImGuiè¡¨ç¤ºã™ã‚‹
		switch (type) {
		case CollisionType::kTop:

			break;
		case CollisionType::kBottom:
			//Logger::Log("hit floor");
			break;
		case CollisionType::kRight:
			//Logger::Log("hit right");
			break;
		case CollisionType::kLeft:
			//Logger::Log("hit left");
			break;
		}
	}
}

Vector3 Player::CornerPosition(const Vector3& center, Corner corner)
{
	Vector3 offsetTable[kNumCorners] = {
		{+status_.kWidth / 2.0f, -status_.kHeight / 2.0f, 0.0f},// å³ä¸‹
		{-status_.kWidth / 2.0f, -status_.kHeight / 2.0f, 0.0f},// å·¦ä¸‹
		{+status_.kWidth / 2.0f, +status_.kHeight / 2.0f, 0.0f},// å³ä¸Š
		{-status_.kWidth / 2.0f, +status_.kHeight / 2.0f, 0.0f},// å·¦ä¸Š
	};
	return center + offsetTable[static_cast<uint32_t>(corner)];
}

bool Player::CheckCollisionPoints(const std::array<Vector3, 2>& posList, CollisionType type, CollisionMapInfo& collisionInfo)
{
	// å½“ãŸã‚Šåˆ¤å®šãƒ•ãƒ©ã‚°
	bool isHit = false;

	for (const auto& pos : posList) {
		// åˆ¤å®šã‚’è¡Œã†ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
		IndexSet index = map_->GetMapChipIndexSetByPosition(pos);
		// ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡ã‚’å–å¾—
		BlockType chip = map_->GetMapChipTypeByIndex(index.xIndex, index.yIndex);

		if (IsHitBlockTable(chip)) {
			isHit = true;
		} else if (IsHitGoalBlockTable(chip)) {
			// ã‚´ãƒ¼ãƒ«å‡¦ç†
			isGoal_ = true;
		}
	}
	// è¡çªã—ã¦ã„ãŸã‚‰ç§»å‹•é‡ã‚’èª¿æ•´
	if (isHit) {
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨ä½ç½®ã‚’å–å¾—
		Vector3 position = playerModel_->GetTranslate();
		IndexSet index = map_->GetMapChipIndexSetByPosition(position);

		Rect rect = map_->GetRectByIndex(index.xIndex, index.yIndex);
		// ç§»å‹•é‡ã‚’èª¿æ•´
		switch (type)
		{
		case CollisionType::kTop:
			collisionInfo.celling = true;
			collisionInfo.move.y = (std::max)(0.0f, rect.bottom - position.y - (status_.kHeight / 2.0f + status_.kEpsilon));
			break;
		case CollisionType::kBottom:
			collisionInfo.landing = true;
			collisionInfo.move.y = (std::min)(0.0f, rect.top - position.y + (status_.kHeight / 2.0f + status_.kEpsilon));
			break;
		case CollisionType::kRight:
			collisionInfo.hitWall = true;
			collisionInfo.move.x = (std::max)(0.0f, rect.left - position.x - (status_.kWidth / 2.0f + status_.kEpsilon));
			break;
		case CollisionType::kLeft:
			collisionInfo.hitWall = true;
			collisionInfo.move.x = (std::min)(0.0f, rect.right - position.x + (status_.kWidth / 2.0f + status_.kEpsilon));
			break;
		}
	}
	return isHit;
}

bool Player::IsHitBlockTable(BlockType type)
{
	// åˆ¤å®šã‚’å–ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã®ç¨®é¡ã‹ã©ã†ã‹
	switch (type)
	{
	case BlockType::GrassBlock:
	case BlockType::SoilBlock:
	case BlockType::breakBlock:
	case BlockType::Unbreakable:
		return true;

	default:
		return false;
	}
}

bool Player::IsHitGoalBlockTable(BlockType type)
{
	switch (type) {
	case BlockType::kGoalUp:
	case BlockType::kGoalDown:
		return true;
	default:
		return false;
	}
}

bool Player::IsHitBlockBreakableTable(BlockType type)
{
	switch (type) {
	case BlockType::breakBlock:
		return true;
	default:
		return false;
	}
}

void Player::DebugPlayerReset()
{
	// ãƒ‡ãƒãƒƒã‚°ç”¨ã«ãƒªã‚»ãƒƒãƒˆ
	velocity_ = {};
	playerModel_->SetTranslate({ 1.5f,1.5f,0.0f });
	playerModel_->SetRotate({ 0.0f,0.0f,0.0f });
	isDead_ = false;
	onGround_ = true;
}


void Player::Finalize()
{
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®è§£æ”¾
	if (dashSmokeEffect_) {
		dashSmokeEffect_->Stop();
		dashSmokeEffect_.reset();
	}
	if (dashStartEffect_) {
		dashStartEffect_->Stop();
		dashSmokeEffect_.reset();
	}
}

void Player::ImGui()
{
#ifdef USE_IMGUI
	ImGui::Begin("Player Status");

	if (ImGui::BeginTabBar("Player Status Tab"))
	{
		// ã‚¿ãƒ–ï¼‘ï¼šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼è¨­å®š
		if (ImGui::BeginTabItem("Parameters"))
		{
			ImGui::Text("=== Player Parameters ===");
			ImGui::SliderFloat("Acceleration", &status_.kAcceleration, 0.01f, 0.2f);
			ImGui::SliderFloat("Attenuation", &status_.kAttenuation, 0.0f, 0.5f);
			ImGui::SliderFloat("Max Speed", &status_.kMaxSpeed, 0.05f, 0.5f);
			ImGui::SliderFloat("Dash Speed Scale", &status_.kDashSpeedScale, 1.0f, 5.0f);
			ImGui::SliderFloat("Gravity", &status_.kGravity, 0.01f, 0.2f);
			ImGui::SliderFloat("Max Fall Speed", &status_.kMaxFallSpeed, 0.1f, 2.0f);
			ImGui::SliderFloat("Jump Power", &status_.kJumpPower, 0.1f, 1.0f);

			// Playerã®ã‚¹ã‚¿ãƒƒãƒ„ã®å¤‰æ›´
			Vector3 pos = playerModel_->GetTranslate();
			ImGui::DragFloat3("Player Position", &pos.x, 0.1f);
			playerModel_->SetTranslate(pos);
			Vector3 rot = playerModel_->GetRotate();
			ImGui::DragFloat3("Player Rotation", &rot.x, 0.1f);
			playerModel_->SetRotate(rot);
			ImGui::EndTabItem();
		}

		// ã‚¿ãƒ–ï¼’ï¼šæ•µè¡çªãƒ»ç‚¹æ»…é–¢é€£
		if (ImGui::BeginTabItem("Hit Enemy")) {
			// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”¨ãƒ‡ãƒãƒƒã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦


			ImGui::Text("=== Enemy Collision / Flashing ===");

			// æ•µãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°
			ImGui::Checkbox("isEnemyHit_", &isEnemyHit_);

			// ä»Šã®è¡¨ç¤ºçŠ¶æ…‹
			ImGui::Checkbox("isVisible_", &isVisible_);

			// ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ã‚¿
			ImGui::Text("flashingFrameCount_: %d", flashingFrameCount_);

			// æœ€å¤§ç‚¹æ»…ãƒ•ãƒ¬ãƒ¼ãƒ 
			{
				int tmp = static_cast<int>(maxFlashingFlame_);
				ImGui::DragInt("maxFlashingFlame_", &tmp, 1, 0, 600);
				maxFlashingFlame_ = static_cast<uint32_t>(tmp);
			}

			// ç‚¹æ»…é–“éš”ãƒ•ãƒ¬ãƒ¼ãƒ 
			{
				int tmp = static_cast<int>(flashingIntervalFrame_);
				ImGui::DragInt("flashingIntervalFrame_", &tmp, 1, 1, 120);
				flashingIntervalFrame_ = static_cast<uint32_t>(tmp);
			}

			// ä½™ã‚Šã®ç¢ºèªï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
			if (flashingIntervalFrame_ > 0) {
				int mod = flashingFrameCount_ % flashingIntervalFrame_;
				ImGui::Text("flashingFrameCount_ %% flashingIntervalFrame_ = %d", mod);
			}

			// ç‚¹æ»…ä¸­ã‹ã©ã†ã‹ã®åˆ¤å®šè¡¨ç¤º
			bool isFlashing = (flashingFrameCount_ <= maxFlashingFlame_);
			ImGui::Text("isFlashing: %s", isFlashing ? "true" : "false");

			ImGui::EndTabItem();
		}



		// ã‚¿ãƒ–ï¼“ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±è¡¨ç¤º
		if (ImGui::BeginTabItem("Player Info"))
		{
			ImGui::Text("=== Player Info ===");
			Vector3 pos = playerModel_->GetTranslate();
			Vector3 rotate = playerModel_->GetRotate();
			ImGui::Text("Position: (%.2f, %.2f, %.2f)", pos.x, pos.y, pos.z);
			ImGui::Text("Velocity: (%.2f, %.2f, %.2f)", velocity_.x, velocity_.y, velocity_.z);
			ImGui::Text("Rotate: (%.2f, %.2f, %.2f)", rotate.x, rotate.y, rotate.z);
			ImGui::Text("On Ground: %s", onGround_ ? "Yes" : "No");
			ImGui::Text("Is Dead: %s", isDead_ ? "Yes" : "No");
			ImGui::Text("Is Goal: %s", isGoal_ ? "Yes" : "No");
			ImGui::Text("Direction: %s",
				(direction_ == Direction::kRight) ? "Right" : "Left");
			ImGui::EndTabItem();
		}
		ImGui::EndTabBar();

	}

	ImGui::End();


#endif
}

============================================================
File Path: Game/Application/Player/Player.h
============================================================
#pragma once
#include "engine/math/MyMath.h"
#include <memory>
#include "engine/3d/Object3D.h"
#include "Game/Application/Map/Map.h"
#include "Game/Collision/Collider.h"
#include "Game/Particle/ParticleSystem.h"
/// <summary>
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹
/// </summary>



/// <summary>
/// è¡çªæƒ…å ±
/// </summary>
struct CollisionMapInfo {
	// å¤©äº•è¡çª
	bool celling = false;
	// åºŠè¡çª
	bool landing = false;
	// å£è¡çª
	bool hitWall = false;
	// ç§»å‹•é‡
	Vector3 move;
};

/// <summary>
/// ã‚³ãƒ¼ãƒŠãƒ¼
/// </summary>
enum Corner {
	// å³ä¸‹
	kRightBottom,
	// å·¦ä¸‹
	kLeftBottom,
	// å³ä¸Š
	kRightTop,
	// å·¦ä¸Š
	kLeftTop,
	// è¦ç´ æ•°
	kNumCorners
};

/// <summary>
/// è¡çªã‚¿ã‚¤ãƒ—
/// </summary>
enum class CollisionType {
	kTop,
	kBottom,
	kLeft,
	kRight
};

/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã€€
struct PlayerStatus {
	//é€Ÿåº¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	// åŠ é€Ÿåº¦
	float kAcceleration = 0.05f;
	// é€Ÿåº¦æ¸›è¡°ç‡
	float kAttenuation = 0.2f;
	// æœ€å¤§é€Ÿåº¦
	float kMaxSpeed = 0.1f;

	//ãƒ€ãƒƒã‚·ãƒ¥ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	// ãƒ€ãƒƒã‚·ãƒ¥é€Ÿåº¦å€ç‡
	float kDashSpeedScale = 2.0f;
	// ï¼’å›æŠ¼ã—åˆ¤å®šæ™‚é–“
	uint32_t kDashDoubleTapFrame = 15;

	//ã‚¸ãƒ£ãƒ³ãƒ—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	// é‡åŠ›åŠ é€Ÿåº¦
	float kGravity = 0.05f;
	// æœ€å¤§è½ä¸‹é€Ÿåº¦
	float kMaxFallSpeed = 1.0f;
	// ã‚¸ãƒ£ãƒ³ãƒ—åˆé€Ÿåº¦
	float kJumpPower = 0.5f;
	// æºœã‚æ™‚é–“
	float kMaxChargeTime = 0.2f;

	//å½“ãŸã‚Šåˆ¤å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	// å¹…
	float kWidth = 0.8f;
	// é«˜ã•
	float kHeight = 0.8f;
	// å½“ãŸã‚Šåˆ¤å®šã®ä½™è£•
	float kBlank = 0.0f;
	// å¾®å°å€¤
	float kEpsilon = 0.05f;

	//æ¸›è¡°ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	// ç€åœ°æ™‚ã®æ¸›è¡°ç‡
	float kAttenuationLanding = 0.1f;
	// å£ã«è¡çªã—ãŸã¨ãã®æ¸›è¡°ç‡
	float kAttenuationWall = 1.0f;

	//æŒ¯ã‚Šå‘ããƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	// è§’åº¦ã®è£œé–“ã‚¿ã‚¤ãƒ 
	float kTurnTime = 0.1f;
};

class Player :public Collider
{
public:

	/// <summary>
	/// å‘ã
	/// </summary>
	enum class Direction {
		kRight,
		kLeft
	};


	// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹
	Collider::Type GetType() const override;
	AABB GetAABB() const override;
	void OnCollision(Collider* other)override;

public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="position">åˆæœŸé…ç½®</param>
	void Initialize(Vector3 position);

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();


	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();

private:
	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æŒ™å‹•æ›´æ–°çµ±æ‹¬ / åˆ¤å®š / ç§»å‹• / ãã®ä»–
	/// </summary>
	void UpdateBehavior();

	/// <summary>
	/// ç§»å‹•å‡¦ç†
	/// </summary>
	void Move();

	/// <summary>
	/// ã‚¸ãƒ£ãƒ³ãƒ—å‡¦ç†
	/// </summary>
	void Jump();

	/// <summary>
	/// ImGuiè¡¨ç¤º
	/// </summary>
	void ImGui();

	/// <summary>
	/// ãƒãƒƒãƒ—è¡çªãƒã‚§ãƒƒã‚¯
	/// </summary>
	void MapCollision(CollisionMapInfo& collisionInfo);

	/// <summary>
	/// å¤©äº•è¡çªãƒã‚§ãƒƒã‚¯
	///ã€€å¤©äº•ã«è¡çªã—ãŸã‚‰ç§»å‹•é‡ã‚’èª¿æ•´
	///ã€€</summary>
	void CellingCollisionMove(CollisionMapInfo& collisionInfo);

	/// <summary>
	/// åºŠè¡çªãƒã‚§ãƒƒã‚¯
	/// åºŠã«è¡çªã—ãŸã‚‰ç§»å‹•é‡ã‚’èª¿æ•´
	/// </summary>
	void LandingCollisionMove(CollisionMapInfo& collisionInfo);

	/// <summary>
	/// å£è¡çªãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="collisionInfo"></param>
	void WallCollisionMove(CollisionMapInfo& collisionInfo);

	/// <summary>
	/// è¡çªãƒãƒƒãƒ—æƒ…å ±å–å¾—
	/// </summary>
	/// <param name="info"></param>
	void PlayerCollisionMove(const CollisionMapInfo& info);


	/// <summary>
	/// ãƒãƒƒãƒ—ã¨ã®è¡çªåˆ¤å®šã‚’æŒ‡å®šæ–¹å‘ã«è¡Œã†å…±é€šå‡¦ç†
	/// ç§»å‹•å¾Œã®å½“ãŸã‚Šåˆ¤å®šãƒã‚¤ãƒ³ãƒˆã‚’ãƒã‚§ãƒƒã‚¯ã—ã€ç§»å‹•æ¡ä»¶ã‚’æº€ãŸã™å ´åˆã«ç§»å‹•é‡ã‚’æ›´æ–°ã™ã‚‹
	/// </summary>
	/// <param name="collisionInfo">è¡çªåˆ¤å®šã«ä½¿ç”¨ã™ã‚‹æƒ…å ±</param>
	/// <param name="type">åˆ¤å®šæ–¹å‘</param>
	/// <param name="checkCorners">åˆ¤å®šã‚’å–ã‚‹ï¼’ã¤ã®ã‚³ãƒ¼ãƒŠãƒ¼</param>
	/// <param name="offset">åˆ¤å®šç‚¹ã«åŠ ç®—ã™ã‚‹ã‚ªãƒ•ã‚»ãƒƒãƒˆ</param>
	/// <param name="moveCondition">æ–¹å‘ã®åˆ¤å®šã‚’è¡Œã†æ¡ä»¶ falseã®å ´åˆåˆ¤å®šã‚’ã‚¹ã‚­ãƒƒãƒ—</param>
	void CollisionMapInfoDirection(
		CollisionMapInfo& collisionInfo,
		CollisionType type,
		const std::array<Corner, 2>& checkCorners,
		const Vector3& offset,
		std::function<bool(const CollisionMapInfo&)>moveCondition);

	/// <summary>
	/// ã‚³ãƒ¼ãƒŠãƒ¼ä½ç½®å–å¾—
	/// </summary>
	Vector3 CornerPosition(const Vector3& center, Corner corner);

	/// <summary>
	/// å½“ãŸã‚Šåˆ¤å®šãƒã‚¤ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="posList"></param>
	/// <param name="type"></param>
	/// <param name="collisionInfo"></param>
	bool CheckCollisionPoints(const std::array<Vector3, 2>& posList, CollisionType type, CollisionMapInfo& collisionInfo);


	/// <summary>
	/// å½“ãŸã‚Šåˆ¤å®šãƒ–ãƒ­ãƒƒã‚¯ãƒ†ãƒ¼ãƒ–ãƒ«
	/// </summary>
	/// <param name="type">æŒ‡å®šã®ãƒ–ãƒ­ãƒƒã‚¯ã¯åˆ¤å®šã‚’å–ã‚‹ã‹</param>
	/// <returns>å½“ãŸã£ã¦ã„ã‚‹ã‹ã„ãªã„ã‹</returns>
	bool IsHitBlockTable(BlockType type);

	/// <summary>
	/// ã‚´ãƒ¼ãƒ«ãƒ–ãƒ­ãƒƒã‚¯å½“ãŸã‚Šåˆ¤å®šãƒ†ãƒ¼ãƒ–ãƒ«
	/// </summary>
	/// <param name="type">ã‚´ãƒ¼ãƒ«åˆ¤å®šã®ã‚ã‚‹ãƒ–ãƒ­ãƒƒã‚¯</param>
	/// <returns>ã‚´ãƒ¼ãƒ«åˆ¤å®šã®ã‚ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã‹ã©ã†ã‹</returns>
	bool IsHitGoalBlockTable(BlockType type);

	/// <summary>
	/// å£Šã›ã‚‹ãƒ–ãƒ­ãƒƒã‚¯å½“ãŸã‚Šåˆ¤å®šãƒ†ãƒ¼ãƒ–ãƒ«
	/// </summary>
	/// <param name="type"></param>
	/// <returns></returns>
	bool IsHitBlockBreakableTable(BlockType type);

	/// <summary>
	/// ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ­»äº¡æ™‚ãƒªã‚»ãƒƒãƒˆ
	/// </summary>
	void DebugPlayerReset();

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã«å½“ãŸã£ãŸå ´åˆã®è¡çªå‡¦ç†
	/// </summary>
	void EnemyCollision();

	/// <summary>
	///	ç‚¹æ»…æ›´æ–°å‡¦ç†
	/// </summary>
	void FlashingUpdate();

	/// <summary>
	/// å‘ãã‚’å¤‰æ›´ã—ãŸã¨ãã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¢ãƒ‡ãƒ«ã‚’å›è»¢ã•ã›ã‚‹
	/// </summary>
	void PlayerTurn();

	/// <summary>
	/// ãƒ€ãƒƒã‚·ãƒ¥ä¸­ã«ç™ºç”Ÿã™ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æ›´æ–°
	/// </summary>
	void UpdateDashEffect();


public:	/// Setter / Getter
	// æ­»äº¡åˆ¤å®šã®é«˜ã•ã‚’è¨­å®š
	void SetDeathHeight(float deathHeight) { deathHeight_ = deathHeight; }

	// ãƒãƒƒãƒ—ã®ã‚»ãƒƒãƒˆ
	void SetMap(Map* map) { map_ = map; }

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®æƒ…å ±å–å¾—
	const Vector3 GetTranslate()const { return playerModel_->GetTranslate(); }

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ•µã«ãƒ’ãƒƒãƒˆã—ã¦ã„ã‚‹ã‹ã©ã†ã‹
	bool GetHitEnemy()const { return isEnemyHit_; }

	// ã‚´ãƒ¼ãƒ«ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹
	bool GetIsGoal()const { return isGoal_; }

	// æ“ä½œã®æœ‰åŠ¹/ç„¡åŠ¹
	void SetControlEnabled(bool enabled) { controlEnabled_ = enabled; }
	bool IsControlEnabled() const { return controlEnabled_; }


private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	PlayerStatus status_;
	// é€Ÿåº¦
	Vector3 velocity_ = {};

	// æ­»äº¡åˆ¤å®šã®é«˜ã• / ç”»é¢å¤–ã«å‡ºãŸã‚‰æ­»äº¡åˆ¤å®šã¨ã™ã‚‹
	float deathHeight_;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¢ãƒ‡ãƒ«
	std::unique_ptr<Object3D> playerModel_ = nullptr;

	// æ­»äº¡ãƒ•ãƒ©ã‚°
	bool isDead_ = false;

	// ãƒãƒƒãƒ—
	Map* map_ = nullptr;

	// ã‚´ãƒ¼ãƒ«ãƒ•ãƒ©ã‚°
	bool isGoal_ = false;

	// ã‚¸ãƒ£ãƒ³ãƒ—
	bool onGround_ = true;

	// ãƒ€ãƒƒã‚·ãƒ¥
	bool isDash_ = false;

	// å‘ã / +1:å³ -1:å·¦ 0:ãªã—
	int32_t dashDirection_ = 0;

	// ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®šç”¨ã‚¿ã‚¤ãƒãƒ¼
	uint32_t rightTapTimer_ = 0;
	uint32_t leftTapTimer_ = 0;

	// ã‚¨ãƒãƒŸãƒ¼ã«å½“ãŸã£ãŸã‹ã©ã†ã‹
	bool isEnemyHit_ = false;

	// ç‚¹æ»…ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ãƒˆ
	uint32_t flashingFrameCount_ = 0;
	// ç¾çŠ¶ã®ç‚¹æ»…å›æ•°
	uint32_t flashingCount_ = 0;
	// ç‚¹æ»…æŒç¶šãƒ•ãƒ¬ãƒ¼ãƒ æ•°
	uint32_t maxFlashingFlame_ = 120;
	// ä½•ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«ç‚¹æ»…ã™ã‚‹ã‹
	uint32_t flashingIntervalFrame_ = 10;
	// å¯è¦–ãƒ•ãƒ©ã‚°
	bool isVisible_ = true;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸€å‘¨
	float playerTurnAround_ = 6.3f;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ã
	Direction direction_ = Direction::kRight;
	float turnSpeed_ = 0.2f;
	float targetYaw_ = 0.0f;


	// æ“ä½œã®æœ‰åŠ¹/ç„¡åŠ¹
	bool controlEnabled_ = true;

	// ãƒ€ãƒƒã‚·ãƒ¥ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	// è¶³å…ƒã®ç…™
	std::unique_ptr<ParticleSystem>dashSmokeEffect_;
	// ãƒ€ãƒƒã‚·ãƒ¥é–‹å§‹æ™‚ã®å°‘ã—æ´¾æ‰‹ç›®ç”¨
	std::unique_ptr<ParticleSystem>dashStartEffect_;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’å‡ºã™ãŸã‚ã®ãƒ€ãƒƒã‚·ãƒ¥çŠ¶æ…‹ã®è¿½è·¡
	bool wasDashing_ = false;
	uint32_t dashEffectCounter_ = 0;
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç™ºç”Ÿä½ç½®ã‚’ãšã‚‰ã™
	float particleSpawnPosOffset_ = 0.4f;

};



============================================================
File Path: Game/Application/StageType.cpp
============================================================
#include "StageType.h"


============================================================
File Path: Game/Application/StageType.h
============================================================
#pragma once

enum class StatgeType {
	stage1,
	stage2,
	stage3,
	stage4,
	stage5,
	stage6,
	stage7,
	stage8,
	stage9,
	stage10,
};


============================================================
File Path: Game/Application/UI/DamageFeedBack.cpp
============================================================
#include "DamageFeedBack.h"

static float Clamp01(float x) {
	return std::clamp(x, 0.0f, 1.0f);
}

void DamageFeedBack::Bind(Player* player, Camera* camera, Transform* cameraTransform)
{
	player_ = player;
	camera_ = camera;
	cameraTransform_ = cameraTransform;

}

bool DamageFeedBack::IsActive() const
{
	if (!hitSprite_) {
		return false;
	}
	const float a = hitSprite_->GetColor().w;
	return shakeActive_ || (a > 0.0f);
}

void DamageFeedBack::Reset()
{
	wasHitPrev_ = false;
	shakeActive_ = false;
	shakeTimer_ = 0.0f;
	baseCamPos_ = {};

	if (hitSprite_) {
		hitSprite_->SetColor(flashColorOff_);
	}
}

void DamageFeedBack::BeginHit()
{
	shakeActive_ = true;
	shakeTimer_ = 0.0f;

	// ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	if (hitSprite_) {
		hitSprite_->SetColor(flashColorOn_);
	}

	
}

void DamageFeedBack::UpdateFlash()
{
	if (!hitSprite_) {
		return;
	}
	Vector4 currentColor = hitSprite_->GetColor();
	if (currentColor.w > 0.0f) {
		// æ¸›ç®—ã‚¹ãƒ”ãƒ¼ãƒ‰ã¯ 0.01f ï½ 0.05f ãã‚‰ã„ã§èª¿æ•´
		currentColor.w = (std::max)(0.0f, currentColor.w - fadeSpeed_);
		hitSprite_->SetColor(currentColor);
	}
}

void DamageFeedBack::UpdateShake(float dt)
{
	if (!shakeActive_)return;
	if (!camera_ || !cameraTransform_) return;

	shakeTimer_ += dt;

	// æ¸›è¡°
	float u = Clamp01(1.0f - (shakeTimer_ / shakeTime_));

	// ï¼’è»¸(x,y)ã®ã‚·ã‚§ã‚¤ã‚¯
	float sx = std::sin(shakeTimer_ * 80.0f);
	float sy = std::sin(shakeTimer_ * 100.0f);

	Vector3 offset = { sx * shakeAmp_ * u, sy * shakeAmp_ * u, 0.0f };

	cameraTransform_->translate = baseCamPos_ + offset;
	camera_->SetTranslate(cameraTransform_->translate);

	// ã‚·ã‚§ã‚¤ã‚¯çµ‚äº†
	if (shakeTimer_ >= shakeTime_) {
		shakeTimer_ = 0.0f;
		shakeActive_ = false;
		// æœ€çµ‚çš„ã«ã¯å…ƒã®ä½ç½®ã«æˆ»ã™
		cameraTransform_->translate = baseCamPos_;
		camera_->SetTranslate(baseCamPos_);
	}

}


void DamageFeedBack::Initialize()
{
	hitSprite_ = std::make_unique<Sprite>();
	hitSprite_->Initialize(texturePath_);
	hitSprite_->SetSize({ 1280.0f,720.0f });
	hitSprite_->SetPosition({ 0.0f,0.0f });
	hitSprite_->SetColor(flashColorOff_);

	Reset();
}

void DamageFeedBack::Update(float dt)
{
	if (!player_ || !camera_ || !cameraTransform_)return;

	const bool hitNow = player_->GetHitEnemy();

	if(hitNow && !wasHitPrev_){
		BeginHit();
	}

	wasHitPrev_ = hitNow;


	if (hitSprite_) {
		hitSprite_->Update();
	}

	// ãƒ•ãƒ©ãƒƒã‚·ãƒ¥æ¸›è¡°
	UpdateFlash();

	// ã‚·ã‚§ã‚¤ã‚¯æ›´æ–°
	UpdateShake(dt);
}

void DamageFeedBack::Draw()
{
	if (!hitSprite_){
		return;
	}
	if (IsActive()){
		hitSprite_->Draw();
	}
}




============================================================
File Path: Game/Application/UI/DamageFeedBack.h
============================================================
#pragma once
#include "Game/Camera/Camera.h"
#include "Game/Application/Player/Player.h"
#include "engine/2d/Sprite.h"
class Player;
class Camera;
class DamageFeedBack
{

public:
	void Initialize();

	void Update(float dt);

	void Draw();

	void Bind(Player* player,Camera*camera,Transform*cameraTransform);

	bool IsActive()const;

	void Reset();


public: // Getter / Setter
	void SetBaseCameraPos(const Vector3& basePos) { baseCamPos_ = basePos; }

private:
	void BeginHit();

	void UpdateFlash();

	void UpdateShake(float dt);

private:
	// æ•µã«è¡çªã—ãŸã¨ãã®ã‚·ã‚§ã‚¤ã‚¯æ™‚é–“
	float shakeTime_ = 0.5f;
	// ã‚·ã‚§ã‚¤ã‚¯ã®å¼·ã•
	float shakeAmp_ = 0.2f;
	// Î±å€¤ã®æ¸›è¡°é€Ÿåº¦
	float fadeSpeed_ = 0.02f;

	Vector4 flashColorOn_ = { 1.0f,1.0f,1.0f,0.5f };
	Vector4 flashColorOff_ = { 1.0f,1.0f,1.0f,0.0f };

	// ç”»åƒãƒ‘ã‚¹
	std::string texturePath_ = "resources/HitDamage.png";

private:
	Player* player_ = nullptr;
	Camera* camera_ = nullptr;
	Transform* cameraTransform_ = nullptr;

	// ãƒ’ãƒƒãƒˆæ¤œå‡º
	bool wasHitPrev_ = false;

	// ã‚·ã‚§ã‚¤ã‚¯
	bool shakeActive_ = false;
	float shakeTimer_ = 0.0f;
	Vector3 baseCamPos_ = {};

	// ãƒ’ãƒƒãƒˆæ™‚ã®ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::unique_ptr<Sprite> hitSprite_ = nullptr;

};



============================================================
File Path: Game/Application/UI/GamePlayHUD.cpp
============================================================
#include "GamePlayHUD.h"
#include "Input.h"
#include "ImGuiManager.h"
void GamePlayHUD::Initialize()
{
	// ãƒãƒ¼ã‚ºã‚¢ã‚¤ã‚³ãƒ³
	pauseSprite_ = MakeSprite("resources/KyeUI/Esc.png",
		{ 30.0f,30.0f }, { 50.0f,50.0f }, { 1.0f,1.0f,1.0f,1.0f });
	// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«UI
	// Dã‚­ãƒ¼
	controlUI_D = MakeSprite("resources/KyeUI/D.png",
		{ 200.0f,70.0f }, { 50.0f,50.0f }, { 1.0f,1.0f,1.0f,0.5f });
	// Aã‚­ãƒ¼
	controlUI_A = MakeSprite("resources/KyeUI/A.png",
		{ 100.0f,70.0f }, { 50.0f,50.0f }, { 1.0f,1.0f,1.0f,0.5f });
	// Sã‚­ãƒ¼
	controlUI_S = MakeSprite("resources/KyeUI/S.png",
		{ 150.0f,70.0f }, { 50.0f,50.0f }, { 1.0f,1.0f,1.0f,0.5f });
	// Wã‚­ãƒ¼
	controlUI_W = MakeSprite("resources/KyeUI/W.png",
		{ 150.0f,20.0f }, { 50.0f,50.0f }, { 1.0f,1.0f,1.0f,0.5f });

	UiActive_ = false;
	uiTimer = 0;
	
}

void GamePlayHUD::Update()
{
	// UI
	pauseSprite_->Update();
	controlUI_D->Update();
	controlUI_A->Update();
	controlUI_S->Update();
	controlUI_W->Update();
	
	UpdateControlUI();
	
	
	
}

void GamePlayHUD::UpdateControlUI()
{
	// æŠ¼ã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¼ã ã‘è‰²ã‚’æ¿ƒãã™ã‚‹
	// D
	if (Input::GetInstance()->PushKey(DIK_D)) {
		// è‰²ã‚’æ¿ƒãã™ã‚‹
		controlUI_D->SetColor(activeColor_);
		// å°‘ã—ã ã‘å³ã«ãšã‚‰ã™
		controlUI_D->SetPosition({ 200 + pressedOffset_,70.0f });
	} else {
		// å…ƒã®è–„ã„è‰²ã«æˆ»ã™
		controlUI_D->SetColor(inactiveColor_);
		// å…ƒã®ä½ç½®ã«æˆ»ã™
		controlUI_D->SetPosition({ 200.0f,70.0f });
	}
	 if (Input::GetInstance()->PushKey(DIK_A)) {
        controlUI_A->SetColor(activeColor_);
        controlUI_A->SetPosition({ 100.0f - pressedOffset_, 70.0f });
    } else {
        controlUI_A->SetColor(inactiveColor_);
        controlUI_A->SetPosition({ 100.0f, 70.0f });
    }

    // S
    if (Input::GetInstance()->PushKey(DIK_S)) {
        controlUI_S->SetColor(activeColor_);
        controlUI_S->SetPosition({ 150.0f, 70.0f + pressedOffset_ });
    } else {
        controlUI_S->SetColor(inactiveColor_);
        controlUI_S->SetPosition({ 150.0f, 70.0f });
    }

    // W
    if (Input::GetInstance()->PushKey(DIK_W)) {
        controlUI_W->SetColor(activeColor_);
        controlUI_W->SetPosition({ 150.0f, 20.0f - pressedOffset_ });
    } else {
        controlUI_W->SetColor(inactiveColor_);
        controlUI_W->SetPosition({ 150.0f, 20.0f });
    }
}

void GamePlayHUD::UpdatePauseIcon()
{
}

void GamePlayHUD::Draw(bool isPaused, bool showControls)
{
	// ãƒãƒ¼ã‚ºä¸­ã¯ãƒãƒ¼ã‚ºã‚¢ã‚¤ã‚³ãƒ³ã‚’è¡¨ç¤º
	if (isPaused) {
		pauseSprite_->Draw();
	}
	
	// æ“ä½œç³»UIè¡¨ç¤º
	if (showControls) {
		controlUI_D->Draw();
		controlUI_A->Draw();
		controlUI_S->Draw();
		controlUI_W->Draw();
	}
	pauseSprite_->Draw();
}

void GamePlayHUD::DrawImGui()
{
#ifdef USE_IMGUI
	ImGui::Begin("GamePlay HUD");
	ImGui::SeparatorText("Pause Icon");
	Vector2 pausePos = pauseSprite_->GetPosition();
	Vector2 pauseSize = pauseSprite_->GetSize();
	ImGui::DragFloat2("Pause Position", &pausePos.x, 1.0f, 0.0f, 1280.0f);
	ImGui::DragFloat2("Pause Size", &pauseSize.x, 1.0f, 0.0f, 500.0f);
	pauseSprite_->SetPosition(pausePos);
	pauseSprite_->SetSize(pauseSize);
	ImGui::SeparatorText("Control UI Positions and Sizes");
	Vector2 dPos = controlUI_D->GetPosition();
	Vector2 aPos = controlUI_A->GetPosition();
	Vector2 sPos = controlUI_S->GetPosition();
	Vector2 wPos = controlUI_W->GetPosition();
	Vector2 dSize = controlUI_D->GetSize();
	Vector2 aSize = controlUI_A->GetSize();
	Vector2 sSize = controlUI_S->GetSize();
	Vector2 wSize = controlUI_W->GetSize();
	ImGui::DragFloat2("D Position", &dPos.x, 1.0f, 0.0f, 1280.0f);
	ImGui::DragFloat2("D Size", &dSize.x, 1.0f, 0.0f, 500.0f);
	ImGui::DragFloat2("A Position", &aPos.x, 1.0f, 0.0f, 1280.0f);
	ImGui::DragFloat2("A Size", &aSize.x, 1.0f, 0.0f, 500.0f);
	ImGui::DragFloat2("S Position", &sPos.x, 1.0f, 0.0f, 1280.0f);
	ImGui::DragFloat2("S Size", &sSize.x, 1.0f, 0.0f, 500.0f);
	ImGui::DragFloat2("W Position", &wPos.x, 1.0f, 0.0f, 1280.0f);
	ImGui::DragFloat2("W Size", &wSize.x, 1.0f, 0.0, 500.0f);
	controlUI_D->SetPosition(dPos);
	controlUI_D->SetSize(dSize);
	controlUI_A->SetPosition(aPos);
	controlUI_A->SetSize(aSize);
	controlUI_S->SetPosition(sPos);
	controlUI_S->SetSize(sSize);
	controlUI_W->SetPosition(wPos);
	controlUI_W->SetSize(wSize);
	ImGui::End();
#endif
}

std::unique_ptr<Sprite> GamePlayHUD::MakeSprite(const std::string& path, const Vector2& pos, const Vector2& size, const Vector4 color)
{
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆç”Ÿæˆ
	auto sprite = std::make_unique<Sprite>();
	sprite->Initialize(path);
	sprite->SetPosition(pos);
	sprite->SetSize(size);
	sprite->SetColor(color);
	return sprite;
}


============================================================
File Path: Game/Application/UI/GamePlayHUD.h
============================================================
#pragma once
#include <memory>
#include "engine/2d/Sprite.h"
#include "engine/math/MyMath.h"

class GamePlayHUD
{
public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	/// <param name="dt">ã‚²ãƒ¼ãƒ å†…æ™‚é–“</param>
	void Update();

	/// <summary>
	/// æ“ä½œUIã®æ›´æ–°
	/// </summary>
	void UpdateControlUI();

	/// <summary>
	/// ãƒãƒ¼ã‚ºã‚¢ã‚¤ã‚³ãƒ³ã®æ›´æ–°
	/// </summary>
	void UpdatePauseIcon();

	/// <summary>
	/// æç”»
	/// </summary>
	/// <param name="isPaused">ãƒãƒ¼ã‚ºä¸­ã‹</param>
	/// <param name="showControls">æ“ä½œç³»UIãŒè¦‹ãˆã‚‹çŠ¶æ…‹ã‹</param>
	void Draw(bool isPaused,bool showControls);


	/// <summary>
	/// ImGuiã®æç”»
	/// </summary>
	void DrawImGui();

	/// <summary>
	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ç”Ÿæˆãƒ˜ãƒ«ãƒ‘
	/// </summary>
	std::unique_ptr<Sprite> MakeSprite(const std::string& path, const Vector2& pos, const Vector2& size, const Vector4 color);


private:
	// æ“ä½œUI
	// Dã‚­ãƒ¼UI
	std::unique_ptr<Sprite> controlUI_D;
	Vector2 controlUI_DPos_ = { 100.0f, 600.0f };
	Vector4 controlUIColorD_ = { 1.0f,1.0f,1.0f,0.5f };
	// Aã‚­ãƒ¼UI
	std::unique_ptr<Sprite>controlUI_A;
	Vector2 controlUIAPos_ = { 50.0f,600.0f };
	Vector4 controlUIColorA_ = { 1.0f,1.0f,1.0f,0.5f };
	// Wã‚­ãƒ¼UI
	std::unique_ptr<Sprite>controlUI_W;
	Vector2 controlUIWPos_ = { 75.0f,550.0f };
	Vector4 controlUIColorW_ = { 1.0f,1.0f,1.0f,0.5f };
	// Sã‚­ãƒ¼UI
	std::unique_ptr<Sprite>controlUI_S;
	Vector2 controlUISPos_ = { 75.0f,650.0f };
	Vector4 controlUIColorS_ = { 1.0f,1.0f,1.0f,0.5f };

	// ãƒãƒ¼ã‚ºæ¡ˆå†…(esc)
	std::unique_ptr<Sprite> pauseSprite_;

	// UIã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ©ã‚°
	bool UiActive_ = false;
	int32_t uiTimer = 0;

	// éã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ©ãƒ¼ / æŠ¼ã•ã‚Œã¦ã„ãªã„æ™‚ã¯åŠé€æ˜
	Vector4 inactiveColor_ = { 1.0f,1.0f,1.0f,0.5f };
	// ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ã‚«ãƒ©ãƒ¼ / æŠ¼ã•ã‚Œã¦ã„ã‚‹æ™‚ã¯ä¸é€æ˜
	Vector4 activeColor_ = { 1.0f,1.0f,1.0f,1.0f };

	// æŠ¼ã•ã‚ŒãŸæ™‚ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆé‡
	float pressedOffset_ = 5.0f;

	
};



============================================================
File Path: Game/Camera/Camera.cpp
============================================================
#include "Camera.h"

Camera::Camera()
	: transform({ {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f} })
	, fovY(0.45f)
	, aspectRatio(float(WinAPI::kClientWidth) / float(WinAPI::kClientHeight))
	, nearClip(0.1f)
	, farClip(100.0f)
	, worldMatrix(MakeAffineMatrix(transform.scale,transform.rotate,transform.translate))
	, viewMatrix(Inverse(worldMatrix))
	, projectionMatrix(MakePerspectiveFovMatrix(fovY, aspectRatio, nearClip, farClip))
	, viewProjectionMatrix(Multiply(viewMatrix, projectionMatrix))
{

}

void Camera::Initialize()
{
}

void Camera::Update()
{
	// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‹ã‚‰å¤‰æ›è¡Œåˆ—ã‚’è¨ˆç®—
	worldMatrix = MakeAffineMatrix(transform.scale, transform.rotate, transform.translate);
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã®é€†è¡Œåˆ—
	viewMatrix = Inverse(worldMatrix);
	// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—æ›´æ–°
	projectionMatrix = MakePerspectiveFovMatrix(fovY, aspectRatio, nearClip, farClip);
	// ãƒ“ãƒ¥ãƒ¼ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã®è¨ˆç®—
	viewProjectionMatrix = Multiply(viewMatrix, projectionMatrix);

}

void Camera::Draw()
{
}


============================================================
File Path: Game/Camera/Camera.h
============================================================
#pragma once
#include "MyMath.h"
#include "MakeMatrix.h"
#include "WinAPI.h"

/// ã‚«ãƒ¡ãƒ©ã‚¯ãƒ©ã‚¹
class Camera
{
public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	Camera();
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();
		
public:	
	// setter
	/// <summary>
	/// å›è»¢ãƒ»å¹³è¡Œç§»å‹•ã®è¨­å®š
	/// </summary>
	void SetRotate(const Vector3& rotate) { transform.rotate = rotate; }
	void SetTranslate(const Vector3& translate) { transform.translate = translate; }
	
	/// <summary>
	/// è¦–é‡è§’ã®è¨­å®š
	/// </summary>
	/// <param name="fov"></param>
	void SetFovY(float fov) { this->fovY = fov; }

	/// <summary>
	/// ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã®è¨­å®š
	/// </summary>
	/// <param name="aspect"></param>
	void SetAspectRatio(float aspect) { this->aspectRatio = aspect; }

	/// <summary>
	/// ãƒ‹ã‚¢ã‚¯ãƒªãƒƒãƒ—ã®è¨­å®š
	/// </summary>
	/// <param name="nearClip"></param>
	void SetNearClip(float nearClip) { this->nearClip = nearClip; }

	/// <summary>
	/// ãƒ•ã‚¡ãƒ¼ã‚¯ãƒªãƒƒãƒ—ã®è¨­å®š
	/// </summary>
	/// <param name="farClip"></param>
	void SetFarClip(float farClip) { this->farClip = farClip; }

	// getter
	/// <summary>
	/// å„ç¨®è¡Œåˆ—ã®å–å¾—
	/// </summary>
	const Matrix4x4& GetWorldMatrix()const { return worldMatrix; }
	
	/// <summary>
	/// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	const Matrix4x4& GetViewMatrix()const { return viewMatrix; }
	
	/// <summary>
	/// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã®å–å¾—
	/// </summary>
	const Matrix4x4& GetProjectionMatrix()const { return projectionMatrix; }
	
	/// <summary>
	/// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	const Matrix4x4& GetViewProjectionMatrix()const { return viewProjectionMatrix; }
	
	/// <summary> 
	/// æ‹¡ç¸®ãƒ»å›è»¢ãƒ»å¹³è¡Œç§»å‹•ã®å–å¾—
	/// </summary>
	const Vector3& GetScale()const { return transform.scale; }
	const Vector3& GetRotate()const { return transform.rotate; }
	const Vector3& GetTranslate()const { return transform.translate; }


private:
	// ã‚«ãƒ¡ãƒ©ã®å¤‰æ›æƒ…å ±
	Transform transform;
	// æ°´å¹³æ–¹å‘è¦–é‡è§’
	float fovY = 0.45f;
	// ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”
	float aspectRatio = float(WinAPI::kClientWidth) / float(WinAPI::kClientHeight);
	// ãƒ‹ã‚¢ã‚¯ãƒªãƒƒãƒ—
	float nearClip = 0.1f;
	// ãƒ•ã‚¡ãƒ¼ã‚¯ãƒªãƒƒãƒ—
	float farClip = 100.0f;
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—
	Matrix4x4 worldMatrix;
	Matrix4x4 viewMatrix;

	Matrix4x4 projectionMatrix;

	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—
	Matrix4x4 viewProjectionMatrix;


};



============================================================
File Path: Game/Camera/CameraController.cpp
============================================================
#include "CameraController.h"

static Vector3 Lerp(const Vector3& a, const Vector3& b, float t)
{
	return a + (b - a) * t;
}

void CameraController::Initialize()
{
}


void CameraController::Update(float deltaTime)
{
    // å‘ãã«å¿œã˜ãŸã€Œç›®æ¨™ã‚ªãƒ•ã‚»ãƒƒãƒˆã€ï¼ˆç†æƒ³å€¤ï¼‰
    float targetOffsetX = 0.0f;
    if (moveDirection > 0) {
        // å³ã«é€²ã‚€ã¨ãï¼šã‚«ãƒ¡ãƒ©ã‚’å°‘ã—å³ã¸ â†’ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ç”»é¢å·¦å¯„ã‚Š
        targetOffsetX = followOffsetX_;
    } else if (moveDirection < 0) {
        // å·¦ã«é€²ã‚€ã¨ãï¼šã‚«ãƒ¡ãƒ©ã‚’å°‘ã—å·¦ã¸ â†’ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ç”»é¢å³å¯„ã‚Š
        targetOffsetX = -followOffsetX_;
    }
    // moveDirection == 0 ã®ã¨ãã¯ 0ï¼ˆä¸­å¤®ã«æˆ»ã‚‹ï¼‰

    // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ãªã‚ã‚‰ã‹ã«åˆ‡ã‚Šæ›¿ãˆ
    float ot = offsetLerpSpeed_ * deltaTime;
    if (ot > 1.0f) ot = 1.0f;
    currentOffsetX_ = currentOffsetX_ + (targetOffsetX - currentOffsetX_) * ot;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½® + ã‚ªãƒ•ã‚»ãƒƒãƒˆ = ç†æƒ³ã®ã‚«ãƒ¡ãƒ©ä¸­å¿ƒ
    float centerX = targetPosition_.x + currentOffsetX_;

    // ã‚«ãƒ¡ãƒ©ä¸­å¿ƒã‚’ã‚¹ãƒ†ãƒ¼ã‚¸ç¯„å›²ã§ã‚¯ãƒ©ãƒ³ãƒ—
    if (centerX < leftLimit_)  centerX = leftLimit_;
    if (centerX > rightLimit_) centerX = rightLimit_;

    // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«è¿½å¾“
    float t = followSpeed_ * deltaTime;
    if (t > 1.0f) t = 1.0f;

    Vector3 desired = cameraPosition_;
    desired.x = centerX;

    cameraPosition_ = Lerp(cameraPosition_, desired, t);
}

============================================================
File Path: Game/Camera/CameraController.h
============================================================
#pragma once
#include "engine/math/MyMath.h"
class CameraController
{

public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update(float deltaTime);




public:
	// ä½ç½®ã®ã‚»ãƒƒãƒˆ
	void SetTargetPosition(const Vector3& targetPosition) {
		
		// ç§»å‹•æ–¹å‘ã®åˆ¤å®š
		float dx = targetPosition.x - targetPosition_.x;
		// åˆ¤å®šç”¨ã®å¾®å°å€¤
		const float epsilon = 0.01f;
		// ç§»å‹•æ–¹å‘ã®è¨­å®š
		if (dx > epsilon) {
			moveDirection = 1; // å³ç§»å‹•
		} else if (dx < -epsilon)
		{
			moveDirection = -1; // å·¦ç§»å‹•
		}
		// ç¾åœ¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã‚’æ›´æ–°
		targetPosition_ = targetPosition;
	}
	void SetCameraPosition(const Vector3& cameraPosition) { cameraPosition_ = cameraPosition; }
	// ä½ç½®ã®å–å¾—
	const Vector3& GetTargetPosition() const { return targetPosition_; }
	const Vector3& GetCameraPosition() const { return cameraPosition_; }
	// ã‚«ãƒ¡ãƒ©ã®è¿½å¾“ç¯„å›²ã®è¨­å®š
	void SetFollowRange(float leftLimit, float rightLimit) { leftLimit_ = leftLimit; rightLimit_ = rightLimit; };

private:
	// å—ã‘å–ã‚‹å¯¾è±¡ã®ä½ç½®
	Vector3 targetPosition_;

	// å—ã‘å–ã‚‹ã‚«ãƒ¡ãƒ©ã®ä½ç½®
	Vector3 cameraPosition_;

	// ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³
	Vector2 deadZone_{ 2.0f, 1.0f };

	// è¿½å¾“é€Ÿåº¦
	float followSpeed_ = 60.0f;

	// ã‚«ãƒ¡ãƒ©ã®ç§»å‹•å¯èƒ½ç¯„å›²
	float leftLimit_ = 8.0f;
	float rightLimit_ = 92.0f;

	// ã©ã¡ã‚‰ã®æ–¹å‘ã«ç§»å‹•ã—ã¦ã„ã‚‹ã‹
	int32_t moveDirection = 0;
	// é€²è¡Œæ–¹å‘ã«å¯¾ã™ã‚‹ã‚«ãƒ¡ãƒ©ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆé‡
	float followOffsetX_ = 3.0f;
	// ç¾åœ¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆé‡
	float currentOffsetX_ = 0.0f;
	// ã‚ªãƒ•ã‚»ãƒƒãƒˆã®è£œé–“é€Ÿåº¦
	float offsetLerpSpeed_ = 2.0f;
};



============================================================
File Path: Game/Camera/StartCamPhase.cpp
============================================================
#include "StartCamPhase.h"
#include <cassert>

void StartCamPhase::Bind(Camera* camera, Transform* cameraTransform)
{
	// ã‚«ãƒ¡ãƒ©æƒ…å ±ã®ãƒã‚¤ãƒ³ãƒ‰
	camera_ = camera;
	cameraTransform_ = cameraTransform;
}

void StartCamPhase::Start()
{
	// ä¸­èº«ãŒã‚ã‚‹ã‹ã©ã†ã‹
	assert(camera_ != nullptr);

	// å›ºå®šåœ°ç‚¹ã®ä¿å­˜
	introFixedY_ = camTargetPos_.y;
	introFixedZ_ = camTargetPos_.z;

	// é–‹å§‹åœ°ç‚¹ä¿å­˜
	startPos_ = { camTargetPos_.x,introFixedY_,introFixedZ_ };

	// ã‚«ãƒ¡ãƒ©ã‚’åˆæœŸä½ç½®ã¸
	cameraTransform_->translate = startPos_;
	cameraTransform_->rotate = { 0.0f,0.0f,0.0f };
	// ã‚«ãƒ¡ãƒ©ã«åæ˜ 
	camera_->SetTranslate(cameraTransform_->translate);
	camera_->SetRotate(cameraTransform_->rotate);

	phase_ = Phase::MoveToLeft;
	timer_ = 0.0f;



}

void StartCamPhase::Skip()
{
	// å³åº§ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸
	introFixedY_ = camTargetPos_.y;
	introFixedZ_ = camTargetPos_.z;

	startPos_ = { camTargetPos_.x,introFixedY_,introFixedZ_ };
	cameraTransform_->translate = startPos_;
	camera_->SetTranslate(cameraTransform_->translate);

	phase_ = Phase::None;
	timer_ = 0.0f;
}


void StartCamPhase::Update(float dt)
{
	if (phase_ == Phase::None) {
		return;
	}

	const Vector3 leftPos = { introLeftX_,introFixedY_,introFixedZ_ };
	const Vector3 rightPos = { introRightX_,introFixedY_,introFixedZ_ };
	const Vector3 startPos = { camTargetPos_.x,introFixedY_,introFixedZ_ };

	switch (phase_)
	{
	case StartCamPhase::Phase::None:
		break;
	case StartCamPhase::Phase::MoveToLeft:
	{
		timer_ += dt;
		const float t = EaseOutCubic(timer_ / introMoveDur_);
		cameraTransform_->translate = Lerp(startPos_, Vector3{ introLeftX_,introFixedY_,introFixedZ_ }, t);
		if (timer_ >= introMoveDur_) {
			phase_ = Phase::PanToRight;
			timer_ = 0.0f;
			cameraTransform_->translate = leftPos;
		}
	}
	break;
	case StartCamPhase::Phase::PanToRight:
	{
		timer_ += dt;
		const float t = EaseOutCubic(timer_ / introPanDur_);
		cameraTransform_->translate = Lerp(leftPos, rightPos, t);
		if (timer_ >= introPanDur_) {
			phase_ = Phase::Hold;
			timer_ = 0.0f;
			cameraTransform_->translate = rightPos;
		}
	}
	break;
	case StartCamPhase::Phase::Hold: 
	{
		timer_ += dt;
		cameraTransform_->translate = rightPos;

		if (timer_ >= introHoldDur_) {
			phase_ = Phase::ReturnToStart;
			timer_ = 0.0f;
		}
	}
	break;
	case StartCamPhase::Phase::ReturnToStart: {

		timer_ += dt;

		float u = (introReturnDur_ > 0.0f) ? (timer_ / introReturnDur_) : 1.0f;
		u = std::clamp(u, 0.0f, 1.0f);

		float t = EaseOutBack(u);
		t = std::clamp(t, 0.0f, 1.0f);
		cameraTransform_->translate = Lerp(rightPos, startPos, t);

		if (timer_ >= introReturnDur_) {
			phase_ = Phase::None;
			timer_ = 0.0f;
			cameraTransform_->translate = startPos;
		}
	}
											break;
	default:

		break;
	}
	camera_->SetTranslate(cameraTransform_->translate);
}


bool StartCamPhase::IsRunning() const
{
	return phase_ != Phase::None;
}

void StartCamPhase::DrawImgui()
{
}


============================================================
File Path: Game/Camera/StartCamPhase.h
============================================================
#pragma once
#include "MyMath.h"
#include "Game/Camera/Camera.h"
#include <algorithm>
class Camera;
class StartCamPhase
{
public:
	// ã‚¹ã‚¿ãƒ¼ãƒˆæ¼”å‡º
	enum class Phase {
		None,
		MoveToLeft,   // å·¦ç«¯ã¸ç§»å‹•ï¼ˆåˆæœŸä½ç½®ã‹ã‚‰ï¼‰
		PanToRight,   // å·¦â†’å³ã¸ãƒ‘ãƒ³
		Hold,         // å°‘ã—æ­¢ã‚ã‚‹ï¼ˆä»»æ„ï¼‰
		ReturnToStart // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é–‹å§‹åœ°ç‚¹ã¸æˆ»ã‚‹
	};

public:
	void Bind(Camera* camera, Transform* cameraTransform);

	void Start();

	void Update(float dt);

	void Skip();

	bool IsRunning()const;

	Phase GetCurrentPhase() const { return phase_; }

	void DrawImgui();


private:
	static inline float EaseOutCubic(float t) {
		t = std::clamp(t, 0.0f, 1.0f);
		return 1.0f - std::pow(1.0f - t, 3.0f);
	}
	static inline float EaseOutBack(float t, float s = 1.70158f) {
		t = std::clamp(t, 0.0f, 1.0f);
		return 1.0f + (s + 1.0f) * std::pow(t - 1.0f, 3.0f) + s * std::pow(t - 1.0f, 2.0f);
	}
	static inline Vector3 Lerp(const Vector3& a, const Vector3& b, float t) {
		return { a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t };
	}
private:
	// 
	Camera* camera_ = nullptr;
	Transform* cameraTransform_;

	Phase phase_ = Phase::None;
	float timer_ = 0.0f;

	// é–‹å§‹åœ°ç‚¹
	Vector3 startPos_ = {};

	/// æ¨ªãƒ‘ãƒ³æ¼”å‡º
	// ç›®æ¨™ä½ç½®
	Vector3 camTargetPos_ = { 8.0f,3.5f,-20.0f };
	// å·¦ç«¯ã¸è¡Œãæ™‚é–“
	float introMoveDur_ = 0.6f;
	// å·¦ã‹ã‚‰å³ãƒ‘ãƒ³æ™‚é–“
	float introPanDur_ = 1.6f;
	// å³ç«¯ã§ã®åœæ­¢æ™‚é–“
	float introHoldDur_ = 1.0f;
	// é–‹å§‹åœ°ç‚¹ã¸æˆ»ã‚‹æ™‚é–“
	float introReturnDur_ = 3.0f;

	// å·¦ç«¯ã¨å³ç«¯
	float introLeftX_ = 8.0f;
	float introRightX_ = 92.0f;
	// èƒŒæ™¯ãŒå´©å£Šã—ãªã„é«˜ã•
	float introFixedY_ = 3.5f;
	// å›ºå®šZåº§æ¨™ / é€šå¸¸è·é›¢
	float introFixedZ_ = -20.0f;
};



============================================================
File Path: Game/Collision/Collider.cpp
============================================================
#include "Collider.h"


============================================================
File Path: Game/Collision/Collider.h
============================================================
#pragma once
#include "MyMath.h"
struct AABB
{
	Vector3 min;
	Vector3 max;
	
	bool Intersects(const AABB& other)const {
		return	
			(min.x <= other.max.x && max.x >= other.min.x) &&
			(min.y <= other.max.y && max.y >= other.min.y) &&
			(min.z <= other.max.z && max.z >= other.min.z);
	}
};

class Collider
{

public:
	enum class Type
	{
		Player,
		Enemy,
		Static,
	};

	virtual ~Collider() = default;

	virtual Type GetType() const = 0;
	virtual AABB GetAABB() const = 0;

	virtual void OnCollision(Collider* other) = 0;
};



============================================================
File Path: Game/Collision/CollisionManager.cpp
============================================================
#include "CollisionManager.h"

void CollisionManager::AddCollider(Collider* collider)
{
    /// ãƒªã‚¹ãƒˆã«ç™»éŒ²
	colliders.push_back(collider);
}

void CollisionManager::Clear()
{
    ///ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã™ã¹ã¦ã‚’å‰Šé™¤
	colliders.clear();
}

void CollisionManager::CheckAllCollisions()
{
	/// å…¨ã¦ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼åŒå£«ã®è¡çªåˆ¤å®š
    for (size_t i = 0; i < colliders.size(); ++i)
    {
        for (size_t j = i + 1; j < colliders.size(); ++j)
        {
            Collider* a = colliders[i];
            Collider* b = colliders[j];
			/// è¡çªåˆ¤å®š
            if (IsColliding(a, b))
			{
                /// è¡çªã—ã¦ã„ã‚‹å ´åˆã€é€šçŸ¥ã‚’è¡Œã†
                NotifyCollision(a, b);
            }
        }
    }
}

bool CollisionManager::IsColliding(Collider* a, Collider* b) {

    /// ï¼’ã¤ã®åˆ¤å®šã‚’å–ã‚‹
	return a->GetAABB().Intersects(b->GetAABB());

}

void CollisionManager::NotifyCollision(Collider* a, Collider* b) {
    /// è¡çªåˆ¤å®šãŒå–ã‚ŒãŸæ™‚é€šçŸ¥ã™ã‚‹
    a->OnCollision(b);
    b->OnCollision(a);
}

============================================================
File Path: Game/Collision/CollisionManager.h
============================================================
#pragma once
#include "engine/math/MyMath.h"
#include "Game/Collision/Collider.h"
/// <summary>
/// è¡çªåˆ¤å®šç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
class CollisionManager
{
public:
	/// <summary>
	/// åˆ¤å®šå¯¾è±¡è¿½åŠ 
	/// </summary>
	/// <param name="collider"></param>
	void AddCollider(Collider* collider);
	/// <summary>
	/// è¿½åŠ ã•ã‚ŒãŸã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å…¨ã¦å‰Šé™¤
	/// </summary>
	void Clear();
	/// <summary>
	/// å…¨ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼åŒå£«ã®è¡çªåˆ¤å®šã‚’è¡Œã†
	/// </summary>
	void CheckAllCollisions();

private:
	/// <summary>
	/// ï¼’ã¤ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¡çªåˆ¤å®š
	/// </summary>
	bool IsColliding(Collider* a, Collider* b);

	/// <summary>
	/// è¡çªãŒç™ºç”Ÿã—ãŸï¼’ã¤ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã«é€šçŸ¥ã‚’è¡Œã†
	/// </summary>
	void NotifyCollision(Collider* a, Collider* b);

private:
	/// <summary>
	/// åˆ¤å®šå¯¾è±¡ãƒªã‚¹ãƒˆ
	/// </summary>
	std::vector<Collider*>colliders;
	
	
};



============================================================
File Path: Game/Loader/LevelLoader.cpp
============================================================
#include "LevelLoader.h"
#ifdef USE_IMGUI
#include "ImguiManager.h"
#endif
void LevelLoader::Load(const std::string& fileName)
{
	const std::string kDefaultBaseDirectory = "resources/levels/stage/";
	const std::string kExtension = ".json";
	const std::string fullPath = kDefaultBaseDirectory + fileName + kExtension;
	const std::string objPath = ".obj";

	/// ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ 
	std::ifstream file;

	/// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	file.open(fullPath);
	/// ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³ã®æˆå¦
	if (file.fail()) {
		assert(0);
	}


	/// JSONæ–‡å­—åˆ—
	nlohmann::json deserialized;
	/// ãƒ‘ãƒ¼ã‚¹(è§£å‡)
	file >> deserialized;

	/// æ­£ã—ã„ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ç¢ºèª
	assert(deserialized.is_object());
	assert(deserialized.contains("name"));
	assert(deserialized["name"].is_string());

	/// "name"ã‚’æ–‡å­—åˆ—ã¨ã—ã¦å–å¾—
	std::string name = deserialized["name"].get<std::string>();

	/// æ­£ã—ã„ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«
	assert(name.compare("scene") == 0);

	/// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿æ ¼ç´ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	levelData = new LevelData();

	/// "Objects"ã®å…¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èµ°æŸ»
	for (nlohmann::json& object : deserialized["objects"]) {
		assert(object.contains("type"));

		/// ç¨®åˆ¥ã‚’å–å¾—
		std::string type = object["type"].get<std::string>();


		// MESH
		if (type.compare("MESH") == 0) {
			
			/// ç„¡åŠ¹ãƒ•ãƒ©ã‚°ãŒã‚ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
			if (object.contains("disabled_flag") && object["disabled_flag"].get<bool>()) {
				continue;
			}
			
			/// ObjectDataè¦ç´ è¿½åŠ 
			levelData->objects.emplace_back(LevelLoader::ObjectData{});
			/// è¿½åŠ ã—ãŸè¦ç´ ã®å‚ç…§ã‚’å¾—ã‚‹
			LevelLoader::ObjectData& objectData = levelData->objects.back();
			
			if (object.contains("file_name")) {
				objectData.fileName = object["file_name"];
			}
			else if (object.contains("name")) {
				objectData.fileName = object["name"];
			}
			/// ãƒ•ã‚¡ã‚¤ãƒ«åã«æ‹¡å¼µå­ã‚’è¿½åŠ 
			objectData.fileName += objPath;


			/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
			nlohmann::json& transform = object["transform"];
			// Translate
			objectData.transform.translate.x = (float)transform["translation"][0];
			objectData.transform.translate.y = (float)transform["translation"][2];
			objectData.transform.translate.z = (float)transform["translation"][1];
			// Rotate
			objectData.transform.rotate.x = (float)transform["rotation"][0];
			objectData.transform.rotate.y = (float)transform["rotation"][2];
			objectData.transform.rotate.z = (float)transform["rotation"][1];
			// Scale
			objectData.transform.scale.x = (float)transform["scaling"][0];
			objectData.transform.scale.y = (float)transform["scaling"][2];
			objectData.transform.scale.z = (float)transform["scaling"][1];


		}
		else if (type.compare("PlayerSpawn") == 0) {

			/// ç„¡åŠ¹ãƒ•ãƒ©ã‚°ãŒã‚ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
			if (object.contains("disabled_flag") && object["disabled_flag"].get<bool>()) {
				continue;
			}

			/// æ–°ã—ã„ PlayerSpawnData ã‚’è¿½åŠ 
			levelData->playerSpawn.emplace_back(LevelLoader::PlayerSpawnData{});
			LevelLoader::PlayerSpawnData& spawnData = levelData->playerSpawn.back();

			/// ãƒ•ã‚¡ã‚¤ãƒ«åã®èª­ã¿è¾¼ã¿
			if (object.contains("file_name")) {
				spawnData.fileName = object["file_name"];
			} else if (object.contains("name")) {
				spawnData.fileName = object["name"];
			}

			/// å¿…è¦ã«å¿œã˜ã¦æ‹¡å¼µå­ã‚’è¿½åŠ ï¼ˆä¾‹ãˆã° ".obj"ï¼‰
			spawnData.fileName += objPath;

			// Transform
			const auto& transform = object["transform"];
			// Translate
			spawnData.transform.translate.x = static_cast<float>(transform["translation"][0]);
			spawnData.transform.translate.y = static_cast<float>(transform["translation"][2]);
			spawnData.transform.translate.z = static_cast<float>(transform["translation"][1]);
			// Rotate
			spawnData.transform.rotate.x = static_cast<float>(transform["rotation"][0]);
			spawnData.transform.rotate.y = static_cast<float>(transform["rotation"][2]);
			spawnData.transform.rotate.z = static_cast<float>(transform["rotation"][1]);

			
		}





		/// @ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆèµ°æŸ»ã‚’å†å¸°é–¢æ•°ã«ã¾ã¨ã‚ã€å†å¸°å‘¼ã³å‡ºã—ã§æã‚’èµ°æŸ»ã™ã‚‹
		if (object.contains("Children")) {

		}
	}
}

void LevelLoader::CreateObject()
{
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆã€é…ç½®
	for (auto& objectData : levelData->objects) {
		// ãƒ¢ãƒ‡ãƒ«ã‚’æŒ‡å®šã—ã¦3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆ
		std::unique_ptr<Object3D> newObject = std::make_unique<Object3D>();
		newObject->Initialize();
		newObject->SetModel(objectData.fileName);
		newObject->SetTransform(objectData.transform);
		// ç™»éŒ²
		objects.push_back(std::move(newObject));
	}
}



void LevelLoader::Update()
{
	for (auto& object : objects) {
		if (object) {
#ifdef USE_IMGUI
			// ImGuiã§åº§æ¨™å¤‰æ›´UIã‚’è¡¨ç¤º
			ImGui::Begin("Object Transform");

			Vector3 pos = object->GetTranslate();
			if (ImGui::DragFloat3("Position", &pos.x, 0.1f)) {
				object->SetTranslate(pos);
			}

			Vector3 rot = object->GetRotate();
			if (ImGui::DragFloat3("Rotation", &rot.x, 0.1f)) {
				object->SetRotate(rot);
			}

			Vector3 scale = object->GetScale();
			if (ImGui::DragFloat3("Scale", &scale.x, 0.1f)) {
				object->SetScale(scale);
			}

			ImGui::End();
#endif
			object->Update();
		}
	}
}


void LevelLoader::Draw()
{
#ifdef _DEBUG

#endif

	/// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»
	for (auto& object : objects) {
		object->Draw();
	}
}


const std::vector<LevelLoader::PlayerSpawnData>& LevelLoader::getPlayerSpawns() const
{
	assert(levelData);
	return levelData->playerSpawn;
}

bool LevelLoader::HasPlayerSpawn() const
{
	assert(levelData);
	return !levelData->playerSpawn.empty();
}

============================================================
File Path: Game/Loader/LevelLoader.h
============================================================
#pragma once  
#include <string>  
#include <fstream>  
#include <cassert>  
#include "resources/json/json.hpp"  
#include "engine/math/MyMath.h"  
#include "engine/3d/Model.h"
#include "engine/3d/Object3D.h"
class LevelLoader  
{  
public:  
    struct ObjectData {  
        Transform transform; 
        std::string fileName;
    };  

    struct PlayerSpawnData {
		Transform transform;
		std::string fileName;
	};

    struct LevelData {  
        std::vector<ObjectData> objects; 
		std::vector<PlayerSpawnData> playerSpawn;
    }; 

    const std::vector<PlayerSpawnData>& getPlayerSpawns()const;
    bool HasPlayerSpawn()const;


public:  
    /// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€  
    void Load(const std::string& jsonFilePath);  

    ///
    void CreateObject();
    /// <summary>
	/// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update();
	/// <summary>
	///  æç”»å‡¦ç†
	/// </summary>
	void Draw();



private:
    LevelData* levelData;

    std::unordered_map<std::string, Model*> models;
	std::vector<std::unique_ptr<Object3D>> objects;

};


============================================================
File Path: Game/Particle/ModelParticleManager.cpp
============================================================
#include "ModelParticleManager.h"
#include <random>
#include "Object3D.h"

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®åˆæœŸåŒ–

ModelParticleManager& ModelParticleManager::GetInstance()
{
	static ModelParticleManager instance;
	return instance;
}


void ModelParticleManager::Initialize()
{
	// ç ´ç‰‡ç”¨ã®ãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã‚€ 
	modelName_ = "breakBlock.obj";

}

void ModelParticleManager::EmitBlockDebris(const Vector3& position, const Vector4& color, uint32_t count)
{
	std::random_device rnd;
	std::mt19937 randomEngine(rnd());
	std::uniform_real_distribution<float> distSpeed(1.0f, 3.0f);
	std::uniform_real_distribution<float> distAngle(0.0f, 2.0f * std::numbers::pi_v<float>);
	std::uniform_real_distribution<float> distRotation(-5.0f, 5.0f);

	for (uint32_t i = 0; i < count; ++i) {
		ModelParticle particle;

		particle.modelObject = std::make_unique<Object3D>();
		particle.modelObject->Initialize();
		particle.modelObject->SetModel(modelName_);


		float angle = distAngle(randomEngine);
		float speed = distSpeed(randomEngine);

		// æ”¾å°„çŠ¶ã«é£›ã³æ•£ã‚‹
		particle.velocity = {
			std::cos(angle) * speed,
			distSpeed(randomEngine),  // ä¸Šå‘ã
			std::sin(angle) * speed
		};

		// 3Då›è»¢é€Ÿåº¦ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰
		particle.angularVelocity = {
			distRotation(randomEngine),
			distRotation(randomEngine),
			distRotation(randomEngine)
		};

		Transform transform;
		transform.scale = { 0.2f, 0.2f, 0.2f };
		transform.rotate = { 0.0f, 0.0f, 0.0f };
		transform.translate = position;
		particle.modelObject->SetTransform(transform);

		particle.lifeTime = 3.0f;
		particle.currentTime = 0.0f;
		particle.gravity = -15.0f;

		particles_.push_back(std::move(particle));
	}
}

void ModelParticleManager::Update()
{
	const float kDeltaTime = 1.0f / 60.0f;

	for (auto it = particles_.begin(); it != particles_.end();) {
		if (it->currentTime >= it->lifeTime) {
			it = particles_.erase(it);
			continue;
		}

		Transform transform = it->modelObject->GetTransform();

		// ä½ç½®æ›´æ–°
		transform.translate += it->velocity * kDeltaTime;

		// é‡åŠ›ã‚’é©ç”¨
		it->velocity.y += it->gravity * kDeltaTime;

		// 3Då›è»¢ã‚’é©ç”¨
		transform.rotate.x += it->angularVelocity.x * kDeltaTime;
		transform.rotate.y += it->angularVelocity.y * kDeltaTime;
		transform.rotate.z += it->angularVelocity.z * kDeltaTime;

		it->modelObject->SetTransform(transform);

		it->modelObject->Update();

		it->currentTime += kDeltaTime;
		++it;
	}
}

void ModelParticleManager::Draw()
{
	// å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æç”»
	for (const auto& particle : particles_) {
		if (particle.modelObject) {
			particle.modelObject->Draw();
		}
	}
}


============================================================
File Path: Game/Particle/ModelParticleManager.h
============================================================
#pragma once
#include "MyMath.h"
#include <memory>
#include <vector>
#include "engine/3d/Object3D.h"


struct ModelParticle {
	std::unique_ptr<Object3D> modelObject; // ãƒ¢ãƒ‡ãƒ«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	Transform transform;		// å¤‰æ›æƒ…å ±
	Vector3 velocity;			// é€Ÿåº¦
	Vector4 color;				// è‰²
	Vector3 angularVelocity;	// è§’é€Ÿåº¦
	float lifeTime;				// å¯¿å‘½
	float currentTime;			// çµŒéæ™‚é–“
	float gravity;				// é‡åŠ›å½±éŸ¿åº¦
};

/// <summary>
/// ãƒ¢ãƒ‡ãƒ«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã‚¯ãƒ©ã‚¹
/// </summary>
class ModelParticleManager 
{
public:
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	static ModelParticleManager& GetInstance();



	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();



	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®ç ´ç‰‡ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç™ºç”Ÿã•ã›ã‚‹
	/// </summary>
	/// <param name="position">ç™ºç”Ÿä½ç½®</param>
	/// <param name="color">ç ´ç‰‡ã®è‰²</param>
	/// <param name="count">ä½•å€‹å‡ºã™ã‹</param>
	void EmitBlockDebris(const Vector3& position, const Vector4& color, uint32_t count = 10);

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

private:
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³
	static ModelParticleManager* instance;
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	ModelParticleManager() = default;
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~ModelParticleManager() = default;
	// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ç¦æ­¢
	ModelParticleManager(const ModelParticleManager&) = delete;
	// ä»£å…¥æ¼”ç®—å­ç¦æ­¢
	ModelParticleManager& operator=(const ModelParticleManager&) = delete;
private:
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒªã‚¹ãƒˆ
	std::vector<ModelParticle> particles_;

	// ãƒ¢ãƒ‡ãƒ«ã®åå‰
	std::string modelName_ = "breakBlock.obj";
};



============================================================
File Path: Game/Particle/ParticleManager.cpp
============================================================
#include "ParticleManager.h"
#include <Logger.h>
#include "MakeMatrix.h"
#include <TextureManager.h>
#include "WinAPI.h"
#include <numbers>

using namespace Engine;

ParticleManager* ParticleManager::instance = nullptr;
ParticleManager* ParticleManager::GetInstance()
{
	if (instance == nullptr)
	{
		instance = new ParticleManager();
	}
	return instance;

}

void ParticleManager::DeleteInstance()
{
	delete instance;
	instance = nullptr;
}

void ParticleManager::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, Camera* camera)
{
	// ãƒ¡ãƒ³ãƒå¤‰æ•°ã®åˆæœŸåŒ–
	this->dxCommon = dxCommon;
	this->srvManager = srvManager;
	// ã‚«ãƒ¡ãƒ©ã®å–å¾—
	this->camera = camera;

	// ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š
	blendMode = BlendMode::kBlendModeAdd;
	// ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆæœŸåŒ–
	InitializeRandomEngine();
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	CreatePipeline();
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–(åº§æ¨™ç­‰)
	InitializeVertexData();
	// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ–
	InitializeMaterial();

	// ãƒªãƒ³ã‚°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ–
	//CreateRingVertex();

	// ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	//CreateCylinderVertex();
}

void ParticleManager::InitializeRandomEngine()
{
	// ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆæœŸåŒ–
	std::random_device rnd;
	randomEngine = std::mt19937(rnd());
}

void ParticleManager::CreatePipeline()
{
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	CreateRootSignature();
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	SetGraphicsPipeline();
}

void ParticleManager::CreateRootSignature()
{
	D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
	descriptorRange[0].BaseShaderRegister = 0; // t0
	descriptorRange[0].NumDescriptors = 1; 
	descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRV
	descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—

	D3D12_DESCRIPTOR_RANGE descriptorRangeTexture[1] = {};
	descriptorRangeTexture[0].BaseShaderRegister = 1; // t1å§‹ã¾ã‚‹
	descriptorRangeTexture[0].NumDescriptors = 1; 
	descriptorRangeTexture[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRV
	descriptorRangeTexture[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—

	D3D12_ROOT_PARAMETER rootParameters[3] = {};


	// RootParameterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚
	// 0.Material
	rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters[0].Descriptor.ShaderRegister = 0;
	rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;

	// 1.TransformMatrix
	rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	rootParameters[1].DescriptorTable.pDescriptorRanges = descriptorRange;
	rootParameters[1].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange);
	rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
	// 2.Texture
	rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	rootParameters[2].DescriptorTable.pDescriptorRanges = descriptorRangeTexture;
	rootParameters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRangeTexture);
	rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;

	// Samplerã®è¨­å®š
	staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR; // ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿
	staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP; // 0~1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ
	staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER; // æ¯”è¼ƒã—ãªã„
	staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX; // ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†
	staticSamplers[0].ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†
	staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†

	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
	descriptionRootSignature.Flags =
		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;

	descriptionRootSignature.pParameters = rootParameters;
	descriptionRootSignature.NumParameters = _countof(rootParameters);

	descriptionRootSignature.pStaticSamplers = staticSamplers;
	descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

	// ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒã‚¤ãƒŠãƒªã«ã™ã‚‹
	Microsoft::WRL::ComPtr<ID3DBlob> signatureBlob = nullptr;
	Microsoft::WRL::ComPtr<ID3DBlob> errorBlob = nullptr;
	HRESULT hr = D3D12SerializeRootSignature(&descriptionRootSignature,
		D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(hr)) {
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	// ãƒã‚¤ãƒŠãƒªã‚’å…ƒã«ç”Ÿæˆ

	hr = dxCommon->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(),
		signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
	assert(SUCCEEDED(hr));



	// 2. InputLayoutã®è¨­å®š
	inputElementDescs[0].SemanticName = "POSITION";
	inputElementDescs[0].SemanticIndex = 0;
	inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs[1].SemanticName = "TEXCOORD";
	inputElementDescs[1].SemanticIndex = 0;
	inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs[2].SemanticName = "NORMAL";
	inputElementDescs[2].SemanticIndex = 0;
	inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputLayoutDesc.pInputElementDescs = inputElementDescs;
	inputLayoutDesc.NumElements = _countof(inputElementDescs);

	// 3. BlendDateã®è¨­å®š
	blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
	blendDesc.RenderTarget[0].BlendEnable = true;

	SetBlendMode(blendDesc, blendMode);
	currentBlendMode = BlendMode::kBlendModeAdd;  // ç¾åœ¨ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰
	// Î±å€¤ã®ãƒ–ãƒ¬ãƒ³ãƒ‰
	blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;
	blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;
	// RasterizerStateã®è¨­å®š
	// ã‚«ãƒªãƒ³ã‚°ãªã—
	rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
	// å¡—ã‚Šã¤ã¶ã—ãƒ¢ãƒ¼ãƒ‰
	rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;
	// 4. Shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	vertexShaderBlob = dxCommon->CompileShader(L"resources/shaders/Particle.VS.hlsl",
		L"vs_6_0");
	assert(vertexShaderBlob != nullptr);
	pixelShaderBlob = dxCommon->CompileShader(L"resources/shaders/Particle.PS.hlsl",
		L"ps_6_0");
	assert(pixelShaderBlob != nullptr);

	// DepthStencilStateã®è¨­å®š
	// Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
	depthStencilDesc.DepthEnable = true;
	//æ›¸ãè¾¼ã¿ã—ã¾ã™
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
	//æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
}




void ParticleManager::SetGraphicsPipeline()
{
	graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();
	graphicsPipelineStateDesc.InputLayout = inputLayoutDesc;
	graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),
										vertexShaderBlob->GetBufferSize() };
	graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),
										pixelShaderBlob->GetBufferSize() };
	graphicsPipelineStateDesc.BlendState = blendDesc;
	graphicsPipelineStateDesc.RasterizerState = rasterizerDesc;
	// Dehiscenceã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
	// æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	// åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸ï¼ˆå½¢çŠ¶ï¼‰ã®ã‚¿ã‚¤ãƒ—ã€‚ä¸‰è§’å½¢
	graphicsPipelineStateDesc.PrimitiveTopologyType =
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	// ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã®ã‹è¨­å®šï¼ˆæ°—ã«ã—ãªãã¦è‰¯ã„ï¼‰
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	// å®Ÿéš›ã«ç”Ÿæˆ
	HRESULT hr = dxCommon->GetDevice()->CreateGraphicsPipelineState(&graphicsPipelineStateDesc,
		IID_PPV_ARGS(&graphicsPipelineState));
	assert(SUCCEEDED(hr));
}


void ParticleManager::SetBlendMode(D3D12_BLEND_DESC& desc, BlendMode mode)
{
	switch (mode)
	{
	case kBlendModeAdd:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;
		break;
	case kBlendModeSubtract:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_REV_SUBTRACT;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;
		break;
	case kBlendModeMultiply:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_DEST_COLOR;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ZERO;
		break;
	case kBlendModeScreen:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_COLOR;
		break;
	default:
		assert(false);
		break;
	}
}



void ParticleManager::InitializeVertexData()
{

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, 0.0f, 1.0f},   .texcoord = {0.0f, 0.0f}, .normal = {0.0f, 0.0f, 1.0f} });
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, 0.0f, 1.0f},  .texcoord = {1.0f, 0.0f}, .normal = {0.0f, 0.0f, 1.0f} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, 0.0f, 1.0f},  .texcoord = {0.0f, 1.0f}, .normal = {0.0f, 0.0f, 1.0f} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, 0.0f, 1.0f},  .texcoord = {0.0f, 1.0f}, .normal = {0.0f, 0.0f, 1.0f} });
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, 0.0f, 1.0f},  .texcoord = {1.0f, 0.0f}, .normal = {0.0f, 0.0f, 1.0f} });
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, 0.0f, 1.0f}, .texcoord = {1.0f, 1.0f}, .normal = {0.0f, 0.0f, 1.0f} });

	// ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ
	CreateVertexBufferView();
}

void ParticleManager::CreateVertexBufferView()
{
	vertexResource = dxCommon->CreateBufferResource(sizeof(VertexData) * modelData.vertices.size());
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼
	vertexBufferView.BufferLocation = vertexResource->GetGPUVirtualAddress();
	// 1é ‚ç‚¹åˆ†ã®ã‚µã‚¤ã‚º
	vertexBufferView.StrideInBytes = sizeof(VertexData);
	// é ‚ç‚¹æ•°
	vertexBufferView.SizeInBytes = UINT(sizeof(VertexData) * modelData.vertices.size());
	// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿ / ãƒãƒƒãƒ—
	vertexResource->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));
	// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	memcpy(vertexData, modelData.vertices.data(), sizeof(VertexData) * modelData.vertices.size());

}

void ParticleManager::InitializeMaterial()
{
	// ãƒªã‚½ãƒ¼ã‚¹ç”Ÿæˆ
	materialResource = dxCommon->CreateBufferResource(sizeof(Material));

	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã«æ›¸ãè¾¼ã¿
	materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));

	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	materialData->color = Vector4(0.3f, 1.0f, 0.7f, 1.0f);
	materialData->enableLighting = true;
	materialData->uvTransform = MakeIdentity4x4();
}

void ParticleManager::CreateParticleGroup(const std::string& name, const std::string textureFilePath)
{

	// ç™»éŒ²æ¸ˆã¿ã®åå‰ã‹ç¢ºèª
	if (particleGroups.contains(name))
	{
		// ç™»éŒ²ã•ã‚Œã¦ã„ãŸã‚‰ãƒªã‚¿ãƒ¼ãƒ³
		Logger::Log("æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—åã§ã™");
		return;
	}
	// æ–°ãŸãªç©ºã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã—ã‚³ãƒ³ãƒ†ãƒŠã«ç™»éŒ²
	particleGroups[name] = ParticleGroup();
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	ParticleGroup& particleGroup = particleGroups[name];

	// æ–°ãŸãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
	particleGroup.materialData.textureFilePath = textureFilePath;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿
	TextureManager::GetInstance()->LoadTexture(particleGroup.materialData.textureFilePath);

	particleGroup.textureSrvIndex = TextureManager::GetInstance()->GetSrvIndex(particleGroup.materialData.textureFilePath);

	
	particleGroup.instancingResource = dxCommon->CreateBufferResource(sizeof(ParticleForGPU) * kMaxParticle);

	// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	particleGroup.instancingSrvIndex = srvManager->Allocate();
	// æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	particleGroup.instancingResource->Map(0, nullptr, reinterpret_cast<void**>(&particleGroup.instancingData));

	

	srvManager->CreateSRVforStructuredBuffer(
		particleGroup.instancingSrvIndex, 
		particleGroup.instancingResource.Get(), 
		kMaxParticle, 
		sizeof(ParticleForGPU));

	// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ã‚’åˆæœŸåŒ–
	particleGroup.kNumInstance = 0;
}

void ParticleManager::Update()
{
	uvOffset.x += uvScrollSpeed.x * kDeltaTime;
	uvOffset.y += uvScrollSpeed.y * kDeltaTime;

	// wrap (0ã€œ1ã®ç¯„å›²ã«ä¿ã¤)
	uvOffset.x = std::fmod(uvOffset.x, 1.0f);
	uvOffset.y = std::fmod(uvOffset.y, 1.0f);
	materialData->uvTransform = MakeTranslateMatrix({ uvOffset.x, uvOffset.y, 0.0f });

	// è¡Œåˆ—ã®æ›´æ–°
	UpdateMatrix();
	// å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®å‡¦ç†
	UpdateParticle();

}

void ParticleManager::UpdateMatrix()
{
	// ã‚«ãƒ¡ãƒ©è¡Œåˆ—ã®å–å¾—
	cameraMatrix = camera->GetWorldMatrix();
	// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®å–å¾—
	viewMatrix = camera->GetViewMatrix();
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®å–å¾—
	backToFrontMatrix = MakeRotateYMatrix(std::numbers::pi_v<float>);

	// ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰ç”¨ã®è¡Œåˆ—
	billboardMatrix = Multiply(backToFrontMatrix, cameraMatrix);
	billboardMatrix.m[3][0] = 0.0f;
	billboardMatrix.m[3][1] = 0.0f;
	billboardMatrix.m[3][2] = 0.0f;
}

void ParticleManager::UpdateParticle()
{
	// å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã«ã¤ã„ã¦å‡¦ç†
	for (auto& [name, particleGroup] : particleGroups)
	{
		particleGroup.kNumInstance = 0;
		// å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ›´æ–°
		for (auto particleIterator = particleGroup.particles.begin(); particleIterator != particleGroup.particles.end();)
		{
			// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ãŒä¸Šé™ã‚’è¶…ãˆã¦ã„ãªã„ãªã‚‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€
			if (particleGroup.kNumInstance < kMaxParticle)
			{
				// ç”Ÿå­˜æ™‚é–“ã‚’éãã¦ã„ãŸã‚‰æ›´æ–°ã›ãšæç”»å¯¾è±¡ã«ã—ãªã„
				if (particleIterator->lifeTime <= particleIterator->currentTime)
				{
					// æ¶ˆã™
					particleIterator = particleGroup.particles.erase(particleIterator);
					continue;
				}
				// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼‘å€‹ã”ã¨ã®æ›´æ–°
				particleIterator->transform.translate.x += particleIterator->velocity.x * kDeltaTime;
				particleIterator->transform.translate.y += particleIterator->velocity.y * kDeltaTime;
				particleIterator->transform.translate.z += particleIterator->velocity.z * kDeltaTime;
				particleIterator->currentTime += kDeltaTime;

				Matrix4x4 worldMatrixParticle = MakeAffineMatrix(particleIterator->transform.scale, particleIterator->transform.rotate, particleIterator->transform.translate);
				Matrix4x4 worldViewProjectionMatrix = Multiply(worldMatrixParticle, camera->GetViewProjectionMatrix());
				// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
				particleGroup.instancingData[particleGroup.kNumInstance].WVP = worldViewProjectionMatrix;
				particleGroup.instancingData[particleGroup.kNumInstance].World = worldMatrixParticle;
				particleGroup.instancingData[particleGroup.kNumInstance].color = particleIterator->color;
				particleGroup.instancingData[particleGroup.kNumInstance].color.w = 1.0f - (particleIterator->currentTime / particleIterator->lifeTime);

				++particleGroup.kNumInstance;
			}
			// æ¬¡ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«é€²ã‚ã‚‹
			++particleIterator;
		}
	}
}



void ParticleManager::Draw()
{
	
	// ã‚³ãƒãƒ³ãƒ‰ : ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¨­å®š
	dxCommon->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
	// ã‚³ãƒãƒ³ãƒ‰ : ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒ­ãƒã‚¸(æç”»å½¢çŠ¶)ã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	// ã‚³ãƒãƒ³ãƒ‰ : VertexBufferViewã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);

	// ã‚³ãƒãƒ³ãƒ‰ : ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’è¨­å®š
	dxCommon->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°
	dxCommon->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());

	// å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã«ã¤ã„ã¦å‡¦ç†
	for (auto& [name, particleGroup] : particleGroups)
	{ 
		if(particleGroup.kNumInstance == 0)
		{
			continue;
		}

		// è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°
		dxCommon->GetCommandList()->SetGraphicsRootDescriptorTable(
			1,
			srvManager->GetGPUDescriptorHandle(particleGroup.instancingSrvIndex));

		// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°
		//srvManager->SetGraphicsDescriptorTable(1, particleGroup.instancingSrvIndex);

		// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã®è¨­å®š
		dxCommon->GetCommandList()->SetGraphicsRootDescriptorTable(2, 
			srvManager->GetGPUDescriptorHandle(particleGroup.textureSrvIndex));
		
		// æç”»
		dxCommon->GetCommandList()->DrawInstanced(6, particleGroup.kNumInstance, 0, 0);
	}
}

void ParticleManager::DeleteParticleGroup(const std::string& name)
{
	auto it = particleGroups.find(name);
	if (it != particleGroups.end()) {
		// Unmapã§ãƒªãƒ¼ã‚¯ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
		if (it->second.instancingResource) {
			it->second.instancingResource->Unmap(0, nullptr);
			it->second.instancingData = nullptr; // ãƒã‚¤ãƒ³ã‚¿ã®ç„¡åŠ¹åŒ–
			it->second.instancingResource.Reset(); // ComPtrã®è§£æ”¾
		}

		// SRVã®è§£æ”¾ã‚‚ï¼ˆã‚‚ã—å¿…è¦ã§ã‚ã‚Œã°ï¼‰
		// srvManager->Release(it->second.srvIndex); // å¿…è¦ãªã‚‰

		// Mapã‹ã‚‰å‰Šé™¤
		particleGroups.erase(it);
	}
}


// Particleã¯Emitterã‚’ç”Ÿæˆã—ãªã„ã¨æç”»ã•ã‚Œãªã„ã®ã§ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã ã‘ã‚’å‘¼ã³å‡ºã—ã¦ã‚‚æç”»ã•ã‚Œãªã„
void ParticleManager::Emit(const std::string& name, const Vector3& position, uint32_t count)
{
	// ç™»éŒ²æ¸ˆã¿ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—åã‹ãƒã‚§ãƒƒã‚¯
	auto it = particleGroups.find(name);
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
	assert(it != particleGroups.end());
	// æŒ‡å®šã•ã‚ŒãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¿½åŠ 
	ParticleGroup& group = it->second;
	// å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆã—è¿½åŠ 
	for (uint32_t i = 0; i < count; ++i) {
		Particle newParticle = MakeParticle(randomEngine, position);
		group.particles.push_back(newParticle);
	}
}

void ParticleManager::EffectEmit(const std::string& name, const Vector3& position, uint32_t count)
{
	auto it = particleGroups.find(name);
	assert(it != particleGroups.end());
	ParticleGroup& group = it->second;

	for (uint32_t i = 0; i < count; ++i) {
		Particle newParticle;
		newParticle.transform.scale = { 0.1f, 0.1f, 0.1f };
		newParticle.transform.rotate = { 0.0f,0.0f,0.0f };
		newParticle.transform.translate = position;
		newParticle.velocity = { 0.0f, 0.0f, 0.0f };
		newParticle.color = { 1.0f, 1.0f, 1.0f, 1.0f };
		newParticle.lifeTime = 1.0f;
		newParticle.currentTime = 0.0f;
		newParticle = MakeCylinderEffect(position);
		group.particles.push_back(newParticle);
	}
}

Particle ParticleManager::MakeParticle(std::mt19937& randomEngine, const  Vector3& position)
{
	Particle particle;
	std::uniform_real_distribution<float> distPosition(-1.0f, 1.0f);
	std::uniform_real_distribution<float> distVelocity(-1.0f, 1.0f);
	std::uniform_real_distribution<float> distColor(0.0f, 1.0f);
	std::uniform_real_distribution<float> distTime(1.0f, 3.0f);

	particle.transform.scale = { 1.0f, 1.0f, 1.0f };
	particle.transform.rotate = { 0.0f, 3.3f, 0.0f };
	Vector3 randomPosition = { distPosition(randomEngine), distPosition(randomEngine),5.0f };
	particle.transform.translate = position + randomPosition;
	particle.velocity = { distVelocity(randomEngine), distVelocity(randomEngine), distVelocity(randomEngine) };
	particle.color = { distColor(randomEngine), distColor(randomEngine), distColor(randomEngine), 1.0f };
	particle.lifeTime = distTime(randomEngine);
	particle.currentTime = 0;

	return particle;
}

Particle ParticleManager::MakePrimitiveEffect(std::mt19937& randomEngine, const Vector3& translate)
{
	Particle particle;

	std::uniform_real_distribution<float>distRotate(-std::numbers::pi_v<float>, std::numbers::pi_v<float>);
	std::uniform_real_distribution<float>distScale(0.4f, 1.5f);

	particle.transform.scale = { 0.05f,distScale(randomEngine),1.0f };// æ¨ªã«ã¤ã¶ã™
	particle.transform.rotate = { 0.0f,0.0f,distRotate(randomEngine) };
	particle.transform.translate = Vector3(translate.x, translate.y, 15.0f);
	particle.velocity = { 0.0f,0.0f,0.0f };
	//white
	particle.color = { 1.0f,1.0f,1.0f,1.0f };
	particle.lifeTime = 10.0f;
	particle.currentTime = 0;
	return particle;


#pragma region ãƒœãƒ³ãƒ‰ãƒ«ãƒ‰
	//Particle particle;
	//particle.transform.scale = { 0.05f,1.0f,1.0f };// æ¨ªã«ã¤ã¶ã™
	//particle.transform.rotate = { 0.0f,0.0f,0.0f, };
	//particle.transform.translate = Vector3(translate.x, translate.y, 15.0f);
	//particle.velocity = { 0.0f,0.0f,0.0f };
	////purple
	//particle.color = { 102.0f, 51.0f, 153.0f, 1.0f };
	//particle.lifeTime = 10.0f;
	//particle.currentTime = 0;
	//return particle;
#pragma endregion
}

Particle ParticleManager::MakeExplosionParticle(std::mt19937& randomEngine, const Vector3& position)
{
	Particle particle;

	// ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’ç”Ÿæˆï¼ˆçƒé¢ä¸Šã®ãƒ©ãƒ³ãƒ€ãƒ ãªç‚¹ï¼‰
	std::uniform_real_distribution<float> distAngle(0.0f, 2.0f * std::numbers::pi_v<float>);
	std::uniform_real_distribution<float> distSpeed(2.0f, 5.0f);   // é€Ÿã„é€Ÿåº¦
	std::uniform_real_distribution<float> distColor(0.8f, 1.0f);   // æ˜ã‚‹ã„è‰²
	std::uniform_real_distribution<float> distLifetime(0.5f, 1.5f); // çŸ­å‘½

	// çƒé¢åº§æ¨™ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ãªæ–¹å‘ã‚’è¨ˆç®—
	float theta = distAngle(randomEngine);  // æ°´å¹³è§’åº¦
	float phi = distAngle(randomEngine);    // å‚ç›´è§’åº¦
	float speed = distSpeed(randomEngine);

	// æ”¾å°„çŠ¶ã®é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆä¸­å¿ƒã‹ã‚‰å¤–å´ã¸ï¼‰
	particle.velocity = {
		std::sin(phi) * std::cos(theta) * speed,  // Xæ–¹å‘
		std::sin(phi) * std::sin(theta) * speed,  // Yæ–¹å‘
		std::cos(phi) * speed                      // Zæ–¹å‘
	};

	particle.transform.scale = { 0.5f, 0.5f, 0.5f };
	particle.transform.rotate = { 0.0f, 0.0f, 0.0f };
	particle.transform.translate = position;

	// çˆ†ç™ºã‚‰ã—ã„è‰²ï¼ˆèµ¤ãƒ»ã‚ªãƒ¬ãƒ³ã‚¸ãƒ»é»„è‰²ï¼‰
	particle.color = {
		1.0f,                        // èµ¤ã¯æœ€å¤§
		distColor(randomEngine),     // ç·‘ã¯ãƒ©ãƒ³ãƒ€ãƒ 
		distColor(randomEngine) * 0.3f, // é’ã¯å°‘ãªã‚
		1.0f
	};

	particle.lifeTime = distLifetime(randomEngine);
	particle.currentTime = 0.0f;

	return particle;
}


Particle ParticleManager::MakeSmokeParticle(std::mt19937& randomEngine, const Vector3& position)
{
	Particle particle;

	std::uniform_real_distribution<float> distPosition(-0.3f, 0.3f);
	std::uniform_real_distribution<float> distUpSpeed(0.3f, 0.8f);    // ä¸Šæ˜‡é€Ÿåº¦
	std::uniform_real_distribution<float> distSideSpeed(-0.2f, 0.2f); // æ¨ªã®æºã‚Œ
	std::uniform_real_distribution<float> distLifetime(0.5f, 1.0f);   

	// ä¸»ã«ä¸Šæ–¹å‘ã«ç§»å‹•
	particle.velocity = {
		distSideSpeed(randomEngine),  // ã‚ãšã‹ã«æ¨ªã«ãšã‚Œã‚‹
		distUpSpeed(randomEngine),    // ä¸Šã«æ˜‡ã‚‹
		distSideSpeed(randomEngine)   // ã‚ãšã‹ã«æ¨ªã«ãšã‚Œã‚‹
	};

	particle.transform.scale = { 0.3f, 0.3f, 0.3f };  // å¤§ãã‚
	particle.transform.rotate = { 0.0f, 0.0f, 0.0f };
	particle.transform.translate = position + Vector3{
		distPosition(randomEngine),
		distPosition(randomEngine),
		0.0f
	};

	// ç…™ã‚‰ã—ã„è‰²ï¼ˆã‚°ãƒ¬ãƒ¼ï¼‰
	std::uniform_real_distribution<float> distGray(0.7f, 0.9f);
	float gray = distGray(randomEngine);
	particle.color = { gray, gray, gray, 1.0f };

	particle.lifeTime = distLifetime(randomEngine);
	particle.currentTime = 0.0f;

	return particle;
}



Particle ParticleManager::MakeSparkParticle(std::mt19937& randomEngine, const Vector3& position)
{
	Particle particle;
	// 
	std::uniform_real_distribution<float> distAngle(0.0f, 2.0f * std::numbers::pi_v<float>);
	// é€Ÿã‚
	std::uniform_real_distribution<float> distSpeed(3.0f, 8.0f);
	// å¯¿å‘½
	std::uniform_real_distribution<float> distLifetime(0.1f, 0.3f);
	// è§’åº¦
	std::uniform_real_distribution<float> distUpAngle(-0.5f, 0.5f);

	float angle = distAngle(randomEngine);
	float speed = distSpeed(randomEngine);
	float upAngle = distUpAngle(randomEngine);

	// ä¸»ã«æ¨ªæ–¹å‘ã«é£›ã³æ•£ã‚‹
	particle.velocity = {
		std::cos(angle) * speed,          // Xæ–¹å‘
		upAngle * speed * 0.3f,           // Yæ–¹å‘
		std::sin(angle) * speed * 0.2f    // Zæ–¹å‘
	};

	particle.transform.scale = { 0.4f, 0.4f, 0.4f };  // å°ã•ã„
	particle.transform.rotate = { 0.0f, 0.0f, angle };
	particle.transform.translate = position;

	// ã‚¹ãƒ‘ãƒ¼ã‚¯ã‚‰ã—ã„è‰²ï¼ˆæ˜ã‚‹ã„é»„è‰²ãƒ»ã‚ªãƒ¬ãƒ³ã‚¸ãƒ»ç™½)
	std::uniform_real_distribution<float> distColor(0.8f, 1.0f);
	particle.color = {
		1.0f,                        // èµ¤ã¯æœ€å¤§
		distColor(randomEngine),     // ç·‘ã¯ãƒ©ãƒ³ãƒ€ãƒ ï¼ˆé»„è‰²ã£ã½ãï¼‰
		distColor(randomEngine) * 0.2f, // é’ã¯å°‘ãªã‚
		1.0f
	};

	particle.lifeTime = distLifetime(randomEngine);
	particle.currentTime = 0.0f;

	return particle;
}

Particle ParticleManager::MakeMagicCircleParticle(
	std::mt19937& randomEngine,
	const Vector3& position,
	float angle,      // å††å‘¨ä¸Šã®è§’åº¦
	float radius)     // åŠå¾„
{
	Particle particle;

	std::uniform_real_distribution<float> distHeight(-0.1f, 0.1f);
	std::uniform_real_distribution<float> distColor(0.7f, 1.0f);

	// å††å‘¨ä¸Šã®ä½ç½®ã‚’è¨ˆç®—
	float x = std::cos(angle) * radius;
	float z = std::sin(angle) * radius;

	particle.transform.scale = { 0.3f, 0.3f, 0.3f };
	particle.transform.rotate = { 0.0f, 0.0f, 0.0f };

	// åœ°é¢ã«å¹³è¡Œã«é…ç½®ï¼ˆYè»¸ã¯ã»ã¼å›ºå®šï¼‰
	particle.transform.translate = {
		position.x + x,
		position.y + distHeight(randomEngine),  // å°‘ã—ã ã‘é«˜ã•ã«ã°ã‚‰ã¤ã
		position.z + z
	};

	// ã‚†ã£ãã‚Šå›è»¢ï¼ˆå††å‘¨ã«æ²¿ã£ã¦ç§»å‹•ï¼‰
	float rotationSpeed = 0.5f;  // å›è»¢é€Ÿåº¦
	particle.velocity = {
		-std::sin(angle) * rotationSpeed,  // å††å‘¨æ–¹å‘ã®é€Ÿåº¦
		0.0f,                              // Yè»¸æ–¹å‘ã«ã¯å‹•ã‹ãªã„
		std::cos(angle) * rotationSpeed
	};

	// é­”æ³•é™£ã‚‰ã—ã„è‰²ï¼ˆé’ãƒ»ç´«ãƒ»ã‚·ã‚¢ãƒ³ï¼‰
	particle.color = {
		distColor(randomEngine) * 0.3f,  // èµ¤ã¯å°‘ãªã‚
		distColor(randomEngine) * 0.5f,  // ç·‘ã‚‚å°‘ãªã‚
		distColor(randomEngine),         // é’ã¯å¼·ã‚
		1.0f
	};

	particle.lifeTime = 5.0f;  // é•·ãè¡¨ç¤º
	particle.currentTime = 0.0f;

	return particle;
}

void ParticleManager::CreateRingVertex()
{
	std::vector<VertexData> vertices;
	const uint32_t kRingDivide = 32;
	const float kOuterRadius = 1.0f;
	const float kInnerRadius = 0.2f;
	const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kRingDivide);

	for (uint32_t i = 0; i < kRingDivide; ++i) {
		float angle0 = i * radianPerDivide;
		float angle1 = (i + 1) * radianPerDivide;

		float sin0 = std::sin(angle0);
		float cos0 = std::cos(angle0);
		float sin1 = std::sin(angle1);
		float cos1 = std::cos(angle1);

		// å¤–å´ãƒ»å†…å´ã®å„ç‚¹
		Vector4 outer0 = { sin0 * kOuterRadius, cos0 * kOuterRadius, 0.0f, 1.0f };
		Vector4 outer1 = { sin1 * kOuterRadius, cos1 * kOuterRadius, 0.0f, 1.0f };
		Vector4 inner0 = { sin0 * kInnerRadius, cos0 * kInnerRadius, 0.0f, 1.0f };
		Vector4 inner1 = { sin1 * kInnerRadius, cos1 * kInnerRadius, 0.0f, 1.0f };

		Vector2 uvOuter0 = { float(i) / kRingDivide, 0.0f };
		Vector2 uvOuter1 = { float(i + 1) / kRingDivide, 0.0f };
		Vector2 uvInner0 = { float(i) / kRingDivide, 1.0f };
		Vector2 uvInner1 = { float(i + 1) / kRingDivide, 1.0f };

		Vector3 normal = { 0.0f, 0.0f, 1.0f };

		// ä¸‰è§’å½¢ 1ï¼ˆouter0, outer1, inner0ï¼‰
		vertices.push_back({ outer0, uvOuter0, normal });
		vertices.push_back({ outer1, uvOuter1, normal });
		vertices.push_back({ inner0, uvInner0, normal });

		// ä¸‰è§’å½¢ 2ï¼ˆinner0, outer1, inner1ï¼‰
		vertices.push_back({ inner0, uvInner0, normal });
		vertices.push_back({ outer1, uvOuter1, normal });
		vertices.push_back({ inner1, uvInner1, normal });
	}

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®ä½œæˆ
	size_t vertexSize = sizeof(VertexData) * vertices.size();

	Microsoft::WRL::ComPtr<ID3D12Resource> vertexBuffer;
	D3D12_HEAP_PROPERTIES heapProp{};
	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;

	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Width = vertexSize;
	resourceDesc.Height = 1;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.SampleDesc.Count = 1;
	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	dxCommon->GetDevice()->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertexBuffer));

	VertexData* mapData = nullptr;
	vertexBuffer->Map(0, nullptr, reinterpret_cast<void**>(&mapData));
	memcpy(mapData, vertices.data(), vertexSize);
	vertexBuffer->Unmap(0, nullptr);

	D3D12_VERTEX_BUFFER_VIEW vbView{};
	vbView.BufferLocation = vertexBuffer->GetGPUVirtualAddress();
	vbView.SizeInBytes = static_cast<UINT>(vertexSize);
	vbView.StrideInBytes = sizeof(VertexData);

	ringVertexBuffer = vertexBuffer;
	ringVertexBufferView = vbView;
	ringVertexCount = static_cast<uint32_t>(vertices.size());
}

void ParticleManager::DrawRing()
{
	if (!ringVertexBuffer) return;

	auto* cmdList = dxCommon->GetCommandList();

	// å¿…è¦ãªãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootSignature(rootSignature.Get());
	cmdList->SetPipelineState(graphicsPipelineState.Get());
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	cmdList->IASetVertexBuffers(0, 1, &ringVertexBufferView);
	cmdList->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£SRVï¼ˆä»®ã«index=0ã¨ã™ã‚‹ï¼‰
	D3D12_GPU_DESCRIPTOR_HANDLE textureHandle = srvManager->GetGPUDescriptorHandle(0);
	cmdList->SetGraphicsRootDescriptorTable(2, textureHandle);

	cmdList->DrawInstanced(ringVertexCount, 1, 0, 0);

}

Particle ParticleManager::MakeRingEffect(const Vector3& position) {
	Particle particle;
	particle.transform.scale = { 1.0f, 1.0f, 1.0f };     // ã‚µã‚¤ã‚ºï¼ˆå¤§ãã™ãã‚‹ã¨ç”»é¢å¤–ï¼‰
	particle.transform.rotate = { 0.0f, 0.0f, 0.0f };
	particle.transform.translate = { 0.0f, 0.0f, 5.0f }; // Z = 5.0f ã§æ‰‹å‰ã«è¡¨ç¤ºã•ã‚Œã‚„ã™ã„
	particle.velocity = { 0.0f, 0.0f, 0.0f };
	particle.color = { 1.0f, 1.0f, 1.0f, 1.0f };
	particle.lifeTime = 1.0f;
	particle.currentTime = 0.0f;
	return particle;
}

Particle ParticleManager::MakeCylinderEffect(const Vector3& position)
{
	Particle particle;
	particle.transform.scale = { 1.0f, 1.0f, 1.0f };     // ã‚µã‚¤ã‚ºï¼ˆå¤§ãã™ãã‚‹ã¨ç”»é¢å¤–ï¼‰
	particle.transform.rotate = { 0.0f, 0.0f, 0.0f };
	particle.transform.translate = position;
	particle.velocity = { 0.0f, 0.0f, 0.0f };
	particle.color = { 1.0f, 1.0f, 1.0f, 1.0f };
	particle.lifeTime = 1.0f;
	particle.currentTime = 0.0f;
	return particle;
}

void ParticleManager::CreateCylinderVertex() {
	std::vector<VertexData> vertices;
	const uint32_t kCylinderDivide = 32;
	const float kTopRadius = 1.0f;
	const float kBottomRadius = 1.0f;
	const float kHeight = 3.0f;
	const float halfHeight = kHeight * 0.5f;
	const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kCylinderDivide);

	for (uint32_t i = 0; i < kCylinderDivide; ++i) {
		float angle0 = i * radianPerDivide;
		float angle1 = (i + 1) * radianPerDivide;

		float sin0 = std::sin(angle0);
		float cos0 = std::cos(angle0);
		float sin1 = std::sin(angle1);
		float cos1 = std::cos(angle1);

		float u0 = float(i) / float(kCylinderDivide);
		float u1 = float(i + 1) / float(kCylinderDivide);

		// å„é ‚ç‚¹ã®ä½ç½®
		Vector4 top0 = { sin0 * kTopRadius, +halfHeight, cos0 * kTopRadius, 1.0f };
		Vector4 top1 = { sin1 * kTopRadius, +halfHeight, cos1 * kTopRadius, 1.0f };
		Vector4 bottom0 = { sin0 * kBottomRadius, -halfHeight, cos0 * kBottomRadius, 1.0f };
		Vector4 bottom1 = { sin1 * kBottomRadius, -halfHeight, cos1 * kBottomRadius, 1.0f };

		// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™
		Vector2 uvTop0 = { u0, 0.0f };
		Vector2 uvTop1 = { u1, 0.0f };
		Vector2 uvBottom0 = { u0, 1.0f };
		Vector2 uvBottom1 = { u1, 1.0f };

		// æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«ï¼ˆæ­£è¦åŒ–ï¼‰
		Vector3 normal0 = Vector3{ sin0, 0.0f, cos0 }.Normalized();
		Vector3 normal1 = Vector3{ sin1, 0.0f, cos1 }.Normalized();

		// å´é¢ï¼šä¸‰è§’å½¢2æšï¼ˆ1ã‚¯ã‚¢ãƒƒãƒ‰ï¼‰
		vertices.push_back({ top0,    uvTop0,    normal0 });
		vertices.push_back({ top1,    uvTop1,    normal1 });
		vertices.push_back({ bottom0, uvBottom0, normal0 });

		vertices.push_back({ top1,    uvTop1,    normal1 });
		vertices.push_back({ bottom1, uvBottom1, normal1 });
		vertices.push_back({ bottom0, uvBottom0, normal0 });
	}

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ä½œæˆ
	size_t vertexSize = sizeof(VertexData) * vertices.size();

	Microsoft::WRL::ComPtr<ID3D12Resource> vertexBuffer;
	D3D12_HEAP_PROPERTIES heapProp{};
	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;

	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Width = vertexSize;
	resourceDesc.Height = 1;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.SampleDesc.Count = 1;
	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	HRESULT hr = dxCommon->GetDevice()->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertexBuffer));
	assert(SUCCEEDED(hr));

	VertexData* mapData = nullptr;
	vertexBuffer->Map(0, nullptr, reinterpret_cast<void**>(&mapData));
	memcpy(mapData, vertices.data(), vertexSize);
	vertexBuffer->Unmap(0, nullptr);

	D3D12_VERTEX_BUFFER_VIEW vbView{};
	vbView.BufferLocation = vertexBuffer->GetGPUVirtualAddress();
	vbView.SizeInBytes = static_cast<UINT>(vertexSize);
	vbView.StrideInBytes = sizeof(VertexData);

	ringVertexBuffer = vertexBuffer;
	ringVertexBufferView = vbView;
	ringVertexCount = static_cast<uint32_t>(vertices.size());
}



void ParticleManager::DrawCylinder()
{
	if (!ringVertexBuffer) return;

	auto* cmdList = dxCommon->GetCommandList();

	// å¿…è¦ãªãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootSignature(rootSignature.Get());
	cmdList->SetPipelineState(graphicsPipelineState.Get());
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	cmdList->IASetVertexBuffers(0, 1, &ringVertexBufferView);
	cmdList->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£SRVï¼ˆä»®ã«index=0ã¨ã™ã‚‹ï¼‰
	D3D12_GPU_DESCRIPTOR_HANDLE textureHandle = srvManager->GetGPUDescriptorHandle(0);
	cmdList->SetGraphicsRootDescriptorTable(2, textureHandle);

	cmdList->DrawInstanced(ringVertexCount, 1, 0, 0);


}

void ParticleManager::EnsureParticleGroup(const std::string& name, const std::string& textureFilePath)
{
	if (!HasParticleGroup(name))
	{
		CreateParticleGroup(name, textureFilePath);
	}
}

Particle ParticleManager::MakeParticleByType(std::mt19937& randomEngine, const Vector3& position, EffectType type)
{
	switch (type)
	{
		case EffectType::Explosion:
			return MakeExplosionParticle(randomEngine, position);
		case EffectType::Smoke:
			return MakeSmokeParticle(randomEngine, position);
		case EffectType::Spark:
			return MakeSparkParticle(randomEngine, position);
		case EffectType::Default:
			default:
				return MakeParticle(randomEngine, position);
	}
}

Particle ParticleManager::MakeParticleByTypeWithColor(
	std::mt19937& randomEngine,
	const Vector3& position,
	EffectType type,
	const Vector4& colorTint)
{
	Particle particle;

	switch (type)
	{
	case EffectType::Explosion:
		particle = MakeExplosionParticle(randomEngine, position);
		break;
	case EffectType::Smoke:
		particle = MakeSmokeParticle(randomEngine, position);
		break;
	case EffectType::Spark:
		particle = MakeSparkParticle(randomEngine, position);
		break;
	case EffectType::Default:
	default:
		particle = MakeParticle(randomEngine, position);
		break;
	}

	// è‰²ã‚’ä¹—ç®—ã§é©ç”¨
	particle.color.x *= colorTint.x;
	particle.color.y *= colorTint.y;
	particle.color.z *= colorTint.z;
	particle.color.w *= colorTint.w;

	return particle;
}

void ParticleManager::EmitWithEffectType(const std::string& name, const Vector3& position, uint32_t count, EffectType effectType)
{
	auto it = particleGroups.find(name);
	assert(it != particleGroups.end());

	ParticleGroup& group = it->second;
	for (uint32_t i = 0; i < count; ++i) {
		Particle newParticle = MakeParticleByType(randomEngine, position, effectType);
		group.particles.push_back(newParticle);
	}
}

void ParticleManager::EmitMagicCircle(const std::string& name, const Vector3& position, uint32_t count, float radius)
{
	auto it = particleGroups.find(name);
	assert(it != particleGroups.end());

	ParticleGroup& group = it->second;

	// å††å‘¨ã‚’å‡ç­‰ã«åˆ†å‰²
	float angleStep = (2.0f * std::numbers::pi_v<float>) / count;

	for (uint32_t i = 0; i < count; ++i) {
		float angle = angleStep * i;
		Particle newParticle = MakeMagicCircleParticle(randomEngine, position, angle, radius);
		group.particles.push_back(newParticle);
	}
}


void ParticleManager::EmitComplexMagicCircle(
	const std::string& name,
	const Vector3& position)
{
	// å†…å´ã®å††ï¼ˆå°ã•ã„ã€é€Ÿãå›è»¢ï¼‰
	EmitMagicCircle(name, position, 20, 2.0f);

	// ä¸­é–“ã®å††ï¼ˆä¸­ãã‚‰ã„ã€ä¸­é€Ÿå›è»¢ï¼‰
	EmitMagicCircle(name, position, 30, 4.0f);

	// å¤–å´ã®å††ï¼ˆå¤§ãã„ã€ã‚†ã£ãã‚Šå›è»¢ï¼‰
	EmitMagicCircle(name, position, 40, 6.0f);

	// ä¸­å¿ƒã«å…‰ã‚‹ç‚¹
	Particle centerParticle;
	centerParticle.transform.scale = { 1.0f, 1.0f, 1.0f };
	centerParticle.transform.translate = position;
	centerParticle.velocity = { 0.0f, 0.0f, 0.0f };
	centerParticle.color = { 0.5f, 0.7f, 1.0f, 1.0f };
	centerParticle.lifeTime = 5.0f;
	centerParticle.currentTime = 0.0f;

	auto it = particleGroups.find(name);
	if (it != particleGroups.end()) {
		it->second.particles.push_back(centerParticle);
	}
}

void ParticleManager::EmitWithEffectTypeAndColor(
	const std::string& name,
	const Vector3& position,
	uint32_t count,
	EffectType effectType,
	const Vector4& colorTint)
{
	auto it = particleGroups.find(name);
	assert(it != particleGroups.end());

	ParticleGroup& group = it->second;
	for (uint32_t i = 0; i < count; ++i) {
		Particle newParticle = MakeParticleByTypeWithColor(randomEngine, position, effectType, colorTint);
		group.particles.push_back(newParticle);
	}
}


============================================================
File Path: Game/Particle/ParticleManager.h
============================================================
#pragma once
#include "DirectXCommon.h"
#include "SrvManager.h"
#include "MyMath.h"
#include <random>
#include "Game/Camera/Camera.h"


/// <summary>
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
/// </summary>
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹

class ParticleManager
{
public:

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ§‹é€ ä½“
	struct ParticleGroup {		// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ— // ä½¿ç”¨ã™ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ã”ã¨ã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã¨ã—ã¦ã¾ã¨ã‚ã‚‹
		MaterialData materialData;			// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿					
		std::list<Particle> particles;		// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒªã‚¹ãƒˆ		
		uint32_t instancingSrvIndex;					// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ç”¨ã®SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹	
		Microsoft::WRL::ComPtr<ID3D12Resource> instancingResource;	// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹
		UINT kNumInstance;					// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°
		ParticleForGPU* instancingData;		// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ãƒã‚¤ãƒ³ã‚¿
		uint32_t textureSrvIndex;               // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	};

	// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—åˆ—æŒ™å‹
	enum class EffectType {
		Default,		// é€šå¸¸ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
		Explosion,		// çˆ†ç™º
		Smoke,			// ç…™
		Spark,			// ç«èŠ±
		MagicCircle,	// é­”æ³•é™£
	};

	/// <summary>
	/// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å–å¾—
	/// </summary>
	static ParticleManager* GetInstance();
	/// <summary>
	/// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å‰Šé™¤
	/// </summary>
	static void DeleteInstance();
private:
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³
	static ParticleManager* instance;
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ã‚³ãƒ”ãƒ¼ç¦æ­¢
	ParticleManager() = default;
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~ParticleManager() = default;
	// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ä»£å…¥æ¼”ç®—å­ã‚’å‰Šé™¤
	ParticleManager(ParticleManager&) = delete;
	// ä»£å…¥æ¼”ç®—å­
	ParticleManager& operator=(ParticleManager&) = delete;


	// åˆæœŸåŒ–å†…éƒ¨å‡¦ç†
	/// <summary>
	/// ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆæœŸåŒ–
	/// </summary>
	void InitializeRandomEngine();
	/// <summary>
	/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	/// </summary>
	void CreatePipeline();
	/// <summary>
	/// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–(åº§æ¨™ç­‰)
	/// </summary>
	void InitializeVertexData();
	/// <summary>
	/// ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ
	/// </summary>
	void CreateVertexBufferView();
	/// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ–
	/// </summary>
	void InitializeMaterial();

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆå†…éƒ¨
	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	/// </summary>
	void CreateRootSignature();
	/// <summary>
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	/// </summary>
	void SetGraphicsPipeline();
	/// <summary>
	/// ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š
	/// </summary>
	/// <param name="desc"></param>
	/// <param name="mode"></param>
	void SetBlendMode(D3D12_BLEND_DESC& desc, BlendMode mode);


	/// <summary>
	/// ã‚¿ã‚¤ãƒ—åˆ¥ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
	/// </summary>
	/// <param name="randomEngine"></param>
	/// <param name="position"></param>
	/// <param name="type"></param>
	/// <returns></returns>
	Particle MakeParticleByType(std::mt19937& randomEngine, const Vector3& position, EffectType type);

	/// <summary>
	/// ã‚¿ã‚¤ãƒ—åˆ¥ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆï¼ˆè‰²æŒ‡å®šç‰ˆï¼‰ï¼ˆè¿½åŠ ï¼‰
	/// </summary>
	Particle MakeParticleByTypeWithColor(std::mt19937& randomEngine,const Vector3& position,EffectType type,const Vector4& colorTint);


public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon"></param>
	/// <param name="srvManager"></param>
	/// <param name="camera"></param>
	void Initialize(Engine::DirectXCommon* dxCommon, SrvManager* srvManager, Camera* camera);


	/// <summary>
	///  ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆ
	/// </summary>
	/// <param name="name"></param>
	/// <param name="textureFilePath"></param>
	void CreateParticleGroup(const std::string& name, const std::string textureFilePath);


	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	// æ›´æ–°å†…éƒ¨å‡¦ç†
	/// <summary>
	/// è¡Œåˆ—æ›´æ–°
	/// </summary>
	void UpdateMatrix();
	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
	/// </summary>
	void UpdateParticle();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®å‰Šé™¤
	/// </summary>
	/// <param name="name"></param>
	void DeleteParticleGroup(const std::string& name);

	/// <summary>
	/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç™ºç”Ÿ
	/// </summary>
	/// <param name="name"></param>
	/// <param name="position"></param>
	/// <param name="count"></param>
	void Emit(const std::string& name, const Vector3& position, uint32_t count);
	/// <summary>
	/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç™ºç”Ÿ(ç‰¹æ®Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ)
	/// </summary>
	/// <param name="name"></param>
	/// <param name="position"></param>
	/// <param name="count"></param>
	void EffectEmit(const std::string& name, const Vector3& position, uint32_t count);


	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«(é€šå¸¸)ç”Ÿæˆ
	/// </summary>
	Particle MakeParticle(std::mt19937& randomEngine, const Vector3& position);

	/// <summary>
	/// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”Ÿæˆ
	/// </summary>
	Particle MakePrimitiveEffect(std::mt19937& randomEngine, const Vector3& translate);

	/// <summary>
	/// çˆ†ç™ºãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
	/// </summary>
	/// <param name="randomEngine">ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³</param>
	/// <param name="position">ç™ºç”Ÿä½ç½®</param>
	/// <returns>ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¿”ã™</returns>
	Particle MakeExplosionParticle(std::mt19937& randomEngine, const Vector3& position);

	/// <summary>
	/// ç…™ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
	/// </summary>
	/// <param name="randomEngine">ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³</param>
	/// <param name="position">ç™ºç”Ÿä½ç½®</param>
	/// <returns>ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¿”ã™</returns>
	Particle MakeSmokeParticle(std::mt19937& randomEngine, const Vector3& position);
	
	/// <summary>
	/// ç«èŠ±ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
	/// </summary>
	/// <param name="randomEngine">ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³</param>
	/// <param name="position">ç™ºç”Ÿä½ç½®</param>
	/// <returns>ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¿”ã™</returns>
	Particle MakeSparkParticle(std::mt19937& randomEngine, const Vector3& position);

	/// <summary>
	/// é­”æ³•é™£ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç”Ÿæˆ
	/// </summary>
	/// <param name="randomEngine">ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³</param>
	/// <param name="position">ç™ºç”Ÿä½ç½®</param>
	/// <param name="angle">è§’åº¦</param>
	/// <param name="radius">åŠå¾„</param>
	/// <returns>ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¿”ã™</returns>
	Particle MakeMagicCircleParticle(std::mt19937& randomEngine,const Vector3& position,float angle,float radius);


	/// <summary>
	/// Ringã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	/// </summary>
	/// <param name="position"></param>
	/// <returns></returns>
	Particle MakeRingEffect(const Vector3& position);
	/// <summary>
	/// Cylinderã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	/// </summary>
	/// <param name="position"></param>
	/// <returns></returns>
	Particle MakeCylinderEffect(const Vector3& position);

	

	/// <summary>
	/// Ring
	/// </summary>
	void CreateRingVertex();
	/// <summary>
	/// RingEffectã®æç”»
	/// </summary>
	void DrawRing();

	/// <summary>
	/// Cylinder
	/// </summary>
	void CreateCylinderVertex();
	/// <summary>
	/// CylinderEffectã®æç”»
	/// </summary>
	void DrawCylinder();

	/// <summary>
	/// ImGuiæç”»
	/// </summary>
	void DrawImgui();

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚»ãƒƒãƒˆã™ã‚‹
	/// </summary>
	/// <param name="cameraPtr_"></param>
	void SetCamera(Camera* cameraPtr_) { camera = cameraPtr_; }

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ãŒå­˜åœ¨ã™ã‚‹ã‹
	/// </summary>
	/// <param name="name">å­˜åœ¨ã‚’ç¢ºèªã™ã‚‹ã‚°ãƒ«ãƒ¼ãƒ—ã®åå‰</param>
	/// <returns>å­˜åœ¨ã™ã‚Œã°true / å­˜åœ¨ã—ãªã‘ã‚Œã°false</returns>
	bool HasParticleGroup(const std::string& name) const { return particleGroups.contains(name); }

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ãŒå­˜åœ¨ã—ãªã‘ã‚Œã°ä½œæˆã™ã‚‹
	/// </summary>
	/// <param name="name"></param>
	/// <param name="textureFilePath"></param>
	void EnsureParticleGroup(const std::string& name, const std::string& textureFilePath);
	
	/// <summary>
	/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç™ºç”Ÿ(ç‰¹æ®Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ)
	/// </summary>
	/// <param name="name"></param>
	/// <param name="position"></param>
	/// <param name="count"></param>
	/// <param name="effectType"></param>
	void EmitWithEffectType(const std::string& name, const Vector3& position, uint32_t count, EffectType effectType);

	/// <summary>
	/// é­”æ³•é™£ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç™ºç”Ÿ
	/// </summary>
	/// <param name="name"></param>
	/// <param name="position"></param>
	/// <param name="radius"></param>
	void EmitMagicCircle(const std::string& name, const Vector3& position,uint32_t count, float radius);

	/// <summary>
	/// è¤‡é›‘ãªé­”æ³•é™£ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç™ºç”Ÿ
	/// </summary>
	/// <param name="name"></param>
	/// <param name="position"></param>
	void EmitComplexMagicCircle(const std::string& name,const Vector3& position);

	/// <summary>
	/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç™ºç”Ÿ(ç‰¹æ®Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ) / è‰²æŒ‡å®šãƒãƒ¼ã‚¸ãƒ§ãƒ³
	/// </summary>
	/// <param name="name">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—å</param>
	/// <param name="position">ç™ºç”Ÿä½ç½®</param>
	/// <param name="count">ç™ºç”Ÿæ•°</param>
	/// <param name="effectType">ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—</param>
	/// <param name="color">è‰²ã®èª¿æ•´</param>
	void EmitWithEffectTypeAndColor(const std::string& name, const Vector3& position, uint32_t count, EffectType effectType, const Vector4& color);

private:
	// DirectXCommon
	Engine::DirectXCommon* dxCommon;
	// SRVãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
	SrvManager* srvManager;
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
	VertexData* vertexData = nullptr;
	// ã‚«ãƒ¡ãƒ©
	Camera* camera = nullptr;

	// ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³
	std::mt19937 randomEngine;


	// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	D3D12_ROOT_PARAMETER rootParameters[3] = {};
	// ã‚µãƒ³ãƒ—ãƒ©ãƒ¼
	D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	Microsoft::WRL::ComPtr<ID3D12RootSignature> rootSignature;
	// ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_ELEMENT_DESC inputElementDescs[3];
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆ

	// ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_LAYOUT_DESC inputLayoutDesc{};

	// ãƒ–ãƒ¬ãƒ³ãƒ‰
	BlendMode blendMode;
	BlendMode currentBlendMode;
	D3D12_BLEND_DESC blendDesc{};
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};
	D3D12_RASTERIZER_DESC rasterizerDesc{};
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
	Microsoft::WRL::ComPtr<ID3D12PipelineState> graphicsPipelineState = nullptr;
	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc;
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒã‚¤ãƒŠãƒª
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob;
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç™ºç”Ÿä¸Šé™
	static const int kMaxParticle = 1000;

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexResource = nullptr;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ‡ãƒ¼ã‚¿
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
	ModelData modelData;
	// ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView;
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> materialResource = nullptr;
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿
	Material* materialData = nullptr;
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ— / ã‚°ãƒ«ãƒ¼ãƒ—åã‚’ã‚­ãƒ¼ã«ã—ã¦ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ç®¡ç†
	std::unordered_map<std::string, ParticleGroup> particleGroups;

	// ã‚«ãƒ¡ãƒ©è¡Œåˆ—
	Matrix4x4 cameraMatrix;
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—
	Matrix4x4 viewMatrix;
	// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—
	Matrix4x4 projectionMatrix;
	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¡Œåˆ—
	Matrix4x4 backToFrontMatrix;
	// ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—
	Matrix4x4 billboardMatrix;
	bool useBillboard = false;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒªã‚¹ãƒˆ
	std::list<Particle>particles;

	// Î”tã‚’å®šç¾©ï¼–ï¼foså›ºå®š
	const float kDeltaTime = 1.0f / 60.0f;

	// ãƒªãƒ³ã‚°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	Microsoft::WRL::ComPtr<ID3D12Resource> ringVertexBuffer = nullptr;
	D3D12_VERTEX_BUFFER_VIEW ringVertexBufferView{};
	uint32_t ringVertexCount = 0;

	// UVåº§æ¨™å¤‰æ›´
	Vector2 uvOffset = { 0.0f, 0.0f };
	Vector2 uvScrollSpeed = { 0.0f, 0.0f };  // æ°´å¹³æ–¹å‘ã«æµã™å ´åˆ


};



============================================================
File Path: Game/Particle/ParticlePresets.cpp
============================================================
#include "ParticlePresets.h"

std::unique_ptr<ParticleSystem> ParticlePresets::CreateExplosion(const Vector3& position)
{
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ç”Ÿæˆ
	auto particleSystem = ParticleSystem::Create("Explosion", "resources/Particle/circle.png");
	// ä½ç½®ã®è¨­å®š
	particleSystem->SetTranslate(position);
	// ã‚¨ãƒŸãƒƒã‚·ãƒ§ãƒ³è¨­å®š / æç”»ã•ã‚Œã‚‹ç²’å­ã®æ•°
	particleSystem->SetEmissionRate(50.0f);
	// ãƒ¡ã‚¤ãƒ³è¨­å®š / ãƒ«ãƒ¼ãƒ—å†ç”Ÿã®æœ‰ç„¡ã€å¯¿å‘½ãªã©
	particleSystem->SetLoop(false);
	particleSystem->GetMainModule().duration = 0.5f;
	particleSystem->GetMainModule().startLifetime = 1.0f;

	// çˆ†ç™ºã‚¿ã‚¤ãƒ—ã‚’è¨­å®š
	particleSystem->SetEffectType(ParticleManager::EffectType::Explosion);
	return particleSystem;
}

std::unique_ptr<ParticleSystem> ParticlePresets::CreateSmoke(const Vector3& position)
{
	auto particleSystem = ParticleSystem::Create(
		"Smoke", "resources/Particle/smoke.png");
	// ä½ç½®ã®è¨­å®š
	particleSystem->SetTranslate(position);
	// ã‚¨ãƒŸãƒƒã‚·ãƒ§ãƒ³è¨­å®š / æç”»ã•ã‚Œã‚‹ç²’å­ã®æ•°
	particleSystem->SetEmissionRate(15.0f);
	// ãƒ¡ã‚¤ãƒ³è¨­å®š / ãƒ«ãƒ¼ãƒ—å†ç”Ÿã®æœ‰ç„¡ã€å¯¿å‘½ãªã©
	particleSystem->SetLoop(true);
	particleSystem->GetMainModule().duration = 0.2f;
	particleSystem->GetMainModule().startLifetime = 0.8f;

	// ç…™ã‚¿ã‚¤ãƒ—ã‚’è¨­å®š
	particleSystem->SetEffectType(ParticleManager::EffectType::Smoke);
	return particleSystem;
}

std::unique_ptr<ParticleSystem> ParticlePresets::CreateSparks(const Vector3& position)
{
	auto particleSystem = ParticleSystem::Create(
		"Sparks", "resources/Particle/star.png");
	// ä½ç½®ã®è¨­å®š
	particleSystem->SetTranslate(position);
	// ã‚¨ãƒŸãƒƒã‚·ãƒ§ãƒ³è¨­å®š / æç”»ã•ã‚Œã‚‹ç²’å­ã®æ•°
	particleSystem->SetEmissionRate(50.0f);
	// ãƒ¡ã‚¤ãƒ³è¨­å®š / ãƒ«ãƒ¼ãƒ—å†ç”Ÿã®æœ‰ç„¡ã€å¯¿å‘½ãªã©
	particleSystem->SetLoop(false);
	particleSystem->GetMainModule().duration = 0.15f;
	particleSystem->GetMainModule().startLifetime = 0.25f;

	// ã‚¹ãƒ‘ãƒ¼ã‚¯ã‚¿ã‚¤ãƒ—ã‚’è¨­å®š
	particleSystem->SetEffectType(ParticleManager::EffectType::Spark);
	return particleSystem;
}

std::unique_ptr<ParticleSystem> ParticlePresets::CreateTitleEffect(const Vector3& position)
{
	auto particleSystem = ParticleSystem::Create("TitleEffect", "resources/Particle/circle.png");
	// ä½ç½®ã®è¨­å®š
	particleSystem->SetTranslate(position);
	// ã‚¨ãƒŸãƒƒã‚·ãƒ§ãƒ³è¨­å®š / æç”»ã•ã‚Œã‚‹ç²’å­ã®æ•°
	particleSystem->SetEmissionRate(5.0f);
	// ãƒ¡ã‚¤ãƒ³è¨­å®š / ãƒ«ãƒ¼ãƒ—å†ç”Ÿã®æœ‰ç„¡
	particleSystem->SetLoop(true);

	// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã‚’è¨­å®š
	particleSystem->SetEffectType(ParticleManager::EffectType::Default);
	return particleSystem;
}

std::unique_ptr<ParticleSystem> ParticlePresets::CreateMagicCircle(const Vector3& position)
{
	auto ps = ParticleSystem::Create("MagicCircle", "resources/Particle/circle.png");
	ps->SetTranslate(position);
	ps->SetEffectType(ParticleManager::EffectType::MagicCircle);

	// é­”æ³•é™£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
	ParticleSystem::MagicCircleParams params;
	params.radius = 5.0f;
	params.particleCount = 32;
	params.rotationSpeed = 1.0f;
	params.multiLayer = false;
	ps->SetMagicCircleParams(params);

	ps->SetLoop(true);
	ps->SetEmissionRate(10.0f);  // ã‚†ã£ãã‚Šè¿½åŠ 

	return ps;
}


std::unique_ptr<ParticleSystem> ParticlePresets::CreateComplexMagicCircle(const Vector3& position)
{
	auto ps = ParticleSystem::Create("ComplexMagicCircle", "resources/Particle/circle.png");
	ps->SetTranslate(position);
	ps->SetEffectType(ParticleManager::EffectType::MagicCircle);

	// å¤šé‡å††ã®è¨­å®š
	ParticleSystem::MagicCircleParams params;
	params.radius = 6.0f;
	params.particleCount = 40;
	params.rotationSpeed = 0.5f;
	params.multiLayer = true;  // â† å¤šé‡å††
	ps->SetMagicCircleParams(params);

	ps->SetLoop(true);
	ps->SetEmissionRate(5.0f);

	return ps;
}

std::unique_ptr<ParticleSystem> ParticlePresets::CreateSummonCircle(const Vector3& position)
{
	auto ps = ParticleSystem::Create("SummonCircle", "resources/Particle/circle.png");
	ps->SetTranslate(position);
	ps->SetEffectType(ParticleManager::EffectType::MagicCircle);

	ParticleSystem::MagicCircleParams params;
	params.radius = 4.0f;
	params.particleCount = 24;
	params.rotationSpeed = 2.0f;  // é€Ÿãå›è»¢
	params.multiLayer = true;
	ps->SetMagicCircleParams(params);

	ps->SetLoop(false);
	ps->GetMainModule().duration = 2.0f;  // 2ç§’é–“ã ã‘

	return ps;
}


============================================================
File Path: Game/Particle/ParticlePresets.h
============================================================
#pragma once
#include "ParticleSystem.h"
#include <functional>
#include <memory>

class ParticlePresets
{
public:
	/// <summary>
	/// ãƒ—ãƒªã‚»ãƒƒãƒˆè¨­å®šæ§‹é€ ä½“
	/// </summary>
	struct PresetConfig {
		std::string name;
		std::string texturePath;
		std::function<void(ParticleSystem&)> configure;
	};

	/// <summary>
	/// çˆ†ç™ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	/// </summary>
	static std::unique_ptr<ParticleSystem> CreateExplosion(const Vector3& position = { 0.0f,0.0f,0.0f });

	/// <summary>
	/// ç…™ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	/// </summary>
	static std::unique_ptr<ParticleSystem> CreateSmoke(const Vector3& position = { 0.0f,0.0f,0.0f });

	/// <summary>
	/// ã‚¹ãƒ‘ãƒ¼ã‚¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	/// </summary>
	static std::unique_ptr<ParticleSystem> CreateSparks(const Vector3& position = { 0.0f,0.0f,0.0f });

	/// <summary>
	/// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	/// </summary>
	static std::unique_ptr<ParticleSystem> CreateTitleEffect(const Vector3& position = { 0.0f,0.0f,0.0f });

	/// <summary>
	/// é­”æ³•é™£ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	/// </summary>
	static std::unique_ptr<ParticleSystem> CreateMagicCircle(const Vector3& position = { 0.0f,0.0f,0.0f });

	/// <summary>
	/// è¤‡é›‘ãªé­”æ³•é™£ï¼ˆå¤šé‡å††ï¼‰
	/// </summary>
	static std::unique_ptr<ParticleSystem> CreateComplexMagicCircle(const Vector3& position = { 0, 0, 0 });

	/// <summary>
    /// å¬å–šé­”æ³•é™£ï¼ˆä¸‹ã‹ã‚‰ä¸Šã¸ã‚¨ãƒãƒ«ã‚®ãƒ¼ãŒä¸ŠãŒã‚‹ï¼‰
    /// </summary>
	static std::unique_ptr<ParticleSystem> CreateSummonCircle(const Vector3& position = { 0, 0, 0 });
};



============================================================
File Path: Game/Particle/ParticleSystem.cpp
============================================================
#include "ParticleSystem.h"

ParticleSystem::ParticleSystem()
	: currentTime(0.0f)
	, emissionTimer(0.0f)
	, state(State::Stopped)
{
	// SRT åˆæœŸåŒ–
	transform.translate = { 0.0f, 0.0f, 0.0f };
	transform.rotate = { 0.0f, 0.0f, 0.0f };
	transform.scale = { 1.0f, 1.0f, 1.0f };

	// ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿åˆæœŸåŒ–
	emitterData.count = 1;
	emitterData.frequency = 1.0f;

	// ã‚¨ãƒŸãƒƒã‚·ãƒ§ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–
	emission.enabled = true;
	emission.rateOverTime = 10.0f; // 1ç§’ã‚ãŸã‚Š10å€‹ç™º

	// ãƒ¡ã‚¤ãƒ³ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åˆæœŸåŒ–
	main.duration = 5.0f;         // å†ç”Ÿæ™‚é–“5ç§’
	main.loop = true;            // ãƒ«ãƒ¼ãƒ—å†ç”Ÿ
	main.startLifetime = 1.0f;   // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å¯¿å‘½3ç§’
	main.startSpeed = { 0.0f, 0.0f, 0.0f };
	main.startColor = { 1.0f, 1.0f, 1.0f, 1.0f }; // ç™½è‰²
}

ParticleSystem::~ParticleSystem()
{

}

std::unique_ptr<ParticleSystem> ParticleSystem::Create(
	const std::string& particleName,
	const std::string& texturePath)
{
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®è‡ªå‹•ç”Ÿæˆ
	auto manager = ParticleManager::GetInstance();
	if (!manager->HasParticleGroup(particleName)) {
		manager->CreateParticleGroup(particleName, texturePath);
	}
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®ç”Ÿæˆ
	auto particleSystem = std::make_unique<ParticleSystem>();
	particleSystem->SetParticleName(particleName);

	return particleSystem;
}

void ParticleSystem::PlayOneShot(const std::string& particleName, const Transform& transform, uint32_t count)
{
	ParticleManager::GetInstance()->Emit(particleName, transform.translate, count);
}

void ParticleSystem::Play()
{
	// å†ç”ŸçŠ¶æ…‹ã«è¨­å®š
	state = State::Playing;
	currentTime = 0.0f;
	emissionTimer = 0.0f;
}

void ParticleSystem::Stop()
{
	// åœæ­¢çŠ¶æ…‹ã«è¨­å®š
	state = State::Stopped;
	currentTime = 0.0f;
	emissionTimer = 0.0f;
}

void ParticleSystem::Pause()
{
	// ä¸€æ™‚åœæ­¢çŠ¶æ…‹ã«è¨­å®š
	state = State::Paused;
}


void ParticleSystem::Update()
{
	// åœæ­¢ä¸­ã¾ãŸã¯ä¸€æ™‚åœæ­¢ä¸­ã¯æ›´æ–°ã—ãªã„
	if (state != State::Playing) return;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯æ›´æ–°ã—ãªã„
	if (particleName.empty()) return;

	// ã‚¨ãƒŸãƒƒã‚·ãƒ§ãƒ³ãŒç„¡åŠ¹ãªã‚‰æ›´æ–°ã—ãªã„
	if (!emission.enabled) return;

	// çµŒéæ™‚é–“ã‚’åŠ ç®—
	currentTime += kDeltaTime;
	emissionTimer += kDeltaTime;

	// ãƒ«ãƒ¼ãƒ—ã—ãªã„å ´åˆã€å†ç”Ÿæ™‚é–“ã‚’è¶…ãˆãŸã‚‰åœæ­¢
	if (!main.loop && currentTime >= main.duration) {
		Stop();
		return;
	}

	// ã‚¨ãƒŸãƒƒã‚·ãƒ§ãƒ³é »åº¦ã«åŸºã¥ã„ã¦ç™ºç”Ÿ
	if (emissionTimer >= emitterData.frequency) {
		EmitInternal();
		emissionTimer = 0.0f; // ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
	}
}



void ParticleSystem::Emit(uint32_t count)
{
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç™ºç”Ÿã•ã›ã‚‹
	ParticleManager::GetInstance()->Emit(particleName, transform.translate, count);
}



void ParticleSystem::EmitInternal()
{
	if (effectType == ParticleManager::EffectType::MagicCircle) {
		if (magicCircleParams.multiLayer) {
			// è¤‡é›‘ãªé­”æ³•é™£
			ParticleManager::GetInstance()->EmitComplexMagicCircle(
				particleName,
				transform.translate
			);
		} else {
			// ã‚·ãƒ³ãƒ—ãƒ«ãªé­”æ³•é™£
			ParticleManager::GetInstance()->EmitMagicCircle(
				particleName,
				transform.translate,
				magicCircleParams.particleCount,
				magicCircleParams.radius
			);
		}
	} else {
		// é€šå¸¸ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
			// è‰²ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãŒã‚ã‚‹å ´åˆã¯è‰²ä»˜ãã§ç™ºç”Ÿï¼ˆä¿®æ­£ï¼‰
		if (useColorOverride) {
			ParticleManager::GetInstance()->EmitWithEffectTypeAndColor(
				particleName,
				transform.translate,
				emitterData.count,
				effectType,
				colorOverride  
			);
		} else {
			ParticleManager::GetInstance()->EmitWithEffectType(
				particleName,
				transform.translate,
				emitterData.count,
				effectType
			);
		}
	}
}



============================================================
File Path: Game/Particle/ParticleSystem.h
============================================================
#pragma once
#include "ParticleManager.h"
using namespace std;
/// <summary>
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒŸãƒƒã‚¿ã‚¯ãƒ©ã‚¹
/// </summary>
class ParticleSystem
{
public:
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®çŠ¶æ…‹
	enum class State {
		Playing, // å†ç”Ÿä¸­
		Stopped, // åœæ­¢ä¸­
		Paused	 // ä¸€æ™‚åœæ­¢ä¸­
	};

	// ã‚¨ãƒŸãƒƒã‚·ãƒ§ãƒ³è¨­å®š
	struct EmissionModule {
		bool enabled;        // ã‚¨ãƒŸãƒƒã‚·ãƒ§ãƒ³ã®æœ‰åŠ¹ãƒ»ç„¡åŠ¹
		float rateOverTime; // æ™‚é–“ã‚ãŸã‚Šã®ç™ºç”Ÿç‡
	};

	// ãƒ¡ã‚¤ãƒ³è¨­å®š
	struct MainModule {
		float duration;      // å†ç”Ÿæ™‚é–“
		bool loop;          // ãƒ«ãƒ¼ãƒ—å†ç”Ÿã®æœ‰ç„¡
		float startLifetime; // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®å¯¿å‘½
		Vector3 startSpeed;  // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åˆé€Ÿåº¦
		Vector4 startColor;  // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åˆæœŸè‰²
	};

	/// <summary>
	/// é­”æ³•é™£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	/// </summary>
	struct MagicCircleParams {
		float radius = 5.0f;        // åŠå¾„
		uint32_t particleCount = 32; // å††å‘¨ä¸Šã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ•°
		float rotationSpeed = 1.0f;  // å›è»¢é€Ÿåº¦
		bool multiLayer = false;     // å¤šé‡å††ã‹ã©ã†ã‹
	};

	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	ParticleSystem();
	~ParticleSystem();

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ç”Ÿæˆ
	/// </summary>
	/// <param name="particleName">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <param name="texturePath">ä½¿ç”¨ã™ã‚‹ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰</param>
	/// <returns></returns>
	static std::unique_ptr<ParticleSystem>Create(const std::string& particleName, const std::string& texturePath);
	/// <summary>
	/// ãƒ¯ãƒ³ã‚·ãƒ§ãƒƒãƒˆå†ç”Ÿ
	/// </summary>
	/// <param name="particleName">ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰</param>
	/// <param name="transform">ç™ºç”Ÿã•ã›ã‚‹å ´æ‰€</param>
	/// <param name="count">ç™ºç”Ÿã•ã›ã‚‹æ•°</param>
	static void PlayOneShot(const std::string& particleName, const Transform& transform, uint32_t count = 10);

	/// <summary>
	/// å†ç”Ÿ
	/// </summary>
	void Play();

	/// <summary>
	/// åœæ­¢
	/// </summary>
	void Stop();

	/// <summary>
	/// ä¸€æ™‚åœæ­¢
	/// </summary>
	void Pause();


	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿ
	/// </summary>
	void Emit(uint32_t count);

	


public:	// Getter / Setter


	/// <summary>
	/// Particleã®ç™ºç”Ÿä½ç½®è¨­å®šãƒ»å–å¾—
	/// </summary>
	/// <param name="translate"></param>
	void SetTranslate(const Vector3& translate) { this->transform.translate = translate; }
	Vector3 GetTranslate()const { return transform.translate; }

	/// <summary>
	/// Particleã®å›è»¢è¨­å®šãƒ»å–å¾—
	/// </summary>
	/// <param name="rotate"></param>
	void SetRotate(const Vector3& rotate) { this->transform.rotate = rotate; }
	Vector3 GetRotate()const { return transform.rotate; }

	/// <summary>
	/// Particleã®ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®šãƒ»å–å¾—
	/// </summary>
	/// <param name="scale"></param>
	void SetScale(const Vector3& scale) { this->transform.scale = scale; }
	Vector3 GetScale()const { return transform.scale; }

	/// <summary>
	/// ã‚¨ãƒŸãƒƒã‚¿ã®Transformè¨­å®šãƒ»å–å¾—
	/// </summary>
	/// <param name="transform">ã‚»ãƒƒãƒˆã™ã‚‹Transform</param>
	void SetTransform(const Transform& transform) { this->transform = transform; }
	Transform GetTransform()const { return transform; }

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ ã®çŠ¶æ…‹å–å¾—
	/// </summary>
	/// <returns>çŠ¶æ…‹</returns>
	bool IsPlaying()const { return state == State::Playing; }
	bool IsStopped()const { return state == State::Stopped; }
	bool IsPaused()const { return state == State::Paused; }

	/// <summary>
	/// ã‚¨ãƒŸãƒƒã‚·ãƒ§ãƒ³ãƒ¬ãƒ¼ãƒˆè¨­å®šãƒ»å–å¾—ï¼ˆï¼‘ç§’å½“ãŸã‚Šã®ç™ºç”Ÿæ•°ï¼‰
	/// </summary>
	/// <param name="rate">ã©ã®ãã‚‰ã„ã®é »åº¦ã«ã™ã‚‹ã‹</param>
	void SetEmissionRate(float rate) {
		emission.rateOverTime = rate;
		emitterData.frequency = 1.0f / rate;
		emitterData.count = static_cast<uint32_t>(rate / 10.0f);
		if (emitterData.count < 1)emitterData.count = 1;
	};
	float GetEmissionRate()const {
		return emission.rateOverTime;
	}

	/// <summary>
	/// ãƒ«ãƒ¼ãƒ—è¨­å®šãƒ»å–å¾—
	/// </summary>
	/// <param name="loop">ãƒ«ãƒ¼ãƒ—ã•ã›ã‚‹ã‹ã®ãƒ•ãƒ©ã‚°</param>
	void SetLoop(bool loop) { main.loop = loop; }
	bool GetLoop()const { return main.loop; }

	/// <summary>
	/// ç™ºç”Ÿã•ã›ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®åå‰ã®è¨­å®šãƒ»å–å¾—
	/// </summary>
	/// <param name="name"></param>
	void SetParticleName(const string& name) { particleName = name; }
	std::string GetParticleName()const { return particleName; }


	/// <summary>
	/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã®è¨­å®šãƒ»å–å¾—
	/// </summary>
	/// <param name="type">ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã‚¿ã‚¤ãƒ—</param>
	void SetEffectType(ParticleManager::EffectType type) {
		// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¿ã‚¤ãƒ—ã®è¨­å®š
		effectType = type;
	}
	ParticleManager::EffectType GetEffectType()const { return effectType; }

	/// <summary>
	/// é­”æ³•é™£ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿è¨­å®š
	/// </summary>
	/// <param name="params"></param>
	void SetMagicCircleParams(const MagicCircleParams& params) { magicCircleParams = params; }

	/// <summary>
	/// è‰²ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰è¨­å®š
	/// </summary>
	/// <param name="color">å¤‰æ›´ã™ã‚‹è‰²</param>
	void SetColor(const Vector4& color) {
		colorOverride = color;
		useColorOverride = true;
	}
	/// <summary>
	/// è‰²ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã‚’ã‚¯ãƒªã‚¢
	/// </summary>
	void ClearColorOverride() {
		useColorOverride = false;
	}
	/// <summary>
	/// è‰²ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ãŒæœ‰åŠ¹ã‹ã©ã†ã‹
	/// </summary>
	/// <returns>æœ‰åŠ¹ã‹ç„¡åŠ¹ã‹</returns>
	bool IsColorOverrideEnabled()const { return useColorOverride; }

	/// <summary>
	/// è‰²ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰å–å¾—
	/// </summary>
	/// <returns>ç¾åœ¨ã®ã‚«ãƒ©ãƒ¼ã®å–å¾—</returns>
	Vector4 GetColorOverride()const { return colorOverride; }




public:	// ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ã¸ã®ã‚¢ã‚¯ã‚»ã‚¹
	EmissionModule& GetEmissionModule() { return emission; }
	MainModule& GetMainModule() { return main; }

private:
	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿå†…éƒ¨å‡¦ç†
	/// </summary>
	void EmitInternal();

private:
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒãƒ¼ãƒ 
	std::string particleName;

	// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
	Transform transform;

	// çŠ¶æ…‹
	State state = State::Stopped;

	// ã‚¿ã‚¤ãƒãƒ¼
	float currentTime = 0.0f;
	float emissionTimer = 0.0f;

	// ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«
	EmissionModule emission;
	MainModule main;

	// ã‚¨ãƒŸãƒƒã‚¿ãƒ¼ãƒ‡ãƒ¼ã‚¿ï¼ˆå†…éƒ¨ç”¨ï¼‰
	struct EmitterData {
		uint32_t count = 1;
		float frequency = 1.0f;
	}emitterData;

	// ï¼‘ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ™‚é–“
	const float kDeltaTime = 1.0f / 60.0f;

	ParticleManager::EffectType effectType = ParticleManager::EffectType::Default;
	// é­”æ³•é™£ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	MagicCircleParams magicCircleParams;

	// è‰²ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
	Vector4 colorOverride = { 1.0f, 1.0f, 1.0f, 1.0f };
	// è‰²ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹ã‹ã©ã†ã‹
	bool useColorOverride = false; 

	// ãƒ¢ãƒ‡ãƒ«ã®å‘ãã®è£œæ­£å€¤
	const float modelYawOffset = -1.570796326f;

	// ç§»å‹•ã«ã‹ã‹ã‚‹æ™‚é–“
	float moveDuration = 0.35f;
	// å‘ãå¤‰æ›´ã«ã‹ã‹ã‚‹æ™‚é–“
	float faceDuration = 0.25f;

};


============================================================
File Path: Game/Scene/GamePlayScene.cpp
============================================================
#include "GamePlayScene.h"
#include "Game/Application/Map/Map.h"
#include "Game/Application/Player/Player.h"
#include "Game/Collision/CollisionManager.h"
#include "Game/Particle/ParticleManager.h"
#include "engine/InsideScene/Framework.h"
#include "Game/Application/PlayContext.h"
#include "Game/Particle/ModelParticleManager.h"
#ifdef USE_IMGUI
#include "engine/base/ImGuiManager.h"
#endif

using Engine::DirectXCommon;

GamePlayScene::GamePlayScene()
{
}

GamePlayScene::~GamePlayScene()
{
}

void GamePlayScene::Initialize(DirectXCommon* dxCommon)
{
	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
	SpriteCommon::GetInstance().Initialize(dxCommon);
	/// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®åˆæœŸåŒ–
	Audio::GetInstance().Initialize();
	soundData = Audio::GetInstance().LoadWave("resources/mokugyo.wav");
	xaudio2_ = Audio::GetInstance().GetXAudio2();
	Audio::GetInstance().SoundPlayWave(xaudio2_, soundData);

	// ã‚«ãƒ¡ãƒ©ã‚¯ãƒ©ã‚¹ã®ç”Ÿæˆ
	camera = Framework::GetMainCamera();

	const std::string& key = PlayContext::GetInstance().GetSelectedStageKey();

	// ãƒãƒƒãƒ—
	map = std::make_unique<Map>();

	// ãƒãƒ¼ãƒ‰ã«å¿œã˜ãŸã‚¹ãƒ†ãƒ¼ã‚¸ã‚’åˆæœŸåŒ–
	stageKey = key.empty() ? "1-1" : key.c_str();
	map->Initialize(stageKey);


	collision_ = std::make_unique<CollisionManager>();

	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆæœŸåŒ–
	player = std::make_unique<Player>();
	player->Initialize(Vector3{ 2.0f,2.0f,0.0f });
	player->SetMap(map.get());

	InitializeEnemy();

	//sceneTransition = std::make_unique<SceneTransition>();
	//sceneTransition->Initialize(10);

	backGround = std::make_unique<BackGround>();
	backGround->Initialize();

	cameraController_ = std::make_unique<CameraController>();
	cameraController_->Initialize();

	SpritesInitialize();

	stageStartEventFlag_ = true;
	player->SetControlEnabled(false);

	isPlayerControlLocked_ = true;

	// è‡ªæ©ŸãŒãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸã‚‰ç”»é¢ã‚·ã‚§ã‚¤ã‚¯ä¸­ã«å‡ºã™ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	enemyHitSprite_ = std::make_unique<Sprite>();
	enemyHitSprite_->Initialize("resources/HitDamage.png");
	enemyHitSprite_->SetPosition({ 0.0f,0.0f });
	enemyHitSprite_->SetSize({ 1280.0f,720.0f });

	enemyHitSprite_->SetColor({ 1.0f, 1.0f, 1.0f, 0.0f });
	


	pauseSystem_ = std::make_unique<PauseSystem>();
	pauseSystem_->Initialize();

	gamePlayHUD_ = std::make_unique<GamePlayHUD>();
	gamePlayHUD_->Initialize();

	startCam_ = std::make_unique<StartCamPhase>();
	startCam_->Bind(camera, &cameraTransform);

	startCam_->Start();

	damageFeedBack_ = std::make_unique<DamageFeedBack>();
	damageFeedBack_->Bind(player.get(), camera, &cameraTransform);
	damageFeedBack_->Initialize();

	ModelParticleManager::GetInstance().Initialize();
}


void GamePlayScene::Update()
{

	if (pauseSystem_->Update()) {
		return;
	}

	// ã‚«ãƒ¡ãƒ©ã®æ›´æ–°
	camera->Update();
	// èƒŒæ™¯ã®æ›´æ–°
	backGround->Update();
	// ã‚¹ã‚¿ãƒ¼ãƒˆã‚«ãƒ¡ãƒ©ã®æ›´æ–°
	startCam_->Update(dt);
	stageStartEventFlag_ = startCam_->IsRunning();
	isPlayerControlLocked_ = stageStartEventFlag_;
	player->SetControlEnabled(!isPlayerControlLocked_);
	
	// ãƒãƒƒãƒ—ã®æ›´æ–°
	map->Update();
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ›´æ–°
	player->Update();
	

	bool isEnemyHitNow = player->GetHitEnemy();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ•µã«å½“ãŸã£ãŸã‚‰ã‚«ãƒ¡ãƒ©ã‚’ã‚·ã‚§ã‚¤ã‚¯ã™ã‚‹
	if (player->GetHitEnemy() && !wasEnemyHit_) {
		enemyHitShakeActive_ = true;
		//enemyHitSprite_->SetColor({ 1.0f, 1.0f, 1.0f, 1.0f });
		enemyHitTimer_ = 0.0f;
		// ã‚«ãƒ¡ãƒ©ã®å…ƒã®ä½ç½®ã‚’ä¿å­˜
		enemyHitBasePos = camera->GetTranslate();

	}
	// æ•µã‚’ç‚¹æ»…ã•ã›ã‚‹
	//Vector4 currentColor = enemyHitSprite_->GetColor();
	//if (currentColor.w > 0.0f) {
	//	// æ¸›ç®—ã‚¹ãƒ”ãƒ¼ãƒ‰ã¯ 0.01f ï½ 0.05f ãã‚‰ã„ã§èª¿æ•´
	//	float newAlpha = (std::max)(0.0f, currentColor.w - 0.02f);
	//	enemyHitSprite_->SetColor({ currentColor.x, currentColor.y, currentColor.z, newAlpha });
	//}
	wasEnemyHit_ = isEnemyHitNow;

	// ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ã®æ›´æ–°
	if (enemyHitShakeActive_) {
		// 
		EnemyHitShake(dt);
	}

	//sceneTransition->Update();

	

	// ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¤‰æ›´ã•ã‚ŒãŸã‚‰ã‚¨ãƒãƒŸãƒ¼ã‚’å†ç”Ÿæˆ
	if (map->ConsumeEnemyLayerDirtyFlag()) {
		GenerateEnemy();
	}


	// ã‚«ãƒ¡ãƒ©ã®ãƒ•ã‚©ãƒ­ãƒ¼ç¯„å›²
	cameraController_->SetFollowRange(8.0f, 92.0f);
	// é–‹å§‹æ¼”å‡ºä¸­ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¸ã®å…¥åŠ›ã‚’å—ã‘ä»˜ã‘ãªã„
	if (isPlayerControlLocked_) {
		player->SetControlEnabled(false);
	} else {
		player->SetControlEnabled(true);
	}

	

	// ãƒ•ã‚©ãƒ­ãƒ¼ã‚«ãƒ¡ãƒ©
	if (!startCam_->IsRunning())
	{
		// baseCamPos_ ã‚’å…¥åŠ›ã¨ã—ã¦ä½¿ã†ï¼ˆå‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®ã‚·ã‚§ã‚¤ã‚¯ã‚’æ··ãœãªã„ï¼‰
		cameraController_->SetCameraPosition(baseCameraPos_);
		cameraController_->SetTargetPosition(player->GetTranslate());
		cameraController_->Update(dt);

		// ãƒ•ã‚©ãƒ­ãƒ¼çµæœã‚’ã€ŒåŸºæº–ã€ã¨ã—ã¦ä¿å­˜
		baseCameraPos_ = cameraController_->GetCameraPosition();

	} else {
				// é–‹å§‹æ¼”å‡ºä¸­ã¯åŸºæº–ä½ç½®ã‚‚ã‚«ãƒ¡ãƒ©ä½ç½®ã‚‚é–‹å§‹æ¼”å‡ºã®ä½ç½®ã«ã™ã‚‹
		baseCameraPos_ = cameraTransform.translate;

	}
	cameraTransform.translate = baseCameraPos_;
	camera->SetTranslate(baseCameraPos_);

	damageFeedBack_->SetBaseCameraPos(baseCameraPos_);
	damageFeedBack_->Update(dt);


	// æ•µã®æ›´æ–°
	for (auto& enemy : enemies) {
		enemy->Update();
	}

	// å½“ãŸã‚Šã¯åˆ¤å®š
	CheckCollision();
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ›´æ–°
	gamePlayHUD_->Update();


	ModelParticleManager::GetInstance().Update();
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚´ãƒ¼ãƒ«ã«è§¦ã‚Œã¦ã„ãŸã‚‰ã‚·ãƒ¼ãƒ³é·ç§»
	bool isGoal = player->GetIsGoal();
	if (isGoal) {
		sceneManager->ChangeScene("STAGECLEAR");
	}

	

	// ImGuiã®æç”»
	DrawImgui();


}

void GamePlayScene::Draw()
{
	///////////////////
	//  ãƒ¢ãƒ‡ãƒ«ã®æç”»   //
	///////////////////

	backGround->Draw();


	//sceneTransition->Draw();
	/// ãƒãƒƒãƒ—ã®æç”»
	map->Draw();

	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æç”»
	player->Draw();

	/// æ•µã®æç”»
	for (auto& enemy : enemies) {
		enemy->Draw();
	}

	ParticleManager::GetInstance()->Draw();
	ModelParticleManager::GetInstance().Draw();

	///////////////////
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æç”» //
	///////////////////

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæç”»å‡¦ç†
	SpritesDraw();

	damageFeedBack_->Draw();
	gamePlayHUD_->Draw(pauseSystem_->GetPause(), !isPlayerControlLocked_);


	pauseSystem_->Draw();

}

void GamePlayScene::InitializeEnemy()
{

	// csvã‚’èª­ã¿è¾¼ã¿æ•µã®é…ç½®æƒ…å ±ã‚’å–å¾—
	GenerateEnemy();

}

void GamePlayScene::GenerateEnemy()
{
	// ã‚¨ãƒãƒŸãƒ¼ã‚’ä¸€æ—¦ã‚¯ãƒªã‚¢
	enemies.clear();

	const EnemyLayerData& enemyLayerData = map->GetEnemyLayerData();
	const auto& enemyData = enemyLayerData.enemyData;

	const uint32_t mapHeight = static_cast<uint32_t>(enemyData.size());
	for (uint32_t y = 0; y < mapHeight; y++) {
		const uint32_t mapWidth = static_cast<uint32_t>(enemyData[y].size());
		for (uint32_t x = 0; x < mapWidth; x++) {
			EnemyType type = enemyData[y][x];
			// æ•µã®ç¨®é¡ãŒNoneãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
			if (EnemyType::None == type) {
				continue;
			}

			// æ•µã®ç”Ÿæˆ
			// EnemyTypeã‹ã‚‰æ•µã®ç¨®é¡ã‚’ç‰¹å®šã—ã¦ç”Ÿæˆ
			std::string enemyId;
			switch (type) {
			case EnemyType::NormalEnemy:
				enemyId = "NormalEnemy";
				break;
			case EnemyType::FlyingEnemy:
				enemyId = "FlyingEnemy";
				break;
			default:
				// æœªçŸ¥ã®ã‚¿ã‚¤ãƒ—
				continue;
			}

			// ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã§ã‚¨ãƒãƒŸãƒ¼ã‚’ç”Ÿæˆ
			auto enemy = EnemyFactory::CreateEnemy(enemyId);
			// ç”Ÿæˆå¤±æ•—ãƒã‚§ãƒƒã‚¯
			if (!enemy) continue;
			// ã‚¨ãƒãƒŸãƒ¼ã®åˆæœŸåŒ–
			enemy->Initialize();
			// ãƒãƒƒãƒ—ä¸Šã®ä½ç½®ã«ã‚»ãƒƒãƒˆ
			Vector3 enemyPos = map->GetMapChipPositionByIndex(x, y);
			// ã‚ªãƒ•ã‚»ãƒƒãƒˆ
			enemyPos.x += enemySpawnOffset_;
			enemyPos.y -= enemySpawnOffset_;
			enemy->SetTranslate(enemyPos);
			// ã‚¨ãƒãƒŸãƒ¼ãƒªã‚¹ãƒˆã«è¿½åŠ 
			enemies.push_back(std::move(enemy));
		}
	}
}

void GamePlayScene::CheckCollision()
{

	collision_->Clear();

	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	if (player) {
		collision_->AddCollider(player.get());
	}

	/// ã‚¨ãƒãƒŸãƒ¼å…¨ç¨®
	for (auto& enemy : enemies) {
		if (!enemy)continue;

		if (enemy->IsAlive()) {
			collision_->AddCollider(enemy.get());
		}
	}
	// è¡çªåˆ¤å®šå®Ÿè¡Œ
	collision_->CheckAllCollisions();

}

void GamePlayScene::UpdateStartCamera(float dt)
{
	
	
}

void GamePlayScene::EnemyHitShake(float dt)
{
	// ã‚¹ã‚¿ãƒ¼ãƒˆæ¼”å‡ºä¸­ã¯ç„¡åŠ¹
	if (stageStartEventFlag_) {
		return;

	}
	enemyHitTimer_ += dt;

	// æ¸›è¡°
	float u = std::clamp(1.0f - (enemyHitTimer_ / enemyHitShakeTime_), 0.0f, 1.0f);

	// ï¼’è»¸(x,y)ã®ã‚·ã‚§ã‚¤ã‚¯
	float sx = std::sin(enemyHitTimer_ * 80.0f);
	float sy = std::sin(enemyHitTimer_ * 100.0f);

	Vector3 offset = { sx * shakeAmp_ * u, sy * shakeAmp_ * u, 0.0f };

	cameraTransform.translate += offset;

	// ã‚·ã‚§ã‚¤ã‚¯çµ‚äº†
	if (enemyHitTimer_ >= enemyHitShakeTime_) {
		enemyHitTimer_ = 0.0f;
		enemyHitShakeActive_ = false;

		// æœ€çµ‚çš„ã«ã¯å…ƒã®ä½ç½®ã«æˆ»ã™
		camera->SetTranslate(enemyHitBasePos);
		cameraTransform.translate = enemyHitBasePos;

	}


}

void GamePlayScene::SpritesInitialize()
{
	

	
}

void GamePlayScene::SpritesUpdate()
{
	

	
	
	
}

void GamePlayScene::SpritesDraw()
{




	if (enemyHitShakeActive_ || enemyHitSprite_->GetColor().w > 0.0f) {
		// ãƒ€ãƒ¡ãƒ¼ã‚¸ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
		/*if (damageFeedback) {
			enemyHitSprite_->Draw();
		}*/
	}
	

}



void GamePlayScene::Finalize()
{
	map->Finalize();

	/// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®çµ‚äº†å‡¦ç†
	Audio::GetInstance().SoundUnload(&soundData);

	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®çµ‚äº†å‡¦ç†
	SpriteCommon::GetInstance().DeleteInstance();

}


void GamePlayScene::DrawImgui()
{
#ifdef USE_IMGUI
	ImGui::Begin("Camera Settings / GamePlayScene");
	// èª­ã¿è¾¼ã‚“ã§ã„ã‚‹ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®ã‚­ãƒ¼
	ImGui::Text("SelectedStage:%s",stageKey);
	//==============================
	// Start Camera Intro Tuning UI
	//==============================

	// ã‚«ãƒ¡ãƒ©ã®é…ç½® / å›è»¢ä¿®æ­£
	cameraTransform.translate = camera->GetTranslate();
	ImGui::DragFloat3("Camera Position", &cameraTransform.translate.x, 0.1f, -10000.0f, 10000.0f);

	cameraTransform.rotate = camera->GetRotate();
	ImGui::DragFloat3("Camera Rotation", &cameraTransform.rotate.x, 0.1f, -180.0f, 180.0f);



	if (ImGui::Button("Vertical Camera")) {
		cameraTransform.translate = { 8.0f,20.0f,0.0f };
		cameraTransform.rotate = { 1.6f,0.0f,0.0f };
	}
	ImGui::End();

	camera->SetTranslate(cameraTransform.translate);
	camera->SetRotate(cameraTransform.rotate);
#endif

}

============================================================
File Path: Game/Scene/GamePlayScene.h
============================================================
#pragma once
#include "Audio.h"
#include "SpriteCommon.h"
#include "engine/InsideScene/BaseScene.h"
#include "engine/math/MyMath.h"
#include "Game/Application/Enemy/EnemyFactory.h"
#include "Game/Application/BackGround.h"
#include "Game/Camera/CameraController.h"
#include "Game/Particle/ParticleSystem.h"
#include "SceneTransition/SceneTransition.h"
#include "Game/Scene/Pause/PauseSystem.h"
#include "Game/Application/UI/GamePlayHUD.h"
#include "Game/Camera/StartCamPhase.h"
#include "Game/Application/UI/DamageFeedBack.h"
#include "engine/base/DirectXCommon.h"
/// <summary>
/// ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³
/// ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ä¸­ã®ã‚·ãƒ¼ãƒ³ã‚’ç®¡ç†ã™ã‚‹
/// </summary>

// å‰æ–¹å®£è¨€
class Map;
class Player;
class Object3D;
class CollisionManager;
/// <summary>
/// ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³ : åŸºåº•ã‚·ãƒ¼ãƒ³ã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿
/// </summary>
class GamePlayScene :public BaseScene
{
public:
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	GamePlayScene();
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~GamePlayScene();
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="dxCommon"></param>
	void Initialize(Engine::DirectXCommon* dxCommon) override;
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;
	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw()override;
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize()override;

	/// <summary>
	/// Imguiä¸€æ‹¬ç®¡ç† / æç”»é–¢æ•°
	/// </summary>
	void DrawImgui();

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®åˆæœŸåŒ–
	/// </summary>
	void InitializeEnemy();

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®ç”Ÿæˆ
	/// </summary>
	void GenerateEnemy();

	/// <summary>\
	/// å½“ãŸã‚Šåˆ¤å®š
	/// </summary>
	void CheckCollision();

	/// <summary>
	/// ã‚¹ã‚¿ãƒ¼ãƒˆã‚«ãƒ¡ãƒ©ã®æ›´æ–°
	/// </summary>
	void UpdateStartCamera(float dt);

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ãƒ’ãƒƒãƒˆæ™‚ã®ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯
	/// </summary>
	void EnemyHitShake(float dt);

	/// <summary>
	/// UI/ãƒ€ãƒ¡ãƒ¼ã‚¸/ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆé¡ã®åˆæœŸåŒ– / æ›´æ–° / æç”»
	/// </summary>
	void SpritesInitialize();
	void SpritesUpdate();
	void SpritesDraw();


	

private:
	// ãƒãƒƒãƒ—
	std::unique_ptr<Map> map;
	
	// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª
	// ã‚µã‚¦ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿
	SoundData soundData;
	IXAudio2* xaudio2_;

	// Player
	std::unique_ptr<Player> player;


	/// ã‚¨ãƒãƒŸãƒ¼ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
	std::vector<std::unique_ptr<EnemyBase>> enemies;

	/// ã‚³ãƒªã‚¸ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
	std::unique_ptr<CollisionManager> collision_;


	/// ã‚«ãƒ¡ãƒ©
	Camera* camera = nullptr;
	Transform cameraTransform;

	

	// è¢«å¼¾ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
	std::unique_ptr<DamageFeedBack> damageFeedBack_;


	
	float shakeAmp_ = 0.1f;

	


	/// ã‚¿ã‚¤ãƒˆãƒ«ãƒ­ã‚´
	std::unique_ptr<Object3D> titleLogoObject;
	Transform titleLogoTransform;

	/// ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰
	std::unique_ptr<BackGround> backGround;


	// ã‚·ãƒ¼ãƒ³é·ç§»
	std::unique_ptr<SceneTransition> sceneTransition;

	// ãƒ•ã‚©ãƒ­ãƒ¼ã‚«ãƒ¡ãƒ©
	std::unique_ptr<CameraController> cameraController_;

	// ãƒãƒ¼ã‚ºã‚·ã‚¹ãƒ†ãƒ 
	std::unique_ptr<PauseSystem> pauseSystem_;

	// ã‚¹ãƒ†ãƒ¼ã‚¸é–‹å§‹æ¼”å‡ºãƒ•ãƒ©ã‚°
	bool stageStartEventFlag_ = true;
	// å›ºå®šãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆç”¨ã®ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ 
	const float dt = 1.0f / 60.0f;

	// ã‚¨ãƒãƒŸãƒ¼é…ç½®ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	float enemySpawnOffset_ = 0.5f;

	// ã‚¨ãƒãƒŸãƒ¼ãƒ’ãƒƒãƒˆã®ã‚·ã‚§ã‚¤ã‚¯æ™‚é–“
	float enemyHitShakeTime_ = 1.0f;
	// ã‚¨ãƒãƒŸãƒ¼ãƒ’ãƒƒãƒˆæ™‚ã®ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ç”¨
	bool enemyHitShakeActive_ = false;
	// ã‚·ã‚§ã‚¤ã‚¯æ™‚é–“
	float enemyHitTimer_ = 0.0f;
	// ã‚·ã‚§ã‚¤ã‚¯æŒç¶šæ™‚é–“ 
	Vector3 enemyHitBasePos{};
	// å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ•µå½“ãŸã‚Šåˆ¤å®š
	bool wasEnemyHit_ = false;
	

	std::unique_ptr<ParticleSystem>testParticle_;

	

	bool isPlayerControlLocked_ = false;

	
	// ã‚¨ãƒãƒŸãƒ¼ãƒ’ãƒƒãƒˆæ™‚ã®ã‚·ã‚§ã‚¤ã‚¯ä¸­ã«å‡ºã™è¢«å¼¾ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::unique_ptr<Sprite> enemyHitSprite_;
	float alpha;
	
	std::unique_ptr<GamePlayHUD> gamePlayHUD_;

	std::unique_ptr<StartCamPhase> startCam_;

	Vector3 baseCameraPos_ = {};

	std::string stageKey;
};



============================================================
File Path: Game/Scene/MyGame.cpp
============================================================
#include "MyGame.h"
#include "engine/InsideScene/SceneFactory.h"
#include <dxgiformat.h>
#include <memory>
#include "RenderTexture.h"
#include "ModelManager.h"
#include "SkyBox/SkyBox.h"
#include "TextureManager.h"
#include "WinAPI.h"
#include "MyMath.h"
#include "Game/Application/ModelList.h"
#include "engine/InsideScene/Framework.h"
#include "Game/Particle/ModelParticleManager.h"

using namespace Engine;

void MyGame::Initialize()
{
	Framework::Initialize();
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ç”Ÿæˆ
	sceneFactory_ = make_unique<SceneFactory>();
	SceneManager::GetInstance()->SetSceneFactory(sceneFactory_.get());
	// ã‚·ãƒ¼ãƒ³managerã«æœ€åˆã®ã‚·ãƒ¼ãƒ³ã‚’ã‚»ãƒƒãƒˆ
	SceneManager::GetInstance()->ChangeScene("TITLE");

	modelList = make_unique<ModelList>();
	modelList->LoadAllModel();

	//ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹
	skyBox = make_unique<SkyBox>();
	skyBox->Initialize(dxCommon.get(), srvManager.get());

	renderTexture = std::make_unique<RenderTexture>();
	renderTexture->Initialize(dxCommon.get(),srvManager.get(),
		WinAPI::kClientWidth,WinAPI::kClientHeight,
		DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, 
		Vector4{ 1.0f, 1.0f, 1.0f, 1.0f });
}

void MyGame::Update()
{
#ifdef USE_IMGUI // ãƒ‡ãƒãƒƒã‚°æ™‚ã®ã¿æœ‰åŠ¹ImGuiã®å‡¦ç†
	imGui->Begin(); 
#endif 
	Framework::Update();
	skyBox->Update();
#ifdef USE_IMGUI // ãƒ‡ãƒãƒƒã‚°æ™‚ã®ã¿æœ‰åŠ¹ImGuiã®å‡¦ç†
	imGui->End();
#endif

}

void MyGame::Draw()
{
	if (usePostProcess_) {
		renderTexture->BeginRender();
		srvManager->PreDraw();
		SceneManager::GetInstance()->Draw();
		renderTexture->EndRender();

		dxCommon->PreDraw();
		srvManager->PreDraw();
		renderTexture->Draw();
	} else {
		dxCommon->PreDraw();
		srvManager->PreDraw();
		SceneManager::GetInstance()->Draw();
	}

	Framework::Draw();

#ifdef USE_IMGUI
	// ImGuiã®æç”»
	imGui->Draw();
#endif
	dxCommon->PostDraw();

}


void MyGame::Finalize()
{
	
#pragma region  è§£æ”¾å‡¦ç†
#ifdef USE_IMGUI
	// ImGuiã®çµ‚äº†å‡¦ç†
	imGui->Finalize();
#endif
	// CloseHandle(fenceEvent);
	TextureManager::GetInstance()->Finalize();
	// ãƒ¢ãƒ‡ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ã®çµ‚äº†å‡¦ç†
	ModelManager::GetInstance().Finalize();
	winAPI->Finalize();

#pragma endregion

	Framework::Finalize();
}


============================================================
File Path: Game/Scene/MyGame.h
============================================================
#pragma once
#include"externals/DirectXTex/d3dx12.h"
#include "engine/InsideScene/Framework.h"
#include "Game/Application/ModelList.h"
#include "engine/3d/SkyBox/SkyBox.h"
/// <summary>
/// ã‚²ãƒ¼ãƒ å…¨ä½“ : ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚¯ãƒ©ã‚¹ç¶™æ‰¿
/// </summary>
class MyGame :public Framework
{
public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize() override;
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;
	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw()override;
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize()override;


private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	
	// èª­ã¿è¾¼ã‚€ãƒ¢ãƒ‡ãƒ«ã®ãƒªã‚¹ãƒˆ
	std::unique_ptr<ModelList> modelList;
	// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹
	std::unique_ptr<SkyBox> skyBox = nullptr;

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
	bool usePostProcess_ = false;

};



============================================================
File Path: Game/Scene/Pause/PauseSystem.cpp
============================================================
#include "PauseSystem.h"
#include "Input.h"

#include "engine/InsideScene/SceneManager.h"


void PauseSystem::Initialize()
{
	pauseUI_ = std::make_unique<PauseUI>();
	pauseUI_->Initialize();
}

bool PauseSystem::Update()
{
	if (Input::GetInstance()->TriggerKey(DIK_ESCAPE)) {
		isPause_ = !isPause_;
	}
	if (isPause_) {
		// ãƒãƒ¼ã‚ºç”»é¢
		pauseUI_->Update();
		// ç¶šã‘ã‚‹ãŒé¸ã°ã‚Œã¦æ±ºå®šã—ãŸã‚‰ãƒãƒ¼ã‚ºè§£é™¤
		if (pauseUI_->PauseReleaseRequested()) {
			isPause_ = false;
		}

		switch (pauseUI_->ConsumeAction())
		{
			
			case PauseUI::Action::Retry:
				// ãƒªãƒˆãƒ©ã‚¤å‡¦ç†
				SceneManager::GetInstance()->ChangeScene("GAMEPLAY");
				break;
			case PauseUI::Action::StageSelect:
				// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã¸
				SceneManager::GetInstance()->ChangeScene("STAGESELECT");
				break;
			case PauseUI::Action::Title:
				// ã‚¿ã‚¤ãƒˆãƒ«ã¸
				SceneManager::GetInstance()->ChangeScene("TITLE");
				break;
		}

		// ãƒãƒ¼ã‚ºä¸­ã«ã‚‚imguiã‚’è¡¨ç¤ºã™ã‚‹
		DrawImgui();
		// ã‚²ãƒ¼ãƒ ã®æ›´æ–°ã‚’è¡Œã‚ãªã„
		return true;
	}
	
	return isPause_;
}

void PauseSystem::Draw()
{
	if (isPause_) {
		// ãƒãƒ¼ã‚ºç”»é¢
		pauseUI_->Draw();
	}
}

void PauseSystem::DrawImgui()
{
	if (isPause_) {
		pauseUI_->DrawImGui();
	}
}


============================================================
File Path: Game/Scene/Pause/PauseSystem.h
============================================================
#pragma once
#include <memory>
#include "engine/2d/Sprite.h"
#include "engine/math/MyMath.h"
#include "PauseUI.h"

class PauseSystem
{

public:
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize();


	/// <summary>
	/// true:ãƒãƒ¼ã‚ºä¸­ / false:ãƒãƒ¼ã‚ºè§£é™¤
	/// </summary>
	/// <returns></returns>
	bool Update();


	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();

	/// <summary>
	/// Pauseç”»é¢æç”»
	/// </summary>
	void DrawImgui();

public:
	// Getter / Setter
	bool GetPause() const { return isPause_; }


private:

	// ãƒãƒ¼ã‚ºä¸­ãƒ•ãƒ©ã‚°
	bool isPause_ = false;

	// ãƒãƒ¼ã‚ºUI
	std::unique_ptr<PauseUI> pauseUI_;
};



============================================================
File Path: Game/Scene/Pause/PauseUI.cpp
============================================================
#include "PauseUI.h"
#include "Input.h"
#include "ImGuiManager.h"


static float Clamp01(float x) {
	if (x < 0.0f) return 0.0f;
	if (x > 1.0f) return 1.0f;
	return x;
}

float PauseUI::GetBounceExtra()
{
	if (bounceT_ >= bounceDuration_) {
		return 0.0f;
	}

	// 60fpsæƒ³å®šã§é€²ã‚ã‚‹ï¼ˆdtãŒã‚ã‚‹ãªã‚‰ bounceT_ += dt; ã«ç½®ãæ›ãˆï¼‰
	bounceT_ += 1.0f / 60.0f;

	float t = Clamp01(bounceT_ / bounceDuration_); // 0â†’1
	float s = std::sinf(3.1415926f * t);           // 0â†’1â†’0

	// 1.10 â†’ 1.15 â†’ 1.10 ã«ã—ãŸã„ã®ã§ä¸Šä¹—ã›æœ€å¤§ +0.05
	return 0.05f * s;
}

PauseUI::Action PauseUI::ConsumeAction()
{
	PauseUI::Action action = pendingAction_;
	pendingAction_ = PauseUI::Action::None;
	return action;
}



void PauseUI::Initialize()
{
	// é¸æŠã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åˆæœŸåŒ–
	selectedSlot_ = Slot::Continue;
	// ãƒãƒ¼ã‚ºè§£é™¤è¦æ±‚ãƒ•ãƒ©ã‚°ã®åˆæœŸåŒ–
	requestPauseRelease_ = false;

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆèª­ã¿è¾¼ã¿
	LoadSprite();
}

void PauseUI::Update()
{
	// å…¥åŠ›å‡¦ç†
	HandleDirectionInput();
	// é¸æŠãŒå¤‰ã‚ã£ãŸç¬é–“ã ã‘ãƒã‚¦ãƒ³ã‚¹é–‹å§‹
	if (selectedSlot_ != prevSelectedSlot_) {
		prevSelectedSlot_ = selectedSlot_;
		bounceT_ = 0.0f; // ãƒã‚¦ãƒ³ã‚¹é–‹å§‹
	}


	// æ±ºå®šå…¥åŠ›å‡¦ç†
	HandleDecideInput();


	for (const auto& sprite : sprites_) {
		sprite->Update();
	}
	slotUIUp_->Update();
	slotUIDown_->Update();
	slotUILeft_->Update();
	slotUIRight_->Update();


	slotUIUp_->SetColor((selectedSlot_ == Slot::Continue) ? selectedSlotColor_ : normalSlotColor_);
	slotUIRight_->SetColor((selectedSlot_ == Slot::Retry) ? selectedSlotColor_ : normalSlotColor_);
	slotUIDown_->SetColor((selectedSlot_ == Slot::Title) ? selectedSlotColor_ : normalSlotColor_);
	slotUILeft_->SetColor((selectedSlot_ == Slot::StageSelect) ? selectedSlotColor_ : normalSlotColor_);

	slotTextUIUp_->Update();
	slotTextUIDown_->Update();
	slotTextUILeft_->Update();
	slotTextUIRight_->Update();

	decideKeyUI_->Update();

	// æ–¹å‘ï¼ˆå¤–å´ï¼‰ãƒ™ã‚¯ãƒˆãƒ«ï¼šä¸Š= (0,-1), å³=(1,0), ä¸‹=(0,1), å·¦=(-1,0)
	ApplySelectedStyle(slotUIUp_.get(), basePosUp_, baseSizeUp_,
		selectedSlot_ == Slot::Continue, { 0.0f, -1.0f });

	ApplySelectedStyle(slotUIRight_.get(), basePosRight_, baseSizeRight_,
		selectedSlot_ == Slot::Retry, { 1.0f,  0.0f });

	ApplySelectedStyle(slotUIDown_.get(), basePosDown_, baseSizeDown_,
		selectedSlot_ == Slot::Title, { 0.0f,  1.0f });

	ApplySelectedStyle(slotUILeft_.get(), basePosLeft_, baseSizeLeft_,
		selectedSlot_ == Slot::StageSelect, { -1.0f, 0.0f });


	// ImGuiã®æç”»
	DrawImGui();
}

void PauseUI::Draw()
{
	for (const auto& sprite : sprites_) {
		sprite->Draw();
	}

	// ã‚¹ãƒ­ãƒƒãƒˆUIæç”»
	slotUIUp_->Draw();
	slotUIDown_->Draw();
	slotUILeft_->Draw();
	slotUIRight_->Draw();
	// æ±ºå®šã‚­ãƒ¼UIæç”»
	decideKeyUI_->Draw();

	// é¸æŠä¸­ã®ã‚¹ãƒ­ãƒƒãƒˆãƒ†ã‚­ã‚¹ãƒˆæç”»
	switch (selectedSlot_)
	{
	case Slot::Continue:
		slotTextUIUp_->Draw();
		break;
	case Slot::Retry:
		slotTextUIRight_->Draw();
		break;
	case Slot::StageSelect:
		slotTextUILeft_->Draw();
		break;
	case Slot::Title:
		slotTextUIDown_->Draw();
		break;
	default:
		break;
	}
}

void PauseUI::LoadSprite()
{
	// ç”»é¢ã‚’å°‘ã—æš—ãã™ã‚‹é»’ã„ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	auto overlaySprite = std::make_unique<Sprite>();
	overlaySprite->Initialize("resources/PauseUI/PauseBlack.png");
	overlaySprite->SetPosition({ 0.0f,0.0f });
	overlaySprite->SetSize({ 1280.0f,720.0f });
	overlaySprite->SetColor({ 1.0f,1.0f,1.0f,0.55f });
	sprites_.push_back(std::move(overlaySprite));

	auto circleSlot = std::make_unique<Sprite>();
	circleSlot->Initialize("resources/PauseUI/PauseUICircleSlot_2.png");
	circleSlot->SetPosition({ 0.0f, 0.0f });
	circleSlot->SetSize({ 1280.0f,720.0f });
	sprites_.push_back(std::move(circleSlot));

	// ã‚¹ãƒ­ãƒƒãƒˆä¸Š
	slotUIUp_ = std::make_unique<Sprite>();
	slotUIUp_->Initialize("resources/PauseUI/PauseUISlotItemUP_IconB.png");
	slotUIUp_->SetPosition({ 0.0f, 0.0f });
	slotUIUp_->SetSize({ 1280.0f, 720.0f });


	// ã‚¹ãƒ­ãƒƒãƒˆä¸‹
	slotUIDown_ = std::make_unique<Sprite>();
	slotUIDown_->Initialize("resources/PauseUI/PauseUISlotItemDown_IconB.png");
	slotUIDown_->SetPosition({ 0.0f, 0.0f });
	slotUIDown_->SetSize({ 1280.0f, 720.0f });
	// ã‚¹ãƒ­ãƒƒãƒˆå·¦
	slotUILeft_ = std::make_unique<Sprite>();
	slotUILeft_->Initialize("resources/PauseUI/PauseUISlotItemLeft_IconB.png");
	slotUILeft_->SetPosition({ 0.0f, 0.0f });
	slotUILeft_->SetSize({ 1280.0f, 720.0f });
	// ã‚¹ãƒ­ãƒƒãƒˆå³
	slotUIRight_ = std::make_unique<Sprite>();
	slotUIRight_->Initialize("resources/PauseUI/PauseUISlotItemRight_IconB.png");
	slotUIRight_->SetPosition({ 0.0f, 0.0f });
	slotUIRight_->SetSize({ 1280.0f, 720.0f });



	basePosUp_ = slotUIUp_->GetPosition();
	baseSizeUp_ = slotUIUp_->GetSize();

	basePosRight_ = slotUIRight_->GetPosition();
	baseSizeRight_ = slotUIRight_->GetSize();

	basePosDown_ = slotUIDown_->GetPosition();
	baseSizeDown_ = slotUIDown_->GetSize();

	basePosLeft_ = slotUILeft_->GetPosition();
	baseSizeLeft_ = slotUILeft_->GetSize();


	slotTextUIUp_ = std::make_unique<Sprite>();
	slotTextUIUp_->Initialize("resources/PauseUI/PlayText.png");
	slotTextUIUp_->SetPosition({ 0.0f, 0.0f });
	slotTextUIUp_->SetSize({ 1280.0f, 720.0f });

	slotTextUIDown_ = std::make_unique<Sprite>();
	slotTextUIDown_->Initialize("resources/PauseUI/TitleText.png");
	slotTextUIDown_->SetPosition({ 0.0f, 0.0f });
	slotTextUIDown_->SetSize({ 1280.0f, 720.0f });

	slotTextUILeft_ = std::make_unique<Sprite>();
	slotTextUILeft_->Initialize("resources/PauseUI/SelectText.png");
	slotTextUILeft_->SetPosition({ 0.0f, 0.0f });
	slotTextUILeft_->SetSize({ 1280.0f, 720.0f });

	slotTextUIRight_ = std::make_unique<Sprite>();
	slotTextUIRight_->Initialize("resources/PauseUI/ReTryText.png");
	slotTextUIRight_->SetPosition({ 0.0f, 0.0f });
	slotTextUIRight_->SetSize({ 1280.0f, 720.0f });


	decideKeyUI_ = std::make_unique<Sprite>();
	decideKeyUI_->Initialize("resources/PauseUI/SpaceText.png");
	decideKeyUI_->SetPosition({ 0.0f, 0.0f });
	decideKeyUI_->SetSize({ 1280.0f, 720.0f });


}

void PauseUI::ApplySelectedStyle(Sprite* sp,
	const Vector2& basePos,
	const Vector2& baseSize,
	bool selected,
	const Vector2& outwardDir)
{
	float kScale = 1.0f;
	if (selected) {
		kScale = 1.10f + GetBounceExtra();
	}

	const float kNudge = selected ? 12.0f : 0.0f; // å¤–å´ã¸æŠ¼ã—å‡ºã—

	// ã‚µã‚¤ã‚ºå¤‰æ›´
	Vector2 size = { baseSize.x * kScale, baseSize.y * kScale };

	// å·¦ä¸ŠåŸºæº–ã®æ‹¡å¤§ã§ä¸­å¿ƒãŒã‚ºãƒ¬ã‚‹ã®ã‚’è£œæ­£ï¼ˆä¸­å¿ƒå›ºå®šï¼‰
	Vector2 pos = basePos;
	pos.x -= (size.x - baseSize.x) * 0.5f;
	pos.y -= (size.y - baseSize.y) * 0.5f;

	// å¤–å´ã¸å°‘ã—ãšã‚‰ã™ï¼ˆæ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ï¼‰
	pos.x += outwardDir.x * kNudge;
	pos.y += outwardDir.y * kNudge;

	sp->SetSize(size);
	sp->SetPosition(pos);
}


void PauseUI::DrawImGui()
{
#ifdef USE_IMGUI
	ImGui::Begin("Pause UI");

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®ã‚«ãƒ©ãƒ¼ã‚»ãƒƒãƒˆ


	for (const auto& sprite : sprites_) {
		Vector4 color = sprite->GetColor();
		ImGui::DragFloat4("Sprite Color", &color.x, 0.01f, 0.0f, 1.0f);
		sprite->SetColor(color);
	}


	// é¸æŠä¸­è¡¨ç¤º
	const uint32_t idx = static_cast<uint32_t>(selectedSlot_);
	ImGui::Text("Selected Slot: %u", idx);

	ImGui::Text("%s Continue (W)", (selectedSlot_ == Slot::Continue) ? ">" : " ");
	ImGui::Text("%s Retry (D)", (selectedSlot_ == Slot::Retry) ? ">" : " ");
	ImGui::Text("%s Stage Select (A)", (selectedSlot_ == Slot::StageSelect) ? ">" : " ");
	ImGui::Text("%s Title (S)", (selectedSlot_ == Slot::Title) ? ">" : " ");

	ImGui::Separator();
	ImGui::Text("Decide: SPACE / ENTER");
	ImGui::Text("ResumeRequested: %s", requestPauseRelease_ ? "true" : "false");


	ImGui::End();
#endif
}

bool PauseUI::PauseReleaseRequested()
{
	// ã™ã§ã«ãƒãƒ¼ã‚ºè§£é™¤è¦æ±‚ãŒå‡ºã¦ã„ã‚Œã°æŠœã‘ã‚‹
	if (!requestPauseRelease_) {
		return false;
	}
	// ãƒãƒ¼ã‚ºè§£é™¤è¦æ±‚ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
	requestPauseRelease_ = false;
	// ãƒãƒ¼ã‚ºè§£é™¤è¦æ±‚ã‚’è¿”ã™
	return true;
}

void PauseUI::HandleDecideInput()
{
	// ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ãªã‘ã‚Œã°æŠœã‘ã‚‹
	if (!Input::GetInstance()->TriggerKey(DIK_SPACE)) return;

	// é¸æŠä¸­ã®ã‚¹ãƒ­ãƒƒãƒˆã«å¿œã˜ãŸå‡¦ç†
	switch (selectedSlot_)
	{
	case Slot::Continue:
		pendingAction_ = Action::Continue;
		requestPauseRelease_ = true;
		break;
	case Slot::Retry:
		pendingAction_ = Action::Retry;
		break;
	case Slot::StageSelect:
		pendingAction_ = Action::StageSelect;
		break;
	case Slot::Title:
		pendingAction_ = Action::Title;
		break;

	default:
		break;
	}

}

void PauseUI::HandleDirectionInput()
{
	// å…¥åŠ›ã«ã‚ˆã£ã¦é¸æŠã‚¹ãƒ­ãƒƒãƒˆã‚’å¤‰æ›´
	if (Input::GetInstance()->TriggerKey(DIK_W)) {
		selectedSlot_ = Slot::Continue;
	} else if (Input::GetInstance()->TriggerKey(DIK_D)) {
		selectedSlot_ = Slot::Retry;
	} else if (Input::GetInstance()->TriggerKey(DIK_A)) {
		selectedSlot_ = Slot::StageSelect;
	} else if (Input::GetInstance()->TriggerKey(DIK_S)) {
		selectedSlot_ = Slot::Title;
	}
}



============================================================
File Path: Game/Scene/Pause/PauseUI.h
============================================================
#pragma once
#include <cstdint>
#include "Sprite.h"
#include <memory>
#include <vector>
#include <MyMath.h>
class PauseUI
{
	enum class Slot : uint32_t {
		// ä¸Š (W)
		Continue = 0,
		// å³ (D)
		Retry = 1,
		// å·¦ (A)
		StageSelect = 2,
		// ä¸‹ (S)
		Title = 3,
		Count
	};
	enum class UiAnimState { Idle, Decide };
public:
	enum class Action {
		None,
		Continue,
		Retry,
		StageSelect,
		Title
	};
public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();


	/// <summary>
	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆèª­ã¿è¾¼ã¿
	/// </summary>
	void LoadSprite();

	/// <summary>
	/// ImGuiã®æç”»
	/// </summary>
	void DrawImGui();

	/// <summary>
	/// ãƒãƒ¼ã‚ºã®è§£é™¤è¦æ±‚
	/// </summary>
	bool PauseReleaseRequested();

	/// <summary>
	/// æ±ºå®šå…¥åŠ›å‡¦ç†
	/// </summary>
	void HandleDecideInput();

	/// <summary>
	/// æ–¹å‘å…¥åŠ›å‡¦ç†
	/// </summary>
	void HandleDirectionInput();

	void ApplySelectedStyle(Sprite* sp,
		const Vector2& basePos,
		const Vector2& baseSize,
		bool selected,
		const Vector2& outwardDir);

	float GetBounceExtra();



public:	// Getter / Setter
	/// <summary>
	/// é¸æŠä¸­ã®ã‚¹ãƒ­ãƒƒãƒˆå–å¾—
	/// </summary>
	Slot GetSelectedSlot() const { return selectedSlot_; }

	Action ConsumeAction();

private:
	// ãƒ¡ãƒ‹ãƒ¥ãƒ¼é …ç›®æ•°
	Slot selectedSlot_ = Slot::Continue;

	Action pendingAction_ = Action::None;

	// ãƒãƒ¼ã‚ºè§£é™¤è¦æ±‚ãƒ•ãƒ©ã‚°
	bool requestPauseRelease_ = false;

	std::vector<std::unique_ptr<Sprite>> sprites_;

	// ã‚¹ãƒ­ãƒƒãƒˆUI
	std::unique_ptr<Sprite> slotUIUp_;
	std::unique_ptr<Sprite> slotUIDown_;
	std::unique_ptr<Sprite> slotUILeft_;
	std::unique_ptr<Sprite> slotUIRight_;

	// é¸æŠä¸­ã®ã‚¹ãƒ­ãƒƒãƒˆã®ãƒ†ã‚­ã‚¹ãƒˆã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::unique_ptr<Sprite> slotTextUIUp_;
	std::unique_ptr<Sprite> slotTextUIDown_;
	std::unique_ptr<Sprite> slotTextUILeft_;
	std::unique_ptr<Sprite> slotTextUIRight_;

	// Space
	std::unique_ptr<Sprite> decideKeyUI_;

	
	// é¸æŠæ™‚ã®ã‚¹ãƒ­ãƒƒãƒˆã®ã‚«ãƒ©ãƒ¼
	// PauseUI.h
	const Vector4 normalSlotColor_{ 1.0f, 1.0f, 1.0f, 1.0f };
	const Vector4 selectedSlotColor_{ 0.05f, 1.0f, 1.0f, 1.0f }; 

	// åŸºæº–ï¼ˆéé¸æŠï¼‰æ™‚ã®ä½ç½®ã¨ã‚µã‚¤ã‚ºã‚’ä¿å­˜ã—ã¦ãŠã
	Vector2 basePosUp_, basePosRight_, basePosDown_, basePosLeft_;
	Vector2 baseSizeUp_, baseSizeRight_, baseSizeDown_, baseSizeLeft_;

	UiAnimState uiAnimState_ = UiAnimState::Idle;

	Slot prevSelectedSlot_ = Slot::Continue;
	// ãƒã‚¦ãƒ³ã‚¹ç”¨
	float bounceT_ = 1.0f;        // 0â†’1ï¼ˆ1ãªã‚‰çµ‚äº†ï¼‰
	float bounceDuration_ = 0.10f; // ç§’ï¼ˆ0.08ã€œ0.12æ¨å¥¨ï¼‰

	

};



============================================================
File Path: Game/Scene/SceneSelectGraph/StageSelectGraph.cpp
============================================================
#include "StageSelectGraph.h"
#include <fstream>  

StageSelectGraph::StageSelectGraph()
{
}

StageSelectGraph::~StageSelectGraph()
{
}

void StageSelectGraph::Initialize()
{
	//// ãƒãƒ¼ãƒ‰ã®è¿½åŠ 

	// ãƒãƒ¼ãƒ‰æƒ…å ±ã‚’JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã¿è¾¼ã¿
	LoadMapNodeFromJson("World_1");
	// ãƒãƒ¼ãƒ‰å¢ƒç•Œæƒ…å ±ã®å†è¨ˆç®—     
	RecalculateBounds();


}


void StageSelectGraph::Finalize()
{
}

uint32_t StageSelectGraph::AddNode(MapPos pos, uint32_t stageId, const std::string& stageKey, bool unlocked, float defaultYaw)
{
	// æ–°ã—ã„ãƒãƒ¼ãƒ‰ã‚’ä½œæˆ
	StageNode newNode{};
	newNode.id = static_cast<uint32_t>(nodes_.size());
	newNode.position = pos;
	newNode.stageId = stageId;
	newNode.stageKey = stageKey;
	newNode.unlocked = unlocked;
	newNode.defaultYaw = defaultYaw;

	// å…¨æ–¹å‘ã®éš£æ¥ãƒãƒ¼ãƒ‰ã‚’ç„¡åŠ¹ã«è¨­å®š
	for (uint32_t i = 0; i < (uint32_t)Direction::count; i++) {
		newNode.neighbor[i] = INVALID_NODE_ID;
	}
	nodes_.push_back(newNode);
	// ãƒãƒ¼ãƒ‰å¢ƒç•Œæƒ…å ±ã®å†è¨ˆç®—
	RecalculateBounds();
	// è¿½åŠ ã—ãŸãƒãƒ¼ãƒ‰ã®IDã‚’è¿”ã™
	return newNode.id;
}




void StageSelectGraph::Link(uint32_t fromNodeId, uint32_t toNodeId, Direction dir)
{
	// ãƒãƒ¼ãƒ‰åŒå£«ã‚’æ¥ç¶š
	nodes_[fromNodeId].neighbor[(uint32_t)dir] = toNodeId;
	// é€†æ–¹å‘ã‚‚æ¥ç¶š
	Direction reverseDir{};
	switch (dir) {
	case Direction::Up:		reverseDir = Direction::Down;	break;
	case Direction::Down:	reverseDir = Direction::Up;		break;
	case Direction::Left:	reverseDir = Direction::Right;	break;
	case Direction::Right:	reverseDir = Direction::Left;	break;
	}

	// é€†æ–¹å‘ã®æ¥ç¶š
	nodes_[toNodeId].neighbor[(uint32_t)reverseDir] = fromNodeId;
}

uint32_t StageSelectGraph::Move(uint32_t currentNodeId, Direction dir) const
{
	// ç§»å‹•å…ˆãƒãƒ¼ãƒ‰IDã‚’å–å¾—
	uint32_t nextNodeId = nodes_[currentNodeId].neighbor[(uint32_t)dir];

	// æœªæ¥ç¶šã§ã‚ã‚Œã°ç¾åœ¨ã®ãƒãƒ¼ãƒ‰ã‚’è¿”ã™
	if (nextNodeId == INVALID_NODE_ID) {
		return currentNodeId;
	}
	// ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãŸã‚‰ç§»å‹•ã§ããªã„
	/*if (!nodes_[nextNodeId].unlocked) {
		return currentNodeId;
	}*/

	return nextNodeId;
}

const StageNode& StageSelectGraph::GetNode(uint32_t id) const
{

	return nodes_.at(id);

}

void StageSelectGraph::LoadMapNodeFromJson(const std::string& fileName)
{
	// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒãƒ¼ãƒ‰æƒ…å ±ã‚’èª­ã¿è¾¼ã‚€å‡¦ç†
	// filePathã¯ãƒªã‚½ãƒ¼ã‚¹ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹
	const std::string frontFilePath = "resources/WorldSelect";
	const std::string kExtension = ".json";
	const std::string fullPath = frontFilePath + "/" + fileName + kExtension;

	// ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
	std::ifstream file;

	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	file.open(fullPath);

	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãŸã‹ã©ã†ã‹
	if (file.fail()) {
		// ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ã¦çµ‚äº†
		printf("Failed to open file: %s\n", fullPath.c_str());
		return;
	}

	// JSONæ–‡å­—åˆ—
	nlohmann::json deserialized;
	// ãƒ‘ãƒ¼ã‚¹(è§£å‡)
	file >> deserialized;

	// ãƒãƒ¼ãƒ‰æƒ…å ±ã®ç¢ºèª
	assert(deserialized.contains("nodes"));
	assert(deserialized["nodes"].is_array());



	// æ—¢å­˜ãƒãƒ¼ãƒ‰æƒ…å ±ã®ã‚¯ãƒªã‚¢
	nodes_.clear();

	// -------- 1ãƒ‘ã‚¹ç›®ï¼šãƒãƒ¼ãƒ‰ç”Ÿæˆã®ã¿ --------
	for (const auto& jsonNode : deserialized["nodes"]) {
		// ãƒãƒ¼ãƒ‰æƒ…å ±ã®ç¢ºèª
		assert(jsonNode.contains("position"));
		assert(jsonNode["position"].contains("x"));
		assert(jsonNode["position"].contains("y"));
		assert(jsonNode["position"]["x"].is_number_integer());
		assert(jsonNode["position"]["y"].is_number_integer());

		assert(jsonNode.contains("stage_id"));
		assert(jsonNode["stage_id"].is_number_integer());
		assert(jsonNode.contains("stage_key"));
		assert(jsonNode["stage_key"].is_string());
		assert(jsonNode.contains("unlocked"));
		assert(jsonNode["unlocked"].is_boolean());

		// ãƒãƒ¼ãƒ‰æƒ…å ±ã®å–å¾—
		MapPos pos{};
		pos.x = jsonNode["position"]["x"].get<uint32_t>();
		pos.y = jsonNode["position"]["y"].get<uint32_t>();
		uint32_t stageId = jsonNode["stage_id"].get<uint32_t>();
		bool unlocked = jsonNode["unlocked"].get<bool>();
		std::string stageKey = jsonNode["stage_key"].get<std::string>();

		// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆYawæƒ…å ±ã®å–å¾—ï¼ˆå­˜åœ¨ã—ãªã„å ´åˆã¯è‡ªå‹•è¨ˆç®—ï¼‰
		float defaultYaw = AUTO_YAW;
		if (jsonNode.contains("default_yaw")) {
			if (jsonNode["default_yaw"].is_number()) {
				defaultYaw = jsonNode["default_yaw"].get<float>();
			}
		}

		// ãƒãƒ¼ãƒ‰ã®è¿½åŠ 
		AddNode(pos, stageId, stageKey, unlocked,defaultYaw);
	}

	// -------- 2ãƒ‘ã‚¹ç›®ï¼šneighbors è¨­å®š --------
	for (uint32_t i = 0; i < (uint32_t)nodes_.size(); ++i) {
		const auto& jsonNode = deserialized["nodes"][i];

		// neighborsæƒ…å ±ã®ç¢ºèª
		if (!jsonNode.contains("neighbors")) continue;
		assert(jsonNode["neighbors"].is_object());

		// neighborsæƒ…å ±ã®å–å¾—ã¨è¨­å®š
		for (const auto& it : jsonNode["neighbors"].items()) {
			const std::string& dirStr = it.key();
			uint32_t neighborId = it.value().get<uint32_t>();

			// æ–¹å‘ã®æ–‡å­—åˆ—ã‚’Directionåˆ—æŒ™å‹ã«å¤‰æ›
			Direction dir{};
			if (dirStr == "Up") dir = Direction::Up;
			else if (dirStr == "Down") dir = Direction::Down;
			else if (dirStr == "Left") dir = Direction::Left;
			else if (dirStr == "Right") dir = Direction::Right;
			else continue;

			// ç¯„å›²å¤–å‚ç…§ã®ä¿è­·
			if (neighborId >= nodes_.size()) continue;

			// éš£æ¥ãƒãƒ¼ãƒ‰ã®è¨­å®š
			SetNeighbor(i, dir, neighborId);
		}
	}



}


const char* DirectionToString(Direction d)
{
	switch (d) {
	case Direction::Up:    return "Up";
	case Direction::Down:  return "Down";
	case Direction::Left:  return "Left";
	case Direction::Right: return "Right";
	default:               return "Unknown";
	}
}


nlohmann::json StageSelectGraph::ToJson() const
{
	// json
	nlohmann::json root;
	// nodes 
	root["nodes"] = nlohmann::json::array();

	for (const auto& n : nodes_) {
		nlohmann::json jn;
		jn["position"] = { {"x",n.position.x},{"y",n.position.y} };
		jn["stage_id"] = n.stageId;
		jn["stage_key"] = n.stageKey;
		jn["unlocked"] = n.unlocked;
		if (n.defaultYaw != AUTO_YAW) {
			jn["default_yaw"] = n.defaultYaw;
		}
		nlohmann::json neigh = nlohmann::json::object();
		for (uint32_t i = 0; i < (uint32_t)Direction::count; i++) {
			uint32_t to = n.neighbor[i];
			if (to != INVALID_NODE_ID) {
				neigh[DirectionToString((Direction)i)] = to;
			}
		}
		jn["neighbors"] = neigh;

		root["nodes"].push_back(jn);
	}
	return root;
}

std::string StageSelectGraph::ToJsonString(int indent) const
{
	return ToJson().dump(indent);
}

void StageSelectGraph::SaveToJsonFile(const std::string& fileName) const
{
	// JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜ã™ã‚‹å‡¦ç†
	const std::string frontFilePath = "resources/StageSelect";
	const std::string kExtension = ".json";
	const std::string fullPath = frontFilePath + "/" + fileName + kExtension;
	// ãƒ•ã‚¡ã‚¤ãƒ«å‡ºåŠ›ã‚¹ãƒˆãƒªãƒ¼ãƒ ã‚’é–‹ã
	std::ofstream ofs(fullPath);
	// JSONæ–‡å­—åˆ—ã‚’æ›¸ãè¾¼ã‚€
	ofs << ToJsonString(2);
}

Vector2 StageSelectGraph::GetNodeUV(uint32_t nodeId) const
{
	// ãƒãƒ¼ãƒ‰IDã®ç¯„å›²ãƒã‚§ãƒƒã‚¯
	const StageNode& node = nodes_.at(nodeId);
	// ç¯„å›²è¨ˆç®—
	const float rangeX = (bounds_.max.x > bounds_.min.x) ? static_cast<float>(bounds_.max.x - bounds_.min.x) : 1.0f;
	const float rangeY = (bounds_.max.y > bounds_.min.y) ? static_cast<float>(bounds_.max.y - bounds_.min.y) : 1.0f;
	// UVåº§æ¨™è¨ˆç®—
	const float u = (static_cast<float>(node.position.x - bounds_.min.x)) / rangeX;
	const float v = (static_cast<float>(node.position.y - bounds_.min.y)) / rangeY;
	// è¿”å´
	return Vector2{ u,v };
}

void StageSelectGraph::RecalculateBounds()
{
	// ãƒãƒ¼ãƒ‰ã®å¢ƒç•Œæƒ…å ±ã‚’å†è¨ˆç®—ã™ã‚‹å‡¦ç†
	// ãƒãƒ¼ãƒ‰ãŒå­˜åœ¨ã—ãªã„å ´åˆã¯åˆæœŸåŒ–ã—ã¦çµ‚äº†
	if (nodes_.empty()) {
		bounds_ = {};
		return;
	}

	// æœ€å°ãƒ»æœ€å¤§åº§æ¨™ã‚’åˆæœŸåŒ–
	bounds_.min = nodes_[0].position;
	bounds_.max = nodes_[0].position;

	// å…¨ãƒãƒ¼ãƒ‰ã‚’èµ°æŸ»ã—ã¦æœ€å°ãƒ»æœ€å¤§åº§æ¨™ã‚’æ›´æ–°
	for (const auto& n : nodes_) {
		if (n.position.x < bounds_.min.x) bounds_.min.x = n.position.x;
		if (n.position.y < bounds_.min.y) bounds_.min.y = n.position.y;
		if (n.position.x > bounds_.max.x) bounds_.max.x = n.position.x;
		if (n.position.y > bounds_.max.y) bounds_.max.y = n.position.y;
	}

}



bool StageSelectGraph::SetNodePos(uint32_t id, MapPos pos)
{
	// IDã®ãƒã‚§ãƒƒã‚¯ / ç¯„å›²å¤–ãªã‚‰å¤±æ•—
	if (id >= nodes_.size()) return false;
	// åº§æ¨™ã®è¨­å®š
	nodes_[id].position = pos;
	// ãƒãƒ¼ãƒ‰å¢ƒç•Œæƒ…å ±ã®å†è¨ˆç®—
	RecalculateBounds();
	return true;
}


bool StageSelectGraph::SetNodeStageId(uint32_t id, uint32_t stageId)
{
	// IDã®ãƒã‚§ãƒƒã‚¯ / ç¯„å›²å¤–ãªã‚‰å¤±æ•—
	if (id >= nodes_.size()) return false;
	// ã‚¹ãƒ†ãƒ¼ã‚¸IDã®è¨­å®š
	nodes_[id].stageId = stageId;
	return true;
}

bool StageSelectGraph::SetNodeStageKey(uint32_t id, const std::string& stageKey)
{
	if (id >= nodes_.size()) return false;
	nodes_[id].stageKey = stageKey;
	return true;
}

bool StageSelectGraph::SetNodeUnlocked(uint32_t id, bool unlocked)
{
	// IDã®ãƒã‚§ãƒƒã‚¯ / ç¯„å›²å¤–ãªã‚‰å¤±æ•—
	if (id >= nodes_.size()) return false;
	// ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®è¨­å®š
	nodes_[id].unlocked = unlocked;
	return true;
}

bool StageSelectGraph::SetNodeYaw(uint32_t id, float yaw)
{
	// IDã®ãƒã‚§ãƒƒã‚¯ / ç¯„å›²å¤–ãªã‚‰å¤±æ•—
	if (id >= nodes_.size()) return false;
	// Yawè§’ã®è¨­å®š
	nodes_[id].defaultYaw = yaw;
	return true;
}

bool StageSelectGraph::SetNeighbor(uint32_t from, Direction dir, uint32_t toOrInvalid)
{
	// IDã®ãƒã‚§ãƒƒã‚¯ / ç¯„å›²å¤–ãªã‚‰å¤±æ•—
	if (from >= nodes_.size()) return false;
	// toãŒç„¡åŠ¹ãªãƒãƒ¼ãƒ‰IDã§ãªã„å ´åˆã€ç¯„å›²å¤–ãªã‚‰å¤±æ•—
	if (toOrInvalid != INVALID_NODE_ID && toOrInvalid >= nodes_.size()) return false;
	// éš£æ¥ãƒãƒ¼ãƒ‰ã®è¨­å®š
	nodes_[from].neighbor[(int)dir] = toOrInvalid;
	return true;
}


bool StageSelectGraph::ClearNeighbor(uint32_t from, Direction dir)
{
	// éš£æ¥ãƒãƒ¼ãƒ‰ã‚’ç„¡åŠ¹ã«è¨­å®š
	return SetNeighbor(from, dir, INVALID_NODE_ID);
}



============================================================
File Path: Game/Scene/SceneSelectGraph/StageSelectGraph.h
============================================================
#pragma once
#include "MyMath.h"
#include <vector>
#include <cstdint>
#include <resources/json/json.hpp>
#include <string>

/// <summary>
/// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã‚°ãƒ©ãƒ•
/// ã‚»ãƒ¬ã‚¯ãƒˆç”»é¢ã®ãƒã‚¹ã®ç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>

// ãƒãƒƒãƒ—ä¸Šã®ä½ç½®
struct MapPos
{
	uint32_t x;
	uint32_t y;
};

struct NodeBounds {
	MapPos min;
	MapPos max;
};

enum class Direction
{
	Up,
	Down,
	Left,
	Right,
	count
};

struct StageNode {
	// ãƒãƒ¼ãƒ‰ID
	uint32_t id;
	// ãƒãƒ¼ãƒ‰ã®ä½ç½®
	MapPos position;
	// ã‚¹ãƒ†ãƒ¼ã‚¸ID
	uint32_t stageId;
	std::string stageKey;
	// ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹
	bool unlocked;
	// éš£æ¥ãƒãƒ¼ãƒ‰IDé…åˆ— / èª­ã¿æ–¹ã¯ãƒã‚¤ãƒãƒ¼
	int32_t neighbor[(uint32_t)Direction::count];
	// ãƒãƒ¼ãƒ‰ã®å‘ãï¼ˆç§»å‹•é–‹å§‹å‰ã®Yawï¼‰
	float defaultYaw; 
};

/// <summary>
/// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã‚°ãƒ©ãƒ•
/// </summary>
class StageSelectGraph
{
public:
	// ç„¡åŠ¹ãªãƒãƒ¼ãƒ‰ID
	static const uint32_t INVALID_NODE_ID = UINT32_MAX;
	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®Yawå€¤ / ã“ã‚ŒãŒå…¥ã£ã¦ã„ã‚‹ã¨ãã¯è‡ªå‹•ã§å‘ãã‚’è¨ˆç®—ã™ã‚‹
	static constexpr float AUTO_YAW = -999.0f; 
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	StageSelectGraph();
	~StageSelectGraph();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize();


	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();

	/// <summary>
	/// ãƒãƒ¼ãƒ‰è¿½åŠ 
	/// </summary>
	/// <param name="pos">ãƒãƒ¼ãƒ‰ã®ä½ç½®</param>
	/// <param name="stageId">ã‚¹ãƒ†ãƒ¼ã‚¸ã®ID</param>
	/// <param name="unlocked">è§£æ”¾çŠ¶æ…‹ã‹</param>
	/// <returns>ã‚¹ãƒ†ãƒ¼ã‚¸IDã‚‚è¿”ã™</returns>
	uint32_t AddNode(MapPos pos,uint32_t stageId,const std::string& stageKey,bool unlocked,float defaultYaw = AUTO_YAW);

	/// <summary>
	/// ãƒãƒ¼ãƒ‰æ¥ç¶š
	/// </summary>
	/// <param name="fromNodeId">ç¹‹ã’å…ƒã®ãƒãƒ¼ãƒ‰</param>
	/// <param name="toNodeId">ç¹‹ã’å…ˆã®ãƒãƒ¼ãƒ‰</param>
	/// <param name="dir">ã©ã®æ–¹å‘ã«ã‚ã‚‹ã®ã‹</param>
	void Link(uint32_t fromNodeId, uint32_t toNodeId,Direction dir);
	
	/// <summary>
	/// ãƒãƒ¼ãƒ‰ç§»å‹•
	/// </summary>
	/// <param name="currentNodeId">ç§»å‹•å‰</param>
	/// <param name="dir">ç§»å‹•ã®æ–¹å‘</param>
	/// <returns></returns>
	uint32_t Move(uint32_t currentNodeId, Direction dir) const;
	
	/// <summary>
	/// ãƒãƒ¼ãƒ‰å–å¾—
	/// </summary>
	/// <param name="id">ã‚¹ãƒ†ãƒ¼ã‚¸ID</param>
	/// <returns></returns>
	const StageNode& GetNode(uint32_t id)const;

	/// <summary>
	/// jsonãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒãƒ¼ãƒ‰æƒ…å ±ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="jsonNode">èª­ã¿è¾¼ã‚€jsonãƒ•ã‚¡ã‚¤ãƒ«å</param>
	void LoadMapNodeFromJson(const std::string& fileName);

	/// <summary>
	/// JSONå½¢å¼ã«å¤‰æ›
	/// </summary>
	/// <returns></returns>
	nlohmann::json ToJson() const;

	/// <summary>
	/// JSONæ–‡å­—åˆ—ã«å¤‰æ›
	/// </summary>
	/// <param name="indent"></param>
	/// <returns></returns>
	std::string ToJsonString(int indent = 2) const;

	/// <summary>
	/// JSONãƒ•ã‚¡ã‚¤ãƒ«ã«ä¿å­˜
	/// </summary>
	/// <param name="fileName">ä¿å­˜ã™ã‚‹æ™‚ã®jsonãƒ•ã‚¡ã‚¤ãƒ«ã®åå‰</param>
	void SaveToJsonFile(const std::string& fileName) const;

	/// <summary>
	/// ãƒãƒ¼ãƒ‰ã®å¢ƒç•Œæƒ…å ±ã‚’å–å¾—
	/// </summary>
	/// <returns></returns>
	NodeBounds GetBounds()const { return bounds_; }

	/// <summary>
	/// ãƒãƒ¼ãƒ‰ã®UVåº§æ¨™ã‚’å–å¾—
	/// </summary>
	/// <param name="nodeId">ãƒãƒ¼ãƒ‰ã®åº§æ¨™</param>
	/// <returns>å¤‰æ›å¾Œã®åº§æ¨™</returns>
	Vector2 GetNodeUV(uint32_t nodeId) const;
private:
	/// <summary>
	/// ãƒãƒ¼ãƒ‰ã®å¢ƒç•Œæƒ…å ±ã‚’å†è¨ˆç®—
	/// </summary>
	void RecalculateBounds();

private:
	// ãƒãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ
	std::vector<StageNode> nodes_;

	// ãƒãƒ¼ãƒ‰ã®å¢ƒç•Œæƒ…å ±
	NodeBounds bounds_;

	

	
public:
	/// --- ç·¨é›†APIï¼ˆImGuiç”¨ï¼‰ --- ///
	// ãƒãƒ¼ãƒ‰æƒ…å ±ç·¨é›†
	bool SetNodePos(uint32_t id, MapPos pos);
	bool SetNodeStageId(uint32_t id, uint32_t stageId);
	bool SetNodeStageKey(uint32_t id, const std::string& stageKey);
	bool SetNodeUnlocked(uint32_t id, bool unlocked);
	bool SetNodeYaw(uint32_t id, float yaw);
	// éš£æ¥ãƒãƒ¼ãƒ‰ç·¨é›† / è¿½åŠ ãƒ»å‰Šé™¤
	bool SetNeighbor(uint32_t from, Direction dir, uint32_t toOrInvalid);
	bool ClearNeighbor(uint32_t from, Direction dir);
	// ãƒãƒ¼ãƒ‰æ•°å–å¾—
	uint32_t GetNodeCount() const { return (uint32_t)nodes_.size(); }


};



============================================================
File Path: Game/Scene/SceneTransition/SceneTransition.cpp
============================================================
#include "SceneTransition.h"
#ifdef USE_IMGUI
#include "engine/base/ImGuiManager.h"
#endif
#include "engine/2d/SpriteCommon.h"
#include "Input.h"

static inline float Clamp01(float x) { return x < 0.f ? 0.f : (x > 1.f ? 1.f : x); }
static inline float Lerp(float a, float b, float t) { return a + (b - a) * t; }
static inline float EaseInOut(float t) {
	return (t < 0.5f) ? (4.f * t * t * t) : (1.f - powf(-2.f * t + 2.f, 3.f) / 2.f);
}
static inline float EaseIn(float t) { return t * t * t; }
void SceneTransition::Initialize(uint32_t division, uint32_t totalFrame)
{
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆåˆ†å‰²æ•°ã‚’è¨­å®š
	spriteCount = division;

	totalFrames_ = std::max<uint32_t>(2, totalFrame);

	// In / Out ã‚’åŠåˆ†ãšã¤
	inFrames_ = totalFrames_ / 2 + (totalFrames_ % 2);
	outFrames_ = totalFrames_ / 2;

	phase_ = Phase::In;
	frame_ = 0;

	spriteDate = {
		// pos
		{0.0f,50.0f},
		// size
		{0.0f,0.0f},
		// rotate
		{0.0f},
		// color
		{1.0f,1.0f,1.0f,1.0f}
	};

	sprites.clear();
	sprites.reserve(spriteCount);

	const float w = 1280.0f / spriteCount;

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚«ã‚¦ãƒ³ãƒˆåˆ†ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	for (uint32_t i = 0; i < spriteCount; i++) {
		Sprite s;
		s.Initialize(textureFilePath);
		s.SetPosition({ i * w, 720.0f });

		// ã‚µã‚¤ã‚º / å·¦ç«¯ã‹ã‚‰å³ç«¯ã¾ã§å‡ç­‰ã«ä¸¦ã¹ã‚‹
		s.SetSize({ w,720.0f });

		s.SetColor({ 1.0f,1.0f,1.0f,1.0f });

		// ç™»éŒ²
		sprites.push_back(s);
	}

}

void SceneTransition::Update() {
	//// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ãƒ»ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã®å‡¦ç†
	//if (!isTransition) {
	//	for (size_t i = 0; i < sprites.size(); ++i) {
	//		auto& s = sprites[i];
	//		float delay = i * 10.0f; // æ®µéšçš„ãªé…å»¶
	//		// ç”»é¢ã‚’è¦†ã†ã¾ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	//		if (timer > delay && timer < delay + 75.0f) {
	//			Vector2 pos = s.GetPosition();
	//			pos.y -= 10.0f; // ä¸Šæ˜‡
	//			s.SetPosition(pos);
	//		}
	//		s.Update();
	//	}
	//	if (timer > 75.0f + (spriteCount - 1) * 10.0f) {
	//		isTransition = true;
	//		timer = 0.0f;
	//	}
	//} else {
	//	for (size_t i = 0; i < sprites.size(); ++i) {
	//		auto& s = sprites[i];
	//		float delay = i * 10.0f; // æ®µéšçš„ãªé…å»¶
	//		// ç”»é¢ã‚’è¦†ã†ã¾ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	//		if (timer > delay && timer < delay + 75.0f) {
	//			Vector2 pos = s.GetPosition();
	//			pos.y += 10.0f; // ä¸‹é™
	//			s.SetPosition(pos);
	//		}
	//		s.Update();
	//	}
	//	if (timer > 75.0f + (spriteCount - 1) * 10.0f) {
	//		isTransition = false;
	//		timer = 0.0f;
	//	}
	//}

	Imgui();

	auto updatePhase = [&](uint32_t phaseFrames, bool reverse) {
		float phaseT = (phaseFrames == 0) ? 1.0f :
			static_cast<float>(frame_) / static_cast<float>(phaseFrames);
		phaseT = Clamp01(phaseT);

		for (uint32_t i = 0; i < spriteCount; ++i) {
			auto& s = sprites[i];

			float p = Clamp01(phaseT * spriteCount - static_cast<float>(i));
			p = EaseInOut(p);

			// ã“ã“ã‚’ä¿®æ­£ â†“
			float startY = reverse ? 0.0f : 720.0f;
			float endY = reverse ? 720.0f : 0.0f;

			float y = Lerp(startY, endY, p);

			Vector2 pos = s.GetPosition();
			pos.y = y;
			s.SetPosition(pos);


			s.Update();
		}

		if (frame_ >= phaseFrames) { frame_ = 0; return true; }
		++frame_; return false;
		};
	switch (phase_) {
	case Phase::In:
		// ä¸Šæ–¹å‘ã¸ä¸ŠãŒã‚‹æ¼”å‡ºï¼ˆä»Šã¾ã§é€šã‚Šï¼‰
		if (updatePhase(inFrames_, /*reverse=*/false)) {
			// ä¸ŠãŒã‚Šãã£ãŸã‚‰ä¸€æ°—ã«ä¸‹ã’ã‚‹ãƒ•ã‚§ãƒ¼ã‚ºã¸
			phase_ = Phase::Out;
			frame_ = 0;
		}
		break;

	case Phase::Out:
	{
		// t: 0â†’1 ã‚’ outFrames_ ã§é€²ã‚ã‚‹
		float t = (outFrames_ == 0) ? 1.0f
			: static_cast<float>(frame_) / static_cast<float>(outFrames_);
		t = Clamp01(t);
		float te = EaseIn(t); // è½ä¸‹ã¯åŠ é€Ÿã•ã›ã‚‹

		// å…¨ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆåŒæ™‚ã«ã€Œä¸Š(0) â†’ ä¸‹(720)ã€ã¸è½ä¸‹
		for (auto& s : sprites) {
			Vector2 pos = s.GetPosition();
			float startY = pos.y;         // ç›´å‰ã®ä½ç½®ï¼ˆé€šå¸¸ã¯ 0ï¼‰
			float endY = 720.0f;        // ç”»é¢ä¸‹
			// startY ãŒ 0 ã§ãªã„çŠ¶æ³ã§ã‚‚ã‚¹ãƒ ãƒ¼ã‚ºã«è½ã¡ã‚‹ã‚ˆã†ã€Lerp ã‚’æ¯ãƒ•ãƒ¬ãƒ¼ãƒ é©ç”¨
			pos.y = Lerp(startY, endY, te);
			s.SetPosition(pos);
			s.Update();
		}

		if (frame_ >= outFrames_) {
			phase_ = Phase::Done; // totalFrame å†…ã¯ Draw ç¶™ç¶šï¼ˆDone ã§ã‚‚æç”»OKã«ã—ã¦ã„ã‚‹ãªã‚‰ãã®ã¾ã¾ï¼‰
			frame_ = 0;
		} else {
			++frame_;
		}
	}
	break;
	}

}



void SceneTransition::Draw()
{
	//sprite->Draw();

	for (auto& s : sprites) {
		s.Draw();
	}
}

void SceneTransition::Imgui()
{
#ifdef USE_IMGUI
	ImGui::Begin("SceneTransition Debug");

	ImGui::Text("=== çŠ¶æ…‹ ===");
	const char* phaseNames[] = { "In", "Out", "Done" };
	ImGui::Text("Phase : %s", phaseNames[static_cast<int>(phase_)]);
	ImGui::Text("Frame : %u / Total %u", frame_, totalFrames_);
	ImGui::Text("In  : %u  Out : %u", inFrames_, outFrames_);
	ImGui::Separator();

	// é€²è¡Œåº¦ãƒãƒ¼
	float normalized = 0.0f;
	switch (phase_) {
	case Phase::In:  normalized = static_cast<float>(frame_) / inFrames_;  break;
	case Phase::Out: normalized = static_cast<float>(frame_) / outFrames_; break;
	default: break;
	}
	ImGui::ProgressBar(normalized, ImVec2(200, 20));
	ImGui::Text("Progress : %.2f %%", normalized * 100.0f);

	ImGui::Separator();
	ImGui::Text("=== ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ ===");
	ImGui::DragInt("SpriteCount", reinterpret_cast<int*>(&spriteCount), 1, 1, 100);
	ImGui::DragInt("TotalFrames", reinterpret_cast<int*>(&totalFrames_), 1, 10, 600);
	ImGui::DragFloat("BaseY", &baseY_, 1.0f, -2000.0f, 2000.0f);
	ImGui::DragFloat("TravelY", &travelY_, 1.0f, 0.0f, 3000.0f);

	// å‹•ãã®ç¢ºèªã‚’ã—ã‚„ã™ãã™ã‚‹ãŸã‚ã®æ‰‹å‹•ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
	static float speed = 1.0f;
	ImGui::DragFloat("Speed Multiplier", &speed, 0.01f, 0.1f, 5.0f, "%.2fx");

	// ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
	if (ImGui::Button("Reset Transition")) {
		Initialize(spriteCount, totalFrames_);
	}

	// å¼·åˆ¶ãƒ•ã‚§ãƒ¼ã‚ºåˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³
	ImGui::Separator();
	if (ImGui::Button("Force -> In")) { phase_ = Phase::In;  frame_ = 0; }
	ImGui::SameLine();
	if (ImGui::Button("Force -> Out")) { phase_ = Phase::Out; frame_ = 0; }
	ImGui::SameLine();
	if (ImGui::Button("Force -> Done")) { phase_ = Phase::Done; }

	ImGui::Separator();
	ImGui::Text("=== å€‹åˆ¥ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæƒ…å ± ===");
	for (size_t i = 0; i < sprites.size(); ++i) {
		const Vector2& pos = sprites[i].GetPosition();
		ImGui::Text("Sprite[%zu] : Y = %.2f", i, pos.y);
	}

	ImGui::End();
#endif
}


float SceneTransition::RandomRange(float min, float max)
{
	static std::mt19937 mt{ std::random_device{}() };
	std::uniform_real_distribution<float> dist(min, max);
	return dist(mt);
}


============================================================
File Path: Game/Scene/SceneTransition/SceneTransition.h
============================================================
#pragma once
#include <memory>
#include "engine/3d/Object3D.h"
#include "engine/2d/Sprite.h"
#include <random>


class SceneTransition
{
	public:
	enum class Type {
		kNone,
		kFadeIn,
		kFadeOut,
	};

	enum class Phase {
		In, Out,Done
	};

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="division"></param>
	void Initialize(uint32_t division,uint32_t totalFrame);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();
	/// <summary>
	/// Imgui
	/// </summary>
	void Imgui();
	
	/// <summary>
	/// ãƒ©ãƒ³ãƒ€ãƒ ãªå®Ÿæ•°å€¤ã‚’ç”Ÿæˆ
	/// </summary>
	/// <param name="min"></param>
	/// <param name="max"></param>
	/// <returns></returns>
	float RandomRange(float min, float max);

	/// <summary>
	/// ãƒ•ã‚§ãƒ¼ã‚ºã‚’Doneã«è¨­å®š
	/// </summary>
	bool IsFinished() const { return phase_ == Phase::Done; }

	
private:
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿
	SpriteData spriteDate;
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::unique_ptr<Sprite> sprite;
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆé…åˆ—
	std::vector<Sprite> sprites;
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆåˆ†å‰²æ•°
	uint32_t spriteCount;
	
	// é€²è¡Œç®¡ç†
	Phase phase_ = Phase::In;

	uint32_t frame_ = 0;

	uint32_t totalFrames_ = 120;

	uint32_t inFrames_ = 60;
	uint32_t outFrames_ = 60;

	float baseY_ = 720.0f;
	float travelY_ = 1080.0f;



	std::string textureFilePath = "resources/Black.png";

};



============================================================
File Path: Game/Scene/StageClearScene.cpp
============================================================
#include "StageClearScene.h"
#include "Game/Camera/Camera.h"
#include "engine/InsideScene/Framework.h"
#include "Input.h"
#include "ImGuiManager.h"
#include <SpriteCommon.h>
using Engine::DirectXCommon;
StageClearScene::StageClearScene()
{
}

StageClearScene::~StageClearScene()
{
}

void StageClearScene::Initialize(DirectXCommon* dxCommon)
{
	SpriteCommon::GetInstance().Initialize(dxCommon);

	// ã‚«ãƒ¡ãƒ©ã®å–å¾—ã¨è¨­å®š
	camera = Framework::GetMainCamera();
	cameraTransform.translate = { 0.0f,-5.0f,4.0f };
	cameraTransform.rotate = { 0.0f,0.0f,0.0f };
	camera->SetTranslate(cameraTransform.translate);
	camera->SetRotate(cameraTransform.rotate);

	// @todo: ãŠç¥ã„æ„Ÿã®ã‚ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é™ã‚‰ã›ã‚‹


	backGround_ = std::make_unique<BackGround>();
	backGround_->Initialize();

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
	clearTextSprite = std::make_unique<Sprite>();
	clearTextSprite->Initialize("resources/ClearScene/StageClear.png");

	clearTextPos = { 0.0f,0.0f }; 
	clearTextSprite->SetPosition(clearTextPos);
	clearTextSprite->SetSize({ 1280.0f,720.0f });

	// playerObject_ã®åˆæœŸåŒ–
	playerObject_ = std::make_unique<Object3D>();
	playerObject_->Initialize();
	playerTransform_ = {
		{ 1.0f,1.0f,1.0f },
		{ 0.0f,0.0f,0.0f },
		{ 5.0f,-7.0f,20.0f }
	};
	playerObject_->SetTransform(playerTransform_);
	playerObject_->SetModel("Player.obj");


	// OneMore / Select / Title UI
	oneMore_ = std::make_unique<Sprite>();
	oneMore_->Initialize("resources/ClearScene/ClearUI_OneMore.png");
	oneMore_->SetPosition({ 250.0f,570.0f });
	oneMore_->SetSize(oneMoreBaseSize_);

	select_ = std::make_unique<Sprite>();
	select_->Initialize("resources/ClearScene/ClearUI_Select.png");
	select_->SetPosition({ 550.0f,570.0f });
	select_->SetSize(selectBaseSize_);

	title_ = std::make_unique<Sprite>();
	title_->Initialize("resources/ClearScene/ClearUI_Title.png");
	title_->SetPosition({ 850.0f,570.0f });
	title_->SetSize(titleBaseSize_);

	// KeyIconUiã€€/ å·¦ä¸‹ã«é…ç½®

	keyIcon_A = std::make_unique<Sprite>();
	keyIcon_A->Initialize("resources/KyeUI/A.png");
	keyIcon_A->SetPosition({ 30.0f, 635.0f });
	keyIcon_A->SetSize({ 50.0f, 50.0f });

	keyIcon_D = std::make_unique<Sprite>();
	keyIcon_D->Initialize("resources/KyeUI/D.png");
	keyIcon_D->SetPosition({ 80.0f, 635.0f });
	keyIcon_D->SetSize({ 50.0f, 50.0f });

	keyIcon_Enter = std::make_unique<Sprite>();
	keyIcon_Enter->Initialize("resources/KyeUI/Enter.png");
	keyIcon_Enter->SetPosition({ 55.0f, 565.0f });
	keyIcon_Enter->SetSize({ 50.0f, 50.0f });
}

void StageClearScene::Update()
{
	// ã‚«ãƒ¡ãƒ©ã®æ›´æ–°
	camera->Update();
	if(Input::GetInstance()->TriggerKey(DIK_A) || Input::GetInstance()->TriggerKey(DIK_LEFT)) {
		int idx = static_cast<int>(selectedItem_);
		idx = (idx - 1 + static_cast<int>(ClearMenuItem::Count)) % static_cast<int>(ClearMenuItem::Count);
		selectedItem_ = static_cast<ClearMenuItem>(idx);
	}
	// å³ã¸ï¼ˆD or â†’ï¼‰
	else if (Input::GetInstance()->TriggerKey(DIK_D) || Input::GetInstance()->TriggerKey(DIK_RIGHT)) {
		int idx = static_cast<int>(selectedItem_);
		idx = (idx + 1) % static_cast<int>(ClearMenuItem::Count);
		selectedItem_ = static_cast<ClearMenuItem>(idx);
	}

	// ========= æ±ºå®šï¼ˆEnter / Spaceï¼‰ =========
	if (Input::GetInstance()->TriggerKey(DIK_RETURN) ) {
		switch (selectedItem_) {
		case ClearMenuItem::OneMore:
			SceneManager::GetInstance()->ChangeScene("GAMEPLAY");     // ã‚‚ã†ä¸€å› = ä»Šã®ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ã‚„ã‚Šç›´ã™ãªã‚‰ GAMEPLAY
			break;
		case ClearMenuItem::Select:
			SceneManager::GetInstance()->ChangeScene("STAGESELECT");
			break;
		case ClearMenuItem::Title:
			SceneManager::GetInstance()->ChangeScene("TITLE");
			break;
		default:
			break;
		}
		return; // ã‚·ãƒ¼ãƒ³é·ç§»ã—ãŸã‚‰ä»¥é™ã®æ›´æ–°ã‚’æ­¢ã‚ãŸã„å ´åˆ
	}
	oneMore_->SetSize(oneMoreBaseSize_);
	select_->SetSize(selectBaseSize_);
	title_->SetSize(titleBaseSize_);
	
	// å›è»¢ã•ã›ã‚‹
	Vector3 rotate = playerObject_->GetRotate();
	rotate.z += -0.1f;
	playerObject_->SetRotate(rotate);

	// é¸æŠä¸­ã ã‘å°‘ã—å¤§ãã
	auto Scale = [](const Vector2& v, float s) { return Vector2{ v.x * s, v.y * s }; };

	switch (selectedItem_) {
	case ClearMenuItem::OneMore:
		oneMore_->SetSize(Scale(oneMoreBaseSize_, selectScale_));
		break;
	case ClearMenuItem::Select:
		select_->SetSize(Scale(selectBaseSize_, selectScale_));
		break;
	case ClearMenuItem::Title:
		title_->SetSize(Scale(titleBaseSize_, selectScale_));
		break;
	default:
		break;
	}
	//// ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹ (1)
	//if (Input::GetInstance()->TriggerKey(DIK_1)) {
	//	SceneManager::GetInstance()->ChangeScene("TITLE");
	//}
	//// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã¸æˆ»ã‚‹ (2)
	//else if (Input::GetInstance()->TriggerKey(DIK_2)) {
	//	SceneManager::GetInstance()->ChangeScene("STAGESELECT");
	//}
	//// ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã¸æˆ»ã‚‹ (3)
	//else if (Input::GetInstance()->TriggerKey(DIK_3)) {
	//	SceneManager::GetInstance()->ChangeScene("GAMEPLAY");
	//}

	playerObject_->Update();

	backGround_->Update();

	clearTextSprite->Update();


	keyIcon_A->Update();

	keyIcon_D->Update();
	keyIcon_Enter->Update();

	
	oneMore_->Update();
	select_->Update();
	title_->Update();

	// ImGuiã®æç”»
	DrawImgui();
}

void StageClearScene::Draw()
{
	backGround_->Draw();
	playerObject_->Draw();
	clearTextSprite->Draw();

	keyIcon_A->Draw();

	keyIcon_D->Draw();
	keyIcon_Enter->Draw();
	oneMore_->Draw();
	select_->Draw();
	title_->Draw();
}

void StageClearScene::Finalize()
{

}

void StageClearScene::DrawImgui()
{
#ifdef USE_IMGUI
	ImGui::Begin("StageClearScene");
	// ã‚·ãƒ¼ãƒ³é·ç§»ã®èª¬æ˜
	ImGui::Text("Press 1 to go to Title Scene");
	ImGui::Text("Press 2 to go to Stage Select Scene");
	ImGui::Text("Press 3 to go to Game Play Scene");

	// ã‚«ãƒ¡ãƒ©ä½ç½®ã®èª¿æ•´
	ImGui::DragFloat3("CameraPos", &cameraTransform.translate.x, 0.1f);
	ImGui::DragFloat3("CameraRot", &cameraTransform.rotate.x, 0.01f);
	camera->SetTranslate(cameraTransform.translate);
	camera->SetRotate(cameraTransform.rotate);

	ImGui::Separator();
	
	

	ImGui::End();
#endif
}


============================================================
File Path: Game/Scene/StageClearScene.h
============================================================
#pragma once
#include "engine/InsideScene/BaseScene.h"
#include "MyMath.h"
#include "Game/Application/BackGround.h"
#include <memory>
#include "MyMath.h"
#include "Sprite.h"
/// <summary>
/// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚¯ãƒªã‚¢ã‚·ãƒ¼ãƒ³
/// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚’ã‚¯ãƒªã‚¢ã—ãŸã¨ãã«è¡¨ç¤ºã•ã‚Œã‚‹ã‚·ãƒ¼ãƒ³
/// </summary>
class Object3D;
class Camera;
class StageClearScene :
    public BaseScene
{
	enum class ClearMenuItem {
		OneMore = 0,
		Select,
		Title,
		Count
	};

public:
	StageClearScene();
	~StageClearScene();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize(Engine::DirectXCommon* dxCommon)override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw()override;

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize()override;

	/// <summary>
	/// Imguiä¸€æ‹¬ç®¡ç†
	/// </summary>
	void DrawImgui();

private:
	/// ã‚«ãƒ¡ãƒ©
	Camera* camera = nullptr;
	Transform cameraTransform;
	// èƒŒæ™¯
	std::unique_ptr<BackGround> backGround_;
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3D>playerObject_;
	Transform playerTransform_;


	// ã‚¯ãƒªã‚¢ãƒ†ã‚­ã‚¹ãƒˆ
	std::unique_ptr<Sprite> clearTextSprite;
	Vector2 clearTextPos = {};

	// OneMore / Select / Title UI

	std::unique_ptr<Sprite> oneMore_;
	Vector2 oneMorePos;
	std::unique_ptr<Sprite> select_;
	Vector2 selectPos;
	std::unique_ptr<Sprite> title_;
	Vector2 titlePos;
	// é¸æŠã—ã¦ã„ã‚‹ã‚¢ã‚¤ãƒ†ãƒ 
	ClearMenuItem selectedItem_ = ClearMenuItem::OneMore;
	// é¸æŠæ™‚ã®æ‹¡ç¸®ç·¨é›†ç”¨Vector2
	Vector2 oneMoreBaseSize_ = { 200.0f, 90.0f };
	Vector2 selectBaseSize_ = { 200.0f, 90.0f };
	Vector2 titleBaseSize_ = { 200.0f, 90.0f };
	// é¸æŠæ™‚ã«ï¼˜ï¼…ç¨‹å¤§ããã™ã‚‹
	float selectScale_ = 1.08f;


	// kyeUI
	std::unique_ptr<Sprite> keyIcon_A;
	std::unique_ptr<Sprite> keyIcon_D;

	// enter
	std::unique_ptr<Sprite> keyIcon_Enter;
	Vector2 keyIcon_Enter_Pos = { 200.0f,650.0f };
};



============================================================
File Path: Game/Scene/StageSelectScene.cpp
============================================================
#include "StageSelectScene.h"
#include "engine/InsideScene/Framework.h"
#include "Game/Camera/Camera.h"
#include "engine/3d/Object3D.h"
#include "Game/Application/PlayContext.h"
#ifdef USE_IMGUI
#include "engine/base/ImGuiManager.h"
#endif

using namespace Engine;

// ========================================
// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
// ========================================

/// <summary>
/// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆã‚¢ã‚¦ãƒˆã‚­ãƒ¥ãƒ¼ãƒ“ãƒƒã‚¯ï¼‰
/// </summary>
static float EaseOutCubic(float t)
{
	float inv = 1.0f - t;
	return 1.0f - inv * inv * inv;
}

/// <summary>
/// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆã‚¤ãƒ³ã‚¢ã‚¦ãƒˆã‚­ãƒ¥ãƒ¼ãƒ“ãƒƒã‚¯ï¼‰
/// </summary>
static float EaseInOutCubic(float t)
{
	if (t < 0.5f)
		return 4.0f * t * t * t;
	else
	{
		float f = 2.0f * t - 2.0f;
		return 0.5f * f * f * f + 1.0f;
	}
}

/// <summary>
/// è§’åº¦ã‚’ 0 ~ 2Ï€ ã«æ­£è¦åŒ–
/// </summary>
static float WrapAngle0To2Pi(float angle)
{
	const float twoPi = 6.28318530718f;
	while (angle < 0.0f) angle += twoPi;
	while (angle >= twoPi) angle -= twoPi;
	return angle;
}

/// <summary>
/// è§’åº¦ã‚’ -Ï€ ~ Ï€ ã«æ­£è¦åŒ–
/// </summary>
static float WrapAngleMinusPiToPi(float a)
{
	const float pi = 3.14159265359f;
	const float twoPi = 6.28318530718f;
	while (a <= -pi) a += twoPi;
	while (a > pi)  a -= twoPi;
	return a;
}

/// <summary>
/// è§’åº¦ã®ç·šå½¢è£œé–“ï¼ˆæœ€çŸ­çµŒè·¯ï¼‰
/// </summary>
static float LerpAngle(float from, float to, float t)
{
	float delta = WrapAngleMinusPiToPi(to - from);
	return WrapAngle0To2Pi(from + delta * t);
}

// ========================================
// åº§æ¨™ãƒ»æ–¹å‘è¨ˆç®—
// ========================================

Vector3 StageSelectScene::CalcNodeWorldPos(uint32_t nodeId) const
{
	// ãƒãƒ¼ãƒ‰ã®UVåº§æ¨™ã‚’å–å¾—
	const Vector2 uv = stageSelectGraph->GetNodeUV(nodeId);

	// ãƒãƒƒãƒ—ã®è¡¨ç¤ºç¯„å›²ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰å˜ä½ï¼‰
	const float mapWidth = 40.0f;  // æ¨ªå¹…
	const float mapHeight = 20.0f;  // ç¸¦å¹…

	// ãƒãƒƒãƒ—ã®åŸºæº–ï¼ˆä¸­å¿ƒï¼‰ä½ç½®
	Vector3 origin = stageSelectBase1Transform.translate;
	origin.y = 1.0f; // ã‚«ãƒ¼ã‚½ãƒ«é«˜ã•

	// ãƒãƒ¼ãƒ‰ä½ç½®ã‚’ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã«å¤‰æ›
	Vector3 t = origin;
	t.x += (uv.x - 0.5f) * mapWidth;
	// ä¸Šä¸‹åè»¢æ¸ˆã¿ã®å¼
	t.z += (0.5f - uv.y) * mapHeight;

	return t;
}

float StageSelectScene::CalcYawToTarget(const Vector3& from, const Vector3& to) const
{
	// 2ç‚¹é–“ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
	Vector3 delta = to - from;
	delta.y = 0.0f; // Yè»¸ã¯ç„¡è¦–ï¼ˆæ°´å¹³æ–¹å‘ã®ã¿ï¼‰

	float len = std::sqrtf(delta.x * delta.x + delta.z * delta.z);
	if (len < 1e-6f) return 0.0f; // ã»ã¼åŒã˜ä½ç½®ãªã‚‰0ã‚’è¿”ã™

	// Yaw 0 ãŒ +Zæ–¹å‘ã®å ´åˆ
	float yaw = std::atan2f(delta.x, delta.z);

	// ãƒ¢ãƒ‡ãƒ«è£œæ­£ã‚’é©ç”¨
	yaw += modelYawOffset_;

	return WrapAngle0To2Pi(yaw);
}

float StageSelectScene::CalcYawFaceCamera(const Vector3& pos) const
{
	// ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’å–å¾—
	Vector3 camPos = cameraTransform.translate;

	// ã‚«ãƒ¡ãƒ©æ–¹å‘ã®ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
	Vector3 delta = camPos - pos;
	delta.y = 0.0f; // Yè»¸ã¯ç„¡è¦–

	float len = std::sqrtf(delta.x * delta.x + delta.z * delta.z);
	if (len < 1e-6f) return 0.0f;

	// Yaw 0 ãŒ +Zæ–¹å‘ã®å ´åˆ
	float yaw = std::atan2f(delta.x, delta.z);

	// ãƒ¢ãƒ‡ãƒ«è£œæ­£ã‚’é©ç”¨
	yaw += modelYawOffset_;

	return WrapAngle0To2Pi(yaw);
}

// ========================================
// ç§»å‹•ãƒ»å›è»¢æ›´æ–°
// ========================================

void StageSelectScene::UpdateCursorMove()
{
	// ç§»å‹•ä¸­ã§ãªã‘ã‚Œã°çµ‚äº†
	if (!isMoving_) return;

	// çµŒéæ™‚é–“ã‚’é€²ã‚ã‚‹
	const float dt = 1.0f / 60.0f;
	moveTime_ += dt;

	// é€²è¡Œåº¦ã‚’è¨ˆç®—ï¼ˆ0.0 ~ 1.0ï¼‰
	float t = moveTime_ / moveDuration_;
	if (t >= 1.0f) t = 1.0f;

	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã‚’é©ç”¨
	float ease = EaseInOutCubic(t);

	// ä½ç½®ã®è£œé–“
	Vector3 position = moveStartPos_ + (moveTargetPos_ - moveStartPos_) * ease;

	// å›è»¢ã®è£œé–“ï¼ˆé€²è¡Œæ–¹å‘ã‚’å‘ãï¼‰
	float yaw = LerpAngle(moveStartYaw_, moveTargetYaw_, ease);

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ å–å¾—
	Transform transform = playerModel->GetTransform();

	// ä½ç½®æ›´æ–°
	transform.translate = position;

	// å›è»¢æ›´æ–°ï¼ˆç§»å‹•ä¸­ã¯é€²è¡Œæ–¹å‘ã‚’å‘ãï¼‰
	transform.rotate.y = yaw;
	transform.rotate.x = 0.0f;  // ç§»å‹•ä¸­ã¯å‚¾ã‘ãªã„
	transform.rotate.z = 0.0f;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®æ›´æ–°
	playerModel->SetTransform(transform);

#ifdef USE_IMGUI
	// â†“ç¾åœ¨ã®Yawè§’ã‚’æ›´æ–°
	debugCurrentYawDeg_ = yaw * 57.2957795f;
#endif

	// ç§»å‹•å®Œäº†
	if (t >= 1.0f)
	{
		// ç§»å‹•ãƒ•ãƒ©ã‚°ã‚’ä¸‹ã‚ã™
		isMoving_ = false;

		// ã‚«ãƒ¡ãƒ©æ–¹å‘ã‚’å‘ãå‡¦ç†ã‚’é–‹å§‹
		const StageNode& targetNode = stageSelectGraph->GetNode(currentNodeId);

		// ã‚«ãƒ¡ãƒ©æ–¹å‘ã‚’å‘ãå‡¦ç†ã‚’é–‹å§‹
		isFacing_ = true;
		faceTime_ = 0.0f;
		faceStartYaw_ = yaw;

		// ãƒãƒ¼ãƒ‰ã«defaultYawãŒè¨­å®šã•ã‚Œã¦ã„ã‚Œã°ãã‚Œã‚’ä½¿ç”¨ã€ãªã‘ã‚Œã°ã‚«ãƒ¡ãƒ©æ–¹å‘
		if (targetNode.defaultYaw != StageSelectGraph::AUTO_YAW) {
			faceTargetYaw_ = targetNode.defaultYaw;
		} else {
			faceTargetYaw_ = CalcYawFaceCamera(moveTargetPos_);
		}
	}
}

void StageSelectScene::UpdateFaceYaw()
{
	// ã‚«ãƒ¡ãƒ©ã‚’å‘ã„ã¦ã„ãªã„å ´åˆã¯çµ‚äº†
	if (!isFacing_) return;

	// çµŒéæ™‚é–“ã‚’é€²ã‚ã‚‹
	const float dt = 1.0f / 60.0f;
	faceTime_ += dt;

	// é€²è¡Œåº¦ã‚’è¨ˆç®—
	float t = faceTime_ / faceDuration_;
	if (t >= 1.0f) t = 1.0f;

	// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°ã‚’é©ç”¨
	float ease = EaseOutCubic(t);

	// Yawè£œé–“ã‚’åæ˜ 
	float yaw = LerpAngle(faceStartYaw_, faceTargetYaw_, ease);

	// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ å–å¾—
	Transform tr = playerModel->GetTransform();

	// Yawè§’ã‚’è¨­å®š
	tr.rotate.y = yaw;
	tr.rotate.x = 0.0f;
	tr.rotate.z = 0.0f;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®æ›´æ–°
	playerModel->SetTransform(tr);

	// å›è»¢å®Œäº†
	if (t >= 1.0f)
	{
		isFacing_ = false;
	}
}

// ========================================
// å…¥åŠ›å‡¦ç†
// ========================================

void StageSelectScene::HandleSelectInput()
{
	// ç§»å‹•ä¸­ãƒ»å›è»¢ä¸­ã¯å…¥åŠ›ã‚’å—ã‘ä»˜ã‘ãªã„
	if (isMoving_ || isFacing_) return;

	// ç¾åœ¨ã®ãƒãƒ¼ãƒ‰IDã‚’ä¿å­˜
	uint32_t next = currentNodeId;

	// å…¥åŠ›ã—ãŸæ–¹å‘ã«ç§»å‹•ã§ãã‚‹ãƒãƒ¼ãƒ‰ãŒã‚ã‚Œã°ç§»å‹•
	if (Input::GetInstance()->TriggerKey(DIK_W)) {
		next = stageSelectGraph->Move(currentNodeId, Direction::Up);
	} else if (Input::GetInstance()->TriggerKey(DIK_S)) {
		next = stageSelectGraph->Move(currentNodeId, Direction::Down);
	} else if (Input::GetInstance()->TriggerKey(DIK_A)) {
		next = stageSelectGraph->Move(currentNodeId, Direction::Left);
	} else if (Input::GetInstance()->TriggerKey(DIK_D)) {
		next = stageSelectGraph->Move(currentNodeId, Direction::Right);
	}

	// ãƒãƒ¼ãƒ‰ãŒå¤‰ã‚ã‚‰ãªã‘ã‚Œã°ä½•ã‚‚ã—ãªã„
	if (next == currentNodeId) return;

	// ç§»å‹•é–‹å§‹
	currentNodeId = next;
	isMoving_ = true;
	moveTime_ = 0.0f;

	// ãƒãƒ¼ãƒ‰æ›´æ–°
	Transform transform = playerModel->GetTransform();
	moveStartPos_ = transform.translate;
	moveTargetPos_ = CalcNodeWorldPos(next);

	// ç¾åœ¨ã®Yawã¨ç›®æ¨™Yawï¼ˆé€²è¡Œæ–¹å‘ï¼‰ã‚’è¨ˆç®—
	moveStartYaw_ = transform.rotate.y;
	moveTargetYaw_ = CalcYawToTarget(moveStartPos_, moveTargetPos_);

#ifdef USE_IMGUI
	// â†“ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’ä¿å­˜
	Vector3 direction = moveTargetPos_ - moveStartPos_;
	direction.y = 0.0f;
	debugDirection_ = direction;
	debugMoveDistance_ = std::sqrtf(direction.x * direction.x + direction.z * direction.z);
	debugStartYawDeg_ = moveStartYaw_ * 57.2957795f;
	debugTargetYawDeg_ = moveTargetYaw_ * 57.2957795f;
	debugYawChangeDeg_ = (moveTargetYaw_ - moveStartYaw_) * 57.2957795f;
#endif
}

void StageSelectScene::ApplyNodeToCursorTransform()
{
	// çµ¶å¯¾åº§æ¨™ã§ã‚»ãƒƒãƒˆ
	Transform tr = playerModel->GetTransform();
	tr.translate = CalcNodeWorldPos(currentNodeId);

	// åˆæœŸçŠ¶æ…‹ã§ã¯ã‚«ãƒ¡ãƒ©ã®æ–¹ã‚’å‘ã
	tr.rotate.y = CalcYawFaceCamera(tr.translate);
	tr.rotate.x = 0.0f;
	tr.rotate.z = 0.0f;

	playerModel->SetTransform(tr);
}

void StageSelectScene::BuildRoutes()
{
	// ãƒ«ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ã®ã‚¯ãƒªã‚¢
	routeModels_.clear();
	routeTransforms_.clear();

	const uint32_t count = stageSelectGraph->GetNodeCount();
	if (count == 0) return;

	for (uint32_t i = 0; i < count; ++i)
	{
		const StageNode& n = stageSelectGraph->GetNode(i);

		for (int d = 0; d < (int)Direction::count; ++d)
		{
			uint32_t to = n.neighbor[d];
			if (to == StageSelectGraph::INVALID_NODE_ID) continue;

			// é‡è¤‡ç”Ÿæˆé˜²æ­¢ï¼ˆi->to ã¨ to->i ã‚’1æœ¬ã«ã™ã‚‹ï¼‰
			if (to < i) continue;

			// ç«¯ç‚¹ï¼ˆãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ï¼‰
			Vector3 a = CalcNodeWorldPos(i);
			Vector3 b = CalcNodeWorldPos(to);

			// å°‘ã—æµ®ã‹ã›ã‚‹ï¼ˆåºŠã«åŸ‹ã¾ã‚‰ãªã„ã‚ˆã†ã«ï¼‰
			a.y += 0.05f;
			b.y += 0.05f;

			Vector3 diff = b - a;
			diff.y = 0.0f;

			// ä¸­ç‚¹ã‚’è¨ˆç®—
			Vector3 mid = (a + b) * 0.5f;

			// yawï¼ˆYaw 0 ãŒ +Z å‰æï¼‰
			float yaw = std::atan2f(diff.x, diff.z);

			// Object3Dä½œæˆ
			auto obj = std::make_unique<Object3D>();
			obj->Initialize();
			obj->SetModel("RoutePlane.obj"); // ãƒ«ãƒ¼ãƒˆç”¨ãƒ¢ãƒ‡ãƒ«å

			Transform tr{};
			tr.translate = mid;
			tr.translate.y -= 1.0f; // å°‘ã—æµ®ã‹ã›ã‚‹
			tr.rotate = { 0.0f, yaw, 0.0f };
			tr.scale = { 0.5f, 0.5f, 1.0f };

			obj->SetTransform(tr);

			routeTransforms_.push_back(tr);
			routeModels_.push_back(std::move(obj));
		}
	}
}

// ========================================
// åˆæœŸåŒ–ãƒ»æ›´æ–°ãƒ»æç”»
// ========================================

StageSelectScene::StageSelectScene()
{
}

StageSelectScene::~StageSelectScene()
{
}

void StageSelectScene::Initialize(DirectXCommon* dxCommon)
{
	// ã‚«ãƒ¡ãƒ©ã®å–å¾—
	camera = Framework::GetMainCamera();
	cameraTransform.translate = { 0.0f,20.0f,0.0f };
	cameraTransform.rotate = { 0.35f,0.0f,0.0f };
	camera->SetTranslate(cameraTransform.translate);
	camera->SetRotate(cameraTransform.rotate);

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ–
	playerModel = std::make_unique<Object3D>();
	playerModel->Initialize();
	playerModel->SetModel("Player.obj");
	playerTransform = {
		// scale
		{2.5f,2.5f,2.5f},
		// rotate
		{0.0f,0.0f,0.0f},
		// translate
		{-20.0f,1.0f,50.0f},
	};
	playerModel->SetTransform(playerTransform);

	// èƒŒæ™¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ–
	stageSelectBase1 = std::make_unique<Object3D>();
	stageSelectBase1->Initialize();
	stageSelectBase1->SetModel("SelectBaseGround.obj");
	stageSelectBase1Transform = {
		// Scale
		{ 1.5f, 1.0f, 2.5f },
		// Rotate
		{ 0.0f, 0.0f, 0.0f },
		// Translate
		{ 0.0f, 0.0f, 50.0f }
	};
	stageSelectBase1->SetTransform(stageSelectBase1Transform);

	// ç©ºèƒŒæ™¯ã®åˆæœŸåŒ–
	skyBack = std::make_unique<Object3D>();
	skyBack->Initialize();
	skyBack->SetModel("BackSky.obj");
	skyBackTransform = {
		// Scale
		{ 50.0f, 50.0f, 40.0f },
		// Rotate
		{ 3.2f, 0.0f, 0.0f },
		// Translate
		{ 0.0f, 0.0f, 100.0f }
	};
	skyBack->SetTransform(skyBackTransform);

	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã‚°ãƒ©ãƒ•ã®åˆæœŸåŒ–
	stageSelectGraph = std::make_unique<StageSelectGraph>();
	stageSelectGraph->Initialize();

	// ãƒ«ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ã®æ§‹ç¯‰
	BuildRoutes();

	// ãƒãƒ¼ãƒ‰ã®è¿½åŠ 
	startNodeId = 0;
	currentNodeId = startNodeId;

	// ã‚«ãƒ¼ã‚½ãƒ«ã‚’åˆæœŸä½ç½®ã«é…ç½®
	ApplyNodeToCursorTransform();

	// ãƒãƒ¼ãƒ‰ãƒ¢ãƒ‡ãƒ«ç”Ÿæˆ
	const uint32_t count = stageSelectGraph->GetNodeCount();
	nodeModels_.clear();
	nodeTransforms_.clear();
	nodeModels_.reserve(count);
	nodeTransforms_.reserve(count);

	for (uint32_t i = 0; i < count; ++i)
	{
		auto obj = std::make_unique<Object3D>();
		obj->Initialize();
		obj->SetModel("Node.obj"); // åŒã˜ãƒ¢ãƒ‡ãƒ«

		Transform tr{};
		tr.scale = { 1.8f, 1.8f, 1.8f };   // ç›®å°ãªã‚‰å°‘ã—å°ã•ã
		tr.rotate = { 0.0f, 0.0f, 0.0f };
		tr.translate = CalcNodeWorldPos(i);

		// ã¡ã‚‡ã„æµ®ã‹ã›ãŸã„ãªã‚‰
		tr.translate.y += -1.1f; // ä¾‹: 0.3f

		// ã€Œå¸¸ã«ã‚«ãƒ¡ãƒ©å‘ãã€ã«ã—ãŸã„ãªã‚‰
		tr.rotate.y = CalcYawFaceCamera(tr.translate);

		obj->SetTransform(tr);

		nodeTransforms_.push_back(tr);
		nodeModels_.push_back(std::move(obj));
	}

	// UIåˆæœŸåŒ–
	stageSelect_ = std::make_unique<Sprite>();
	stageSelect_->Initialize("resources/StageSelect/StageSelect.png");
	stageSelect_->SetPosition({ 0.0f,0.0f });
	stageSelect_->SetSize({ 1280.0f,720.0f });

	// KeyIconUi / å·¦ä¸‹ã«é…ç½®
	keyIcon_W = std::make_unique<Sprite>();
	keyIcon_W->Initialize("resources/KyeUI/W.png");
	keyIcon_W->SetPosition({ 55.0f, 615.0f });
	keyIcon_W->SetSize({ 50.0f, 50.0f });

	keyIcon_A = std::make_unique<Sprite>();
	keyIcon_A->Initialize("resources/KyeUI/A.png");
	keyIcon_A->SetPosition({ 10.0f, 635.0f });
	keyIcon_A->SetSize({ 50.0f, 50.0f });

	keyIcon_S = std::make_unique<Sprite>();
	keyIcon_S->Initialize("resources/KyeUI/S.png");
	keyIcon_S->SetPosition({ 55.0f, 660.0f });
	keyIcon_S->SetSize({ 50.0f, 50.0f });

	keyIcon_D = std::make_unique<Sprite>();
	keyIcon_D->Initialize("resources/KyeUI/D.png");
	keyIcon_D->SetPosition({ 100.0f, 635.0f });
	keyIcon_D->SetSize({ 50.0f, 50.0f });

	// esc / enter UIé…ç½®
	keyIcon_Esc = std::make_unique<Sprite>();
	keyIcon_Esc->Initialize("resources/KyeUI/Esc.png");
	keyIcon_Esc->SetPosition({ 55.0f, 560.0f });
	keyIcon_Esc->SetSize({ 50.0f, 50.0f });

	keyIcon_Enter = std::make_unique<Sprite>();
	keyIcon_Enter->Initialize("resources/KyeUI/Enter.png");
	keyIcon_Enter->SetPosition({ 55.0f, 505.0f });
	keyIcon_Enter->SetSize({ 50.0f, 50.0f });

	// MoveUI
	moveUI_ = std::make_unique<Sprite>();
	moveUI_->Initialize("resources/StageSelect/Move.png");
	moveUI_->SetPosition(moveUI_Pos_);
	moveUI_->SetSize({ 125.0f,50.0f });

	// CheckUI
	checkUI_ = std::make_unique<Sprite>();
	checkUI_->Initialize("resources/StageSelect/Check.png");
	checkUI_->SetPosition(checkUI_Pos_);
	checkUI_->SetSize({ 125.0f,50.0f });

	// BackUI
	backUI_ = std::make_unique<Sprite>();
	backUI_->Initialize("resources/StageSelect/Back.png");
	backUI_->SetPosition(backUI_Pos_);
	backUI_->SetSize({ 125.0f,50.0f });
}

void StageSelectScene::Update()
{
	// Enterã‚­ãƒ¼ã§ã‚¹ãƒ†ãƒ¼ã‚¸é–‹å§‹
	if (Input::GetInstance()->TriggerKey(DIK_RETURN)) {
		const StageNode& node = stageSelectGraph->GetNode(currentNodeId);
		PlayContext::GetInstance().SetSelectedStage(node.stageId, node.stageKey);

		// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚·ãƒ¼ãƒ³ã¸åˆ‡ã‚Šæ›¿ãˆ
		SceneManager::GetInstance()->ChangeScene("GAMEPLAY");
	}

	// Escapeã‚­ãƒ¼ã§ã‚¿ã‚¤ãƒˆãƒ«ã¸
	if (Input::GetInstance()->TriggerKey(DIK_ESCAPE)) {
		// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ã¸åˆ‡ã‚Šæ›¿ãˆ
		SceneManager::GetInstance()->ChangeScene("TITLE");
	}

	// ç©ºèƒŒæ™¯ã®æ›´æ–°
	skyBack->Update();

	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆåœŸå°ã®æ›´æ–°
	stageSelectBase1->Update();

	// ãƒãƒ¼ãƒ‰ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
	for (auto& m : nodeModels_) { m->Update(); }

	// ãƒ«ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
	for (auto& m : routeModels_) { m->Update(); }

	// å…¥åŠ›ã—ãŸæ–¹å‘ã«ç§»å‹• 
	HandleSelectInput();

	// ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•æ›´æ–°
	UpdateCursorMove();

	// åœæ­¢å¾Œã®å‘ãè£œé–“æ›´æ–°
	UpdateFaceYaw();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•å‡¦ç†
	PlayerMove();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
	playerModel->Update();

	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆUIã®æ›´æ–°
	stageSelect_->Update();

	// KeyUIã®æ›´æ–°
	keyIcon_W->Update();
	keyIcon_A->Update();
	keyIcon_S->Update();
	keyIcon_D->Update();
	keyIcon_Esc->Update();
	keyIcon_Enter->Update();

	// Move / Check / Back UIã®æ›´æ–°
	moveUI_->Update();
	checkUI_->Update();
	backUI_->Update();

	// ImGuiã®æç”»
	DrawImgui();
}

void StageSelectScene::Draw()
{
	// ç©ºèƒŒæ™¯ã®æç”»
	skyBack->Draw();

	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆåœŸå°ã®æç”»
	stageSelectBase1->Draw();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ‡ãƒ«ã®æç”»
	playerModel->Draw();

	// ãƒãƒ¼ãƒ‰ãƒ¢ãƒ‡ãƒ«ã®æç”»
	for (auto& m : nodeModels_) { m->Draw(); }

	// ãƒ«ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ã®æç”»
	for (auto& m : routeModels_) { m->Draw(); }

	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆUIã®æç”»
	stageSelect_->Draw();

	// KeyUIã®æç”»
	keyIcon_W->Draw();
	keyIcon_A->Draw();
	keyIcon_S->Draw();
	keyIcon_D->Draw();
	keyIcon_Esc->Draw();
	keyIcon_Enter->Draw();

	// Move / Check / Back UIã®æç”»
	moveUI_->Draw();
	checkUI_->Draw();
	backUI_->Draw();
}

void StageSelectScene::Finalize()
{
}

void StageSelectScene::PlayerMove()
{
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åº§æ¨™å–å¾—
	Transform transform = playerModel->GetTransform();

	// å¿…è¦ã«å¿œã˜ã¦å‡¦ç†ã‚’è¿½åŠ 
	playerModel->SetTransform(transform);
}

void StageSelectScene::DrawImgui()
{
#ifdef USE_IMGUI
	ImGui::Begin("StageSelectScene");

	// ã‚«ãƒ¡ãƒ©ä½ç½®ã®èª¿æ•´
	ImGui::DragFloat3("CameraPos", &cameraTransform.translate.x, 0.1f);
	ImGui::DragFloat3("CameraRot", &cameraTransform.rotate.x, 0.01f);
	camera->SetTranslate(cameraTransform.translate);
	camera->SetRotate(cameraTransform.rotate);

	ImGui::Separator();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	Transform transform = playerModel->GetTransform();
	ImGui::DragFloat3("PlayerPos", &transform.translate.x, 0.1f);
	ImGui::DragFloat3("PlayerRot", &transform.rotate.x, 0.1f);
	ImGui::DragFloat3("PlayerScale", &transform.scale.x, 0.1f);
	playerModel->SetTransform(transform);

	ImGui::Separator();

	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆåœŸå°ï¼‘
	stageSelectBase1Transform = stageSelectBase1->GetTransform();
	ImGui::DragFloat3("StageSelectBase1Pos", &stageSelectBase1Transform.translate.x, 0.1f);
	ImGui::DragFloat3("StageSelectBase1Rot", &stageSelectBase1Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("StageSelectBase1Scale", &stageSelectBase1Transform.scale.x, 0.1f);
	stageSelectBase1->SetTransform(stageSelectBase1Transform);

	ImGui::Separator();

	// ç©ºèƒŒæ™¯
	skyBackTransform = skyBack->GetTransform();
	ImGui::DragFloat3("SkyBackPos", &skyBackTransform.translate.x, 0.1f);
	ImGui::DragFloat3("SkyBackRot", &skyBackTransform.rotate.x, 0.1f);
	ImGui::DragFloat3("SkyBackScale", &skyBackTransform.scale.x, 0.1f);
	skyBack->SetTransform(skyBackTransform);

	ImGui::Separator();

	// UIKeyIconé…ç½®å¤‰æ›´
	keyIcon_W_Pos = keyIcon_W->GetPosition();
	keyIcon_A_Pos = keyIcon_A->GetPosition();
	keyIcon_S_Pos = keyIcon_S->GetPosition();
	keyIcon_D_Pos = keyIcon_D->GetPosition();
	keyIcon_Esc_Pos = keyIcon_Esc->GetPosition();
	keyIcon_Enter_Pos = keyIcon_Enter->GetPosition();

	ImGui::DragFloat2("KeyIcon_W_Pos", &keyIcon_W_Pos.x, 1.0f);
	ImGui::DragFloat2("KeyIcon_A_Pos", &keyIcon_A_Pos.x, 1.0f);
	ImGui::DragFloat2("KeyIcon_S_Pos", &keyIcon_S_Pos.x, 1.0f);
	ImGui::DragFloat2("KeyIcon_D_Pos", &keyIcon_D_Pos.x, 1.0f);
	ImGui::DragFloat2("KeyIcon_Esc_Pos", &keyIcon_Esc_Pos.x, 1.0f);
	ImGui::DragFloat2("KeyIcon_Enter_Pos", &keyIcon_Enter_Pos.x, 1.0f);

	keyIcon_W->SetPosition(keyIcon_W_Pos);
	keyIcon_A->SetPosition(keyIcon_A_Pos);
	keyIcon_S->SetPosition(keyIcon_S_Pos);
	keyIcon_D->SetPosition(keyIcon_D_Pos);
	keyIcon_Esc->SetPosition(keyIcon_Esc_Pos);
	keyIcon_Enter->SetPosition(keyIcon_Enter_Pos);

	// Move / Check / Back UIé…ç½®å¤‰æ›´
	moveUI_Pos_ = moveUI_->GetPosition();
	ImGui::DragFloat2("MoveUI_Pos", &moveUI_Pos_.x, 1.0f);
	moveUI_->SetPosition(moveUI_Pos_);

	checkUI_Pos_ = checkUI_->GetPosition();
	ImGui::DragFloat2("CheckUI_Pos", &checkUI_Pos_.x, 1.0f);
	checkUI_->SetPosition(checkUI_Pos_);

	backUI_Pos_ = backUI_->GetPosition();
	ImGui::DragFloat2("BackUI_Pos", &backUI_Pos_.x, 1.0f);
	backUI_->SetPosition(backUI_Pos_);

	ImGui::End();
	if (showDebugWindow_) {
		ImGui::Begin("Movement Debug", &showDebugWindow_);

		ImGui::Text("=== Current State ===");
		ImGui::Text("Current Node ID: %u", currentNodeId);
		ImGui::Text("Is Moving: %s", isMoving_ ? "YES" : "NO");
		ImGui::Text("Is Facing: %s", isFacing_ ? "YES" : "NO");

		ImGui::Separator();
		ImGui::Text("=== Position ===");
		Transform currentTr = playerModel->GetTransform();
		ImGui::Text("Current Pos: (%.2f, %.2f, %.2f)",
			currentTr.translate.x, currentTr.translate.y, currentTr.translate.z);

		if (isMoving_) {
			ImGui::Text("Start Pos:   (%.2f, %.2f, %.2f)",
				moveStartPos_.x, moveStartPos_.y, moveStartPos_.z);
			ImGui::Text("Target Pos:  (%.2f, %.2f, %.2f)",
				moveTargetPos_.x, moveTargetPos_.y, moveTargetPos_.z);
			ImGui::Text("Direction:   (%.3f, %.3f, %.3f)",
				debugDirection_.x, debugDirection_.y, debugDirection_.z);
			ImGui::Text("Distance:    %.3f", debugMoveDistance_);
		}

		ImGui::Separator();
		ImGui::Text("=== Rotation ===");
		ImGui::Text("Current Yaw:  %.1f deg (%.3f rad)",
			debugCurrentYawDeg_, currentTr.rotate.y);

		if (isMoving_) {
			ImGui::TextColored(ImVec4(0.0f, 1.0f, 0.0f, 1.0f),
				">>> MOVING <<<");
			ImGui::Text("Start Yaw:    %.1f deg", debugStartYawDeg_);
			ImGui::Text("Target Yaw:   %.1f deg", debugTargetYawDeg_);
			ImGui::Text("Yaw Change:   %.1f deg", debugYawChangeDeg_);
			ImGui::Text("Progress:     %.1f%%", (moveTime_ / moveDuration_) * 100.0f);

			// ãƒ—ãƒ­ã‚°ãƒ¬ã‚¹ãƒãƒ¼
			ImGui::ProgressBar(moveTime_ / moveDuration_, ImVec2(-1, 0));

			// å›è»¢ãŒå°ã•ã„å ´åˆã®è­¦å‘Š
			if (std::abs(debugYawChangeDeg_) < 5.0f) {
				ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.0f, 1.0f),
					"WARNING: Small rotation (< 5 deg)");
			}

			// è·é›¢ãŒçŸ­ã„å ´åˆã®è­¦å‘Š
			if (debugMoveDistance_ < 1.0f) {
				ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.0f, 1.0f),
					"WARNING: Short distance (< 1.0)");
			}
		}

		if (isFacing_) {
			ImGui::TextColored(ImVec4(0.0f, 0.5f, 1.0f, 1.0f),
				">>> FACING CAMERA <<<");
			ImGui::Text("Face Start:   %.1f deg", faceStartYaw_ * 57.2957795f);
			ImGui::Text("Face Target:  %.1f deg", faceTargetYaw_ * 57.2957795f);
			ImGui::Text("Progress:     %.1f%%", (faceTime_ / faceDuration_) * 100.0f);
			ImGui::ProgressBar(faceTime_ / faceDuration_, ImVec2(-1, 0));
		}

		ImGui::Separator();
		ImGui::Text("=== Settings ===");
		ImGui::DragFloat("Move Duration", &moveDuration_, 0.01f, 0.1f, 1.0f);
		ImGui::DragFloat("Face Duration", &faceDuration_, 0.01f, 0.1f, 1.0f);

		// ãƒ¢ãƒ‡ãƒ«è£œæ­£å€¤ã®èª¿æ•´
		ImGui::Text("Model Yaw Offset:");
		float offsetDeg = modelYawOffset_ * 57.2957795f;
		ImGui::Text("  Current: %.1f deg (%.3f rad)", offsetDeg, modelYawOffset_);

		ImGui::Separator();
		ImGui::Text("=== Quick Tests ===");
		if (ImGui::Button("Test: 0 deg")) {
			const_cast<float&>(modelYawOffset_) = 0.0f;
		}
		ImGui::SameLine();
		if (ImGui::Button("Test: 90 deg")) {
			const_cast<float&>(modelYawOffset_) = 1.570796326f;
		}
		ImGui::SameLine();
		if (ImGui::Button("Test: -90 deg")) {
			const_cast<float&>(modelYawOffset_) = -1.570796326f;
		}
		ImGui::SameLine();
		if (ImGui::Button("Test: 180 deg")) {
			const_cast<float&>(modelYawOffset_) = 3.14159265f;
		}

		ImGui::End();
	}
	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã‚°ãƒ©ãƒ•ã®ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º
	DrawSelectGraphImGui();
#endif
}

void StageSelectScene::DrawSelectGraphImGui()
{
#ifdef USE_IMGUI
	// Graph ãŒç„¡ã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
	if (!stageSelectGraph)
	{
		ImGui::Begin("StageSelect Graph");
		ImGui::TextDisabled("stageSelectGraph is null.");
		ImGui::End();
		return;
	}

	const uint32_t count = stageSelectGraph->GetNodeCount();

	// é¸æŠIDã®è£œæ­£
	if (count == 0)
	{
		editNodeId_ = 0;
		prevEditNodeId_ = UINT32_MAX;
	} else if (editNodeId_ >= count)
	{
		editNodeId_ = count - 1;
	}

	// é¸æŠãŒå¤‰ã‚ã£ãŸã¨ãã ã‘ç·¨é›†ãƒãƒƒãƒ•ã‚¡ã¸ãƒ­ãƒ¼ãƒ‰
	auto toUi = [&](uint32_t id)->int {
		return (id == StageSelectGraph::INVALID_NODE_ID) ? -1 : (int)id;
		};

	if (count > 0 && editNodeId_ != prevEditNodeId_)
	{
		prevEditNodeId_ = editNodeId_;
		const StageNode& n = stageSelectGraph->GetNode(editNodeId_);

		editX_ = (int)n.position.x;
		editY_ = (int)n.position.y;
		editStageId_ = (int)n.stageId;
		strncpy_s(editStageKey_, sizeof(editStageKey_), n.stageKey.c_str(), _TRUNCATE);
		editUnlocked_ = n.unlocked;

		editNeighUp_ = toUi(n.neighbor[(int)Direction::Up]);
		editNeighDown_ = toUi(n.neighbor[(int)Direction::Down]);
		editNeighLeft_ = toUi(n.neighbor[(int)Direction::Left]);
		editNeighRight_ = toUi(n.neighbor[(int)Direction::Right]);

		jsonDirty_ = true;
	}

	auto toId = [&](int v)->uint32_t {
		return (v < 0) ? StageSelectGraph::INVALID_NODE_ID : (uint32_t)v;
		};

	auto validateNeighbor = [&](int v)->int {
		if (v < 0) return 0;                 // none
		if ((uint32_t)v >= count) return 2;  // invalid
		return 1;                            // ok
		};

	// ========= UI =========
	ImGui::Begin("StageSelect Graph", nullptr, ImGuiWindowFlags_NoCollapse);

	ImGui::Text("Nodes: %u", count);
	ImGui::SameLine();
	ImGui::TextDisabled("Selected: %u", (count > 0) ? editNodeId_ : 0);
	ImGui::Separator();

	// ---- Tabs ----
	if (ImGui::BeginTabBar("GraphTabs"))
	{
		// ======================
		// List tab
		// ======================
		if (ImGui::BeginTabItem("List"))
		{
			ImGui::Checkbox("Unlocked only", &filterUnlockedOnly_);
			ImGui::SameLine();
			ImGui::SetNextItemWidth(140.0f);
			ImGui::InputInt("Filter StageId", &filterStageId_);
			ImGui::SameLine();
			if (ImGui::Button("Clear"))
			{
				filterUnlockedOnly_ = false;
				filterStageId_ = -1;
			}

			ImGui::Separator();

			ImGui::BeginChild("NodeList", ImVec2(0, 0), true);

			if (ImGui::BeginTable("nodes_table", 6,
				ImGuiTableFlags_RowBg | ImGuiTableFlags_Borders | ImGuiTableFlags_ScrollY |
				ImGuiTableFlags_Resizable | ImGuiTableFlags_SizingStretchProp))
			{
				ImGui::TableSetupColumn("Index", ImGuiTableColumnFlags_WidthFixed, 60);
				ImGui::TableSetupColumn("StageId", ImGuiTableColumnFlags_WidthFixed, 70);
				ImGui::TableSetupColumn("Unlocked", ImGuiTableColumnFlags_WidthFixed, 80);
				ImGui::TableSetupColumn("X", ImGuiTableColumnFlags_WidthFixed, 60);
				ImGui::TableSetupColumn("Y", ImGuiTableColumnFlags_WidthFixed, 60);
				ImGui::TableSetupColumn("Neigh", ImGuiTableColumnFlags_WidthFixed, 70);
				ImGui::TableHeadersRow();

				for (uint32_t i = 0; i < count; ++i)
				{
					const StageNode& n = stageSelectGraph->GetNode(i);

					if (filterUnlockedOnly_ && !n.unlocked) continue;
					if (filterStageId_ >= 0 && (int)n.stageId != filterStageId_) continue;

					int neighCount = 0;
					for (int d = 0; d < (int)Direction::count; ++d)
						if (n.neighbor[d] != StageSelectGraph::INVALID_NODE_ID) neighCount++;

					ImGui::TableNextRow();

					ImGui::TableNextColumn();
					bool selected = (editNodeId_ == i);

					ImGui::PushID((int)i);
					if (!n.unlocked) ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(160, 160, 160, 255));
					if (ImGui::Selectable("##row", selected, ImGuiSelectableFlags_SpanAllColumns))
					{
						editNodeId_ = i;
					}
					if (!n.unlocked) ImGui::PopStyleColor();
					ImGui::PopID();

					ImGui::SameLine();
					ImGui::Text("%u", i);

					ImGui::TableNextColumn(); ImGui::Text("%u", n.stageId);
					ImGui::TableNextColumn(); ImGui::TextUnformatted(n.unlocked ? "Yes" : "No");
					ImGui::TableNextColumn(); ImGui::Text("%u", n.position.x);
					ImGui::TableNextColumn(); ImGui::Text("%u", n.position.y);
					ImGui::TableNextColumn(); ImGui::Text("%d", neighCount);
				}

				ImGui::EndTable();
			}

			ImGui::EndChild();
			ImGui::EndTabItem();
		}

		// ======================
		// Node tab
		// ======================
		if (ImGui::BeginTabItem("Node"))
		{
			if (count == 0)
			{
				ImGui::TextDisabled("No nodes.");
			} else
			{
				ImGui::Text("Editing node: %u", editNodeId_);
				ImGui::Separator();

				ImGui::SetNextItemWidth(200.0f);
				ImGui::InputInt("StageId", &editStageId_);
				ImGui::SetNextItemWidth(200.0f);
				ImGui::InputText("StageKey", editStageKey_, sizeof(editStageKey_));
				ImGui::Checkbox("Unlocked", &editUnlocked_);

				ImGui::Separator();

				ImGui::SetNextItemWidth(120.0f);
				ImGui::InputInt("PosX", &editX_);
				ImGui::SameLine();
				ImGui::SetNextItemWidth(120.0f);
				ImGui::InputInt("PosY", &editY_);
				ImGui::Separator();
				ImGui::Text("Rotation Settings");

				// Yawè§’åº¦ã®ç·¨é›†ï¼ˆåº¦æ•°æ³•ã§è¡¨ç¤ºï¼‰
				const StageNode& currentNode = stageSelectGraph->GetNode(editNodeId_);
				bool isAutoYaw = (currentNode.defaultYaw == StageSelectGraph::AUTO_YAW);

				ImGui::Checkbox("Auto Calculate Yaw", &isAutoYaw);
				ImGui::SameLine();
				ImGui::TextDisabled("(?)");
				if (ImGui::IsItemHovered()) {
					ImGui::SetTooltip("If checked, yaw will be automatically calculated to face the camera");
				}

				if (!isAutoYaw) {
					// ãƒ©ã‚¸ã‚¢ãƒ³ã‚’åº¦ã«å¤‰æ›ã—ã¦è¡¨ç¤º
					float yawDegrees = currentNode.defaultYaw * 57.2957795f; // rad to deg
					ImGui::SetNextItemWidth(200.0f);
					if (ImGui::SliderFloat("Yaw (degrees)", &yawDegrees, 0.0f, 360.0f, "%.1f")) {
						// åº¦ã‚’ãƒ©ã‚¸ã‚¢ãƒ³ã«å¤‰æ›ã—ã¦è¨­å®š
						float yawRad = yawDegrees * 0.0174532925f; // deg to rad
						stageSelectGraph->SetNodeYaw(editNodeId_, yawRad);
						jsonDirty_ = true;
					}
				} else {
					// AUTO_YAWã«è¨­å®š
					if (currentNode.defaultYaw != StageSelectGraph::AUTO_YAW) {
						stageSelectGraph->SetNodeYaw(editNodeId_, StageSelectGraph::AUTO_YAW);
						jsonDirty_ = true;
					}
				}
				if (ImGui::Button("Apply Node"))
				{
					stageSelectGraph->SetNodeStageId(editNodeId_, (uint32_t)(std::max)(editStageId_, 0));
					stageSelectGraph->SetNodeStageKey(editNodeId_, std::string(editStageKey_));

					stageSelectGraph->SetNodeUnlocked(editNodeId_, editUnlocked_);
					stageSelectGraph->SetNodePos(editNodeId_, {
						(uint32_t)(std::max)(editX_, 0),
						(uint32_t)(std::max)(editY_, 0)
						});

					jsonDirty_ = true;
				}

				ImGui::SameLine();
				if (ImGui::Button("Reload From Graph"))
				{
					prevEditNodeId_ = UINT32_MAX; // æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã§å†ãƒ­ãƒ¼ãƒ‰
				}
			}

			ImGui::EndTabItem();
		}

		// ======================
		// Neighbors tab
		// ======================
		if (ImGui::BeginTabItem("Neighbors"))
		{
			if (count == 0)
			{
				ImGui::TextDisabled("No nodes.");
			} else
			{
				ImGui::Text("Editing node: %u", editNodeId_);
				ImGui::TextDisabled("Use -1 for none. Valid range: 0..%u", (count > 0) ? (count - 1) : 0);
				ImGui::Separator();

				ImGui::SetNextItemWidth(140.0f); ImGui::InputInt("Up", &editNeighUp_);
				{
					int s = validateNeighbor(editNeighUp_);
					ImGui::SameLine();
					if (s == 0) ImGui::TextDisabled("none");
					else if (s == 2) ImGui::TextColored(ImVec4(1, 0.2f, 0.2f, 1), "invalid");
					else ImGui::Text("ok");
				}

				ImGui::SetNextItemWidth(140.0f); ImGui::InputInt("Down", &editNeighDown_);
				{
					int s = validateNeighbor(editNeighDown_);
					ImGui::SameLine();
					if (s == 0) ImGui::TextDisabled("none");
					else if (s == 2) ImGui::TextColored(ImVec4(1, 0.2f, 0.2f, 1), "invalid");
					else ImGui::Text("ok");
				}

				ImGui::SetNextItemWidth(140.0f); ImGui::InputInt("Left", &editNeighLeft_);
				{
					int s = validateNeighbor(editNeighLeft_);
					ImGui::SameLine();
					if (s == 0) ImGui::TextDisabled("none");
					else if (s == 2) ImGui::TextColored(ImVec4(1, 0.2f, 0.2f, 1), "invalid");
					else ImGui::Text("ok");
				}

				ImGui::SetNextItemWidth(140.0f); ImGui::InputInt("Right", &editNeighRight_);
				{
					int s = validateNeighbor(editNeighRight_);
					ImGui::SameLine();
					if (s == 0) ImGui::TextDisabled("none");
					else if (s == 2) ImGui::TextColored(ImVec4(1, 0.2f, 0.2f, 1), "invalid");
					else ImGui::Text("ok");
				}

				if (ImGui::Button("Apply Neighbors"))
				{
					stageSelectGraph->SetNeighbor(editNodeId_, Direction::Up, toId(editNeighUp_));
					stageSelectGraph->SetNeighbor(editNodeId_, Direction::Down, toId(editNeighDown_));
					stageSelectGraph->SetNeighbor(editNodeId_, Direction::Left, toId(editNeighLeft_));
					stageSelectGraph->SetNeighbor(editNodeId_, Direction::Right, toId(editNeighRight_));
					jsonDirty_ = true;
				}

				ImGui::SameLine();
				if (ImGui::Button("Jump To Up") && editNeighUp_ >= 0 && (uint32_t)editNeighUp_ < count)    editNodeId_ = (uint32_t)editNeighUp_;
				ImGui::SameLine();
				if (ImGui::Button("Jump To Down") && editNeighDown_ >= 0 && (uint32_t)editNeighDown_ < count) editNodeId_ = (uint32_t)editNeighDown_;

				if (ImGui::Button("Jump To Left") && editNeighLeft_ >= 0 && (uint32_t)editNeighLeft_ < count) editNodeId_ = (uint32_t)editNeighLeft_;
				ImGui::SameLine();
				if (ImGui::Button("Jump To Right") && editNeighRight_ >= 0 && (uint32_t)editNeighRight_ < count) editNodeId_ = (uint32_t)editNeighRight_;
			}

			ImGui::EndTabItem();
		}

		// ======================
		// JSON tab
		// ======================
		if (ImGui::BeginTabItem("JSON"))
		{
			ImGui::TextDisabled("Graph JSON preview (read-only).");

			if (ImGui::Button("Refresh"))
			{
				jsonDirty_ = true;
			}
			ImGui::SameLine();

			static char saveName[128] = "StageSelectNodes";
			ImGui::SetNextItemWidth(220.0f);
			ImGui::InputText("Save BaseName", saveName, sizeof(saveName));
			ImGui::SameLine();
			if (ImGui::Button("Save JSON"))
			{
				stageSelectGraph->SaveToJsonFile(saveName);
			}

			ImGui::Separator();

			if (jsonDirty_)
			{
				std::string s = stageSelectGraph->ToJsonString(2);
				strncpy_s(jsonBuf_, sizeof(jsonBuf_), s.c_str(), _TRUNCATE);
				jsonDirty_ = false;
			}

			ImGui::InputTextMultiline("##json",
				jsonBuf_, sizeof(jsonBuf_),
				ImVec2(-1.0f, -1.0f),
				ImGuiInputTextFlags_ReadOnly);

			ImGui::EndTabItem();
		}

		// ======================
		// Ops tab
		// ======================
		if (ImGui::BeginTabItem("Ops"))
		{
			ImGui::Text("Add Node");
			ImGui::SetNextItemWidth(90.0f);  ImGui::InputInt("New X", &newX_);
			ImGui::SameLine();
			ImGui::SetNextItemWidth(90.0f);  ImGui::InputInt("New Y", &newY_);
			ImGui::SameLine();
			ImGui::SetNextItemWidth(120.0f); ImGui::InputInt("New StageId", &newStageId_);
			ImGui::SameLine();
			ImGui::SetNextItemWidth(120.0f); ImGui::InputText("New StageKey", newStageKey_, sizeof(newStageKey_));
			ImGui::SameLine();
			ImGui::Checkbox("New Unlocked", &newUnlocked_);

			if (ImGui::Button("Add"))
			{
				uint32_t newId = stageSelectGraph->AddNode(
					{ (uint32_t)(std::max)(newX_, 0), (uint32_t)(std::max)(newY_, 0) },
					(uint32_t)(std::max)(newStageId_, 0),
					std::string(newStageKey_),
					newUnlocked_
				);

				editNodeId_ = newId;
				prevEditNodeId_ = UINT32_MAX;
				jsonDirty_ = true;
			}

			ImGui::Separator();
			ImGui::TextDisabled("Tips: Edit values here, then press Apply in each tab.");

			ImGui::EndTabItem();
		}

		// ======================
		// Check tab
		// ======================
		if (ImGui::BeginTabItem("Check"))
		{
			ImGui::Text("CurrentNodeId: %u", currentNodeId);

			const StageNode& cn = stageSelectGraph->GetNode(currentNodeId);
			ImGui::Text("Pos: (%u, %u)", cn.position.x, cn.position.y);

			auto showTo = [&](Direction dir, const char* name) {
				uint32_t to = cn.neighbor[(int)dir];
				ImGui::Text("%s -> %u", name, to);
				};
			showTo(Direction::Up, "Up");
			showTo(Direction::Down, "Down");
			showTo(Direction::Left, "Left");
			showTo(Direction::Right, "Right");

			ImGui::EndTabItem();
		}

		ImGui::EndTabBar();
	}

	ImGui::End();
#endif
}

============================================================
File Path: Game/Scene/StageSelectScene.h
============================================================
#pragma once
#include "engine/InsideScene/BaseScene.h"
#include <MyMath.h>
#include "SceneSelectGraph/StageSelectGraph.h"
#include "Sprite.h"

/// <summary>
/// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã‚·ãƒ¼ãƒ³
/// ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠç”»é¢ã®ã‚·ãƒ¼ãƒ³
/// </summary>

class Object3D;
class Camera;
class StageSelectScene :
	public BaseScene
{
public:
	StageSelectScene();
	~StageSelectScene();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize(Engine::DirectXCommon* dxCommon)override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw()override;

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize()override;

	/// <summary>
	/// Imguiä¸€æ‹¬ç®¡ç†
	/// </summary>
	void DrawImgui();

	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•å‡¦ç†
	/// </summary>
	void PlayerMove();

private:
	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆå…¥åŠ›å‡¦ç†
	/// </summary>
	void HandleSelectInput();

	/// <summary>
	/// ãƒãƒ¼ãƒ‰ä½ç½®ã‚’ã‚«ãƒ¼ã‚½ãƒ«ä½ç½®ã«åˆã‚ã›ã‚‹
	/// </summary>
	void ApplyNodeToCursorTransform();

	/// <summary>
	/// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã‚°ãƒ©ãƒ•ç·¨é›†ImGui
	/// </summary>
	void DrawSelectGraphImGui();

	/// <summary>
	/// ãƒãƒ¼ãƒ‰IDã‹ã‚‰ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã‚’è¨ˆç®—
	/// </summary>
	/// <param name="nodeId">å–å¾—ã™ã‚‹ãƒãƒ¼ãƒ‰</param>
	/// <returns>ãƒãƒ¼ãƒ‰ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™</returns>
	Vector3 CalcNodeWorldPos(uint32_t nodeId)const;

	/// <summary>
	/// ã‚«ãƒ¼ã‚½ãƒ«ç§»å‹•æ›´æ–°
	/// </summary>
	void UpdateCursorMove();

	/// <summary>
	/// 2ç‚¹é–“ã®æ–¹å‘ã‚’å‘ããŸã‚ã®Yawè§’ã‚’è¨ˆç®—
	/// </summary>
	/// <param name="from">é–‹å§‹ä½ç½®</param>
	/// <param name="to">ç›®æ¨™ä½ç½®</param>
	/// <returns>Yawè§’ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰</returns>
	float CalcYawToTarget(const Vector3& from, const Vector3& to) const;

	/// <summary>
	/// æŒ‡å®šåº§æ¨™ã‹ã‚‰ã‚«ãƒ¡ãƒ©æ–¹å‘ã‚’å‘ããŸã‚ã®ãƒ¨ãƒ¼è§’ã‚’è¨ˆç®—
	/// </summary>
	/// <param name="pos">åŸºæº–ä½ç½®</param>
	/// <returns>Yawè§’ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰</returns>
	float CalcYawFaceCamera(const Vector3& pos)const;

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©æ–¹å‘ã‚’å‘ãæ›´æ–°
	/// </summary>
	void UpdateFaceYaw();

	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ã®æ§‹ç¯‰
	/// </summary>
	void BuildRoutes();

private:
	// ã‚«ãƒ¡ãƒ© / ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
	Camera* camera = nullptr;
	Transform cameraTransform;

	// ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3D> playerModel;
	Transform playerTransform;

	// ã‚»ãƒ¬ã‚¯ãƒˆç”»é¢ï¼‘ã®åœŸå°
	std::unique_ptr<Object3D> stageSelectBase1;
	Transform stageSelectBase1Transform;

	// ç©ºèƒŒæ™¯
	std::unique_ptr<Object3D> skyBack;
	Transform skyBackTransform;

	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã‚°ãƒ©ãƒ•
	std::unique_ptr<StageSelectGraph> stageSelectGraph;
	uint32_t currentNodeId = 0;
	uint32_t startNodeId = 0;

	// ãƒãƒ¼ãƒ‰ãƒ¢ãƒ‡ãƒ«ç¾¤
	std::vector<std::unique_ptr<Object3D>>nodeModels_;
	std::vector<Transform>nodeTransforms_;

	// ãƒ«ãƒ¼ãƒˆãƒ¢ãƒ‡ãƒ«ç¾¤
	std::vector<std::unique_ptr<Object3D>> routeModels_;
	std::vector<Transform> routeTransforms_;

	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆUI
	std::unique_ptr<Sprite>stageSelect_;

	// ã‚­ãƒ¼ã‚¢ã‚¤ã‚³ãƒ³UI
	std::unique_ptr<Sprite> keyIcon_W;
	Vector2 keyIcon_W_Pos = { 1100.0f,650.0f };
	std::unique_ptr<Sprite> keyIcon_A;
	Vector2 keyIcon_A_Pos = { 1020.0f,680.0f };
	std::unique_ptr<Sprite> keyIcon_S;
	Vector2 keyIcon_S_Pos = { 1100.0f,710.0f };
	std::unique_ptr<Sprite> keyIcon_D;
	Vector2 keyIcon_D_Pos = { 1180.0f,680.0f };

	// Escã‚­ãƒ¼
	std::unique_ptr<Sprite> keyIcon_Esc;
	Vector2 keyIcon_Esc_Pos = { 100.0f,650.0f };
	// Enterã‚­ãƒ¼
	std::unique_ptr<Sprite> keyIcon_Enter;
	Vector2 keyIcon_Enter_Pos = { 200.0f,650.0f };

	// MoveUI
	std::unique_ptr<Sprite>moveUI_;
	Vector2 moveUI_Pos_ = { 160.0f,635.0f };
	// CheckUI
	std::unique_ptr<Sprite>checkUI_;
	Vector2 checkUI_Pos_ = { 160.0f, 505.0f };
	// BackUI
	std::unique_ptr<Sprite>backUI_;
	Vector2 backUI_Pos_ = { 160.0f, 560.0f };

private:
	// ===== ç§»å‹•ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ =====
	// ç§»å‹•ä¸­ãƒ•ãƒ©ã‚°
	bool isMoving_ = false;
	// ç§»å‹•çµŒéæ™‚é–“
	float moveTime_ = 0.0f;
	// ç§»å‹•ã«ã‹ã‹ã‚‹æ™‚é–“
	float moveDuration_ = 0.35f;

	// ç§»å‹•é–‹å§‹ä½ç½®
	Vector3 moveStartPos_ = {};
	// ç§»å‹•ç›®æ¨™ä½ç½®
	Vector3 moveTargetPos_ = {};

	// ç§»å‹•é–‹å§‹æ™‚ã®Yawè§’
	float moveStartYaw_ = 0.0f;
	// ç§»å‹•ç›®æ¨™ã®Yawè§’ï¼ˆé€²è¡Œæ–¹å‘ï¼‰
	float moveTargetYaw_ = 0.0f;

	// ===== åœæ­¢å¾Œã®ã€Œã‚«ãƒ¡ãƒ©æ–¹å‘ã‚’å‘ãã€è£œé–“ç”¨ =====
	// ã‚«ãƒ¡ãƒ©æ–¹å‘ã‚’å‘ã„ã¦ã„ã‚‹æœ€ä¸­ãƒ•ãƒ©ã‚°
	bool  isFacing_ = false;
	// å‘ãå¤‰æ›´ã®çµŒéæ™‚é–“
	float faceTime_ = 0.0f;
	// å‘ãå¤‰æ›´ã«ã‹ã‹ã‚‹æ™‚é–“
	float faceDuration_ = 0.25f;
	// å‘ãå¤‰æ›´é–‹å§‹æ™‚ã®Yawè§’
	float faceStartYaw_ = 0.0f;
	// å‘ãå¤‰æ›´ç›®æ¨™ã®Yawè§’ï¼ˆã‚«ãƒ¡ãƒ©æ–¹å‘ï¼‰
	float faceTargetYaw_ = 0.0f;

	// ãƒ¢ãƒ‡ãƒ«ã®å‘ãè£œæ­£å€¤ï¼ˆãƒ¢ãƒ‡ãƒ«ãŒå³å‘ãã®å ´åˆ -90åº¦ï¼‰
	const float modelYawOffset_ = -1.570796326f;

#ifdef USE_IMGUI
	// ===== ImGuiç·¨é›†ç”¨å¤‰æ•° =====
	// é¸æŠä¸­ãƒãƒ¼ãƒ‰ãŒå¤‰ã‚ã£ãŸã‹ï¿½ï¿½å®šç”¨
	uint32_t prevEditNodeId_ = UINT32_MAX;
	// ãƒ‡ãƒãƒƒã‚°æƒ…å ±è¡¨ç¤ºç”¨
	bool showDebugWindow_ = true;
	float debugMoveDistance_ = 0.0f;
	float debugStartYawDeg_ = 0.0f;
	float debugTargetYawDeg_ = 0.0f;
	float debugCurrentYawDeg_ = 0.0f;
	float debugYawChangeDeg_ = 0.0f;
	Vector3 debugDirection_ = {};

	// ç·¨é›†ãƒãƒƒãƒ•ã‚¡ï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ ä¸Šæ›¸ãã•ã‚Œãªã„ã‚ˆã†ã«ä¿æŒï¼‰
	int editX_ = 0;
	int editY_ = 0;
	int editStageId_ = 0;
	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¹ãƒ†ãƒ¼ã‚¸ã‚­ãƒ¼
	char editStageKey_[64] = "1-1";
	char newStageKey_[64] = "1-1";
	bool editUnlocked_ = false;

	// éš£æ¥ãƒãƒ¼ãƒ‰ç·¨é›†ç”¨
	int editNeighUp_ = -1;
	int editNeighDown_ = -1;
	int editNeighLeft_ = -1;
	int editNeighRight_ = -1;

	// ãƒ•ã‚£ãƒ«ã‚¿IDï¼ˆ-1ã§ç„¡åŠ¹ï¼‰
	int filterStageId_ = -1;
	bool filterUnlockedOnly_ = false;

	// JSONè¡¨ç¤ºç”¨
	bool jsonDirty_ = true;
	char jsonBuf_[32768] = {};

	// ç·¨é›†ç”¨ãƒãƒ¼ãƒ‰ID
	uint32_t editNodeId_ = 0;

	// è¿½åŠ ç”¨å…¥åŠ›
	int newX_ = 0;
	int newY_ = 0;
	int newStageId_ = 0;
	bool newUnlocked_ = true;

	// æ¥ç¶šç·¨é›†ç”¨ï¼ˆãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ï¼‰
	int neighborUp_ = -1;
	int neighborDown_ = -1;
	int neighborLeft_ = -1;
	int neighborRight_ = -1;
#endif
};

============================================================
File Path: Game/Scene/TitleScene.cpp
============================================================
#include <thread>
#include "TitleScene.h"
#include "Input.h"
#include "Object3D.h"
#include "engine/3d/ModelManager.h"
#include "Game/Camera/camera.h"
#include "Game/Particle/ParticleManager.h"
#include "Game/Particle/ModelParticleManager.h"
#include "Game/Particle/ParticleSystem.h"
#include "engine/InsideScene/Framework.h"
#include "Game/Particle/ParticlePresets.h"
using Engine::DirectXCommon;
TitleScene::TitleScene()
{

}

TitleScene::~TitleScene()
{
}

void TitleScene::Initialize(DirectXCommon* dxCommon)
{
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
	SpriteCommon::GetInstance().Initialize(dxCommon);


	// ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã§ã®èª­ã¿è¾¼ã¿
	LoadAudio();
	LoadSprite();

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ
	particleEmitter = ParticlePresets::CreateSmoke({ 1.0f,-7.0f,20.0f });
	particleEmitter->Pause();

	
	particleEmitter2 = ParticlePresets::CreateSparks({ 1.0f,-7.0f,20.0f });
	particleEmitter2->Pause();


	presetEffect = ParticlePresets::CreateSummonCircle({5.0f,-7.0f,20.0f});
	presetEffect->Play();


	object3D = make_unique<Object3D>();
	object3D->Initialize();

	object3D->SetModel("plane.obj");
	object3D->SetTranslate(Vector3(-4.0f, 0.0f, 10.0f));

	object3D->SetScale(Vector3(0.2f, 0.2f, 0.2f));
	speed = object3D->GetTranslate();



	playerObject = std::make_unique<Object3D>();
	playerObject->Initialize();
	playerObject->SetModel("Player.obj");
	playerTransform = {
		{ 1.0f,1.0f,1.0f },
		{ 0.0f,0.0f,0.0f },
		{ 1.0f,-7.0f,20.0f }
	};
	playerObject->SetTransform(playerTransform);


	


	//sceneTransition = std::make_unique<SceneTransition>();
	//sceneTransition->Initialize();

	background = std::make_unique<BackGround>();
	background->Initialize();

	// ã‚«ãƒ¡ãƒ©ã®å–å¾—ã¨è¨­å®š
	camera = Framework::GetMainCamera();
	camera->SetTranslate({7.5f,-4.0f,0.0f});
	camera->SetRotate({ 0.0f, 0.0f, 0.0f });

	// ã‚¿ã‚¤ãƒˆãƒ«ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
	titleSprite = std::make_unique<Sprite>();
	titleSprite->Initialize("resources/Title/Title.png");
	titleSprite->SetPosition({ 0.0f,0.0f });
	titleSprite->SetSize({ 1280.0f,720.0f });

	// Press Start ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
	pressStartSprite = std::make_unique<Sprite>();
	pressStartSprite->Initialize("resources/Title/PushSpace.png");
	pressStartSprite->SetPosition({ -20.0f,100.0f });
	pressStartSprite->SetSize({ 1280.0f,720.0f });

}

void TitleScene::Update()
{
	//sprite_->Update();
	camera->Update();

	background->Update();

	

	//sceneTransition->Update();

#ifdef USE_IMGUI
	DrawImgui();
#endif
	particleEmitter->Update();
	particleEmitter2->Update();
	presetEffect->Update();



	titleSprite->Update();
	pressStartSprite->Update();
	// ç‚¹æ»…ã•ã›ã‚‹

	static int blinkTimer;
	blinkTimer++;
	if (blinkTimer > blinkDuration) {
		pressStartSprite->SetColor({ 1.0f,1.0f,1.0f,1.0f });
	}
	if (blinkTimer > blinkInterval) {
		pressStartSprite->SetColor({ 1.0f,1.0f,1.0f,0.0f });
		blinkTimer = 0;
	}

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å›è»¢
	playerTransform.rotate.z -= 0.05f; // å›è»¢é€Ÿåº¦ã¯èª¿æ•´å¯èƒ½
	playerObject->SetTransform(playerTransform);
	playerObject->Update();

	// ENTERã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸã‚‰
	if (Input::GetInstance()->TriggerKey(DIK_RETURN))
	{
		SceneManager::GetInstance()->ChangeScene("GAMEPLAY");
	}
	else if (Input::GetInstance()->TriggerKey(DIK_SPACE))
	{
		SceneManager::GetInstance()->ChangeScene("STAGESELECT");
	}

	if (Input::GetInstance()->TriggerKey(DIK_0))
	{
		particleEmitter->Stop();
		particleEmitter2->Stop();
		presetEffect->Stop();
	} else if (Input::GetInstance()->TriggerKey(DIK_9))
	{
		particleEmitter->Play();
		particleEmitter2->Play();
		presetEffect->Play();
	}

}

void TitleScene::Draw()
{

#pragma region 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™

	//sprite_->Draw();
#pragma endregion

#pragma region 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»

	background->Draw();

	//object3D->Draw();
	//levelData->Draw();
	playerObject->Draw();
	//Rainbow->Draw();

	

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æç”»
	ParticleManager::GetInstance()->Draw();
	ModelParticleManager::GetInstance().Draw();

	// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æç”»




	//sceneTransition->Draw();


#pragma endregion

	titleSprite->Draw();
	pressStartSprite->Draw();

}

void TitleScene::Finalize()
{


	// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®çµ‚äº†å‡¦ç†
	//Audio::GetInstance()->SoundUnload(&soundData);
	

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®çµ‚äº†å‡¦ç†
	SpriteCommon::GetInstance().DeleteInstance();
}

void TitleScene::LoadAudio()
{
	// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®åˆæœŸåŒ–
	//Audio::GetInstance()->Initialize();
	//soundData = Audio::GetInstance()->LoadWave("resources/fanfare.wav");
	//xaudio2_ = Audio::GetInstance()->GetXAudio2();
	//Audio::GetInstance()->SoundPlayWave(xaudio2_, soundData);

}

void TitleScene::LoadSprite() 
{
	sprite_ = make_unique<Sprite>();
	sprite_->Initialize("resources/gradationLine.png");
	sprite_->SetPosition({ 0.0f,0.0f });
	sprite_->SetRotation(0.0f);
}

void TitleScene::DrawImgui() {
#ifdef USE_IMGUI

	ImGui::Begin("playerObject");

	Transform pTransform = playerObject->GetTransform();
	ImGui::DragFloat3("Scale", &pTransform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotate", &pTransform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translate", &pTransform.translate.x, 0.1f);

	playerObject->SetTransform(pTransform);

	ImGui::End();

	


#endif // _DEBUG

}



============================================================
File Path: Game/Scene/TitleScene.h
============================================================
#pragma once
#include "Audio.h"
#include "SpriteCommon.h"
#include "engine/InsideScene/BaseScene.h"
#include "Sprite.h"
#include "engine/InsideScene/SceneManager.h"
#include "Game/Particle/ParticleManager.h"
#include "Game/Particle/ParticleSystem.h"
#include "Game/Loader/LevelLoader.h"
#include "SceneTransition/SceneTransition.h"
#include "Game/Application/BackGround.h"


#ifdef USE_IMGUI
#include "ImGuiManager.h"
#endif


/// <summary>
/// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³
/// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³ã‚’ç®¡ç†ã™ã‚‹
/// </summary>
class Camera;
class Object3D;
class TitleScene :public BaseScene
{
public:
	TitleScene();
	~TitleScene();
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="dxCommon"></param>
	void Initialize(Engine::DirectXCommon* dxCommon)override;
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;
	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw()override;
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize()override;
	/// <summary>
	///	ãƒ­ãƒ¼ãƒ‰å‡¦ç†ï¼ˆã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã€ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆï¼‰
	/// </summary>
	void LoadAudio();
	void LoadSprite();
	/// <summary>
	/// Imguiä¸€æ‹¬ç®¡ç† / æç”»é–¢æ•°
	/// </summary>
	void DrawImgui();
private:

	// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª
	// ã‚µã‚¦ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿
	//SoundData soundData;
	//IXAudio2* xaudio2_;

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::unique_ptr<Sprite> sprite_;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒŸãƒƒã‚¿ãƒ¼
	std::unique_ptr<ParticleSystem> particleEmitter;
	std::unique_ptr<ParticleSystem> particleEmitter2;

	std::unique_ptr<ParticleSystem> presetEffect;

	// ãƒªãƒ³ã‚°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3D> object3D;
	// èƒŒæ™¯
	std::unique_ptr<Object3D> backgroundObject;

private: // ã‚²ãƒ¼ãƒ è¦ç´ 
	Vector3 emitterScale = { 0.0f, 0.0f, 0.0f };
	Vector3 emitterRotate = { 0.0f, 0.0f, 0.0f };
	Vector3 emitterTranslate = { 0.0f, 0.0f, 10.0f };

	Transform effectTransform;

	Transform cylinderTransform;

	Vector3 speed = { 0.0f,0.0f,0.0f };


	bool isStart = false;



	/// level loader
	std::unique_ptr<LevelLoader>levelData;

	std::unique_ptr<Object3D> playerObject;
	Transform playerTransform;

	std::unique_ptr<Object3D> Rainbow;
	Transform rainbowTransform;

	/// ã‚¿ã‚¤ãƒˆãƒ«ãƒ­ã‚´
	std::unique_ptr<Object3D> titleLogo;
	Transform titleLogoTransform;

	// ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰
	 std::unique_ptr<BackGround> background;

	 // ã‚¿ã‚¤ãƒˆãƒ«ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	 std::unique_ptr<Sprite> titleSprite;
	 std::unique_ptr<Sprite> pressStartSprite;
	 // ç‚¹æ»…
	 const int blinkInterval = 60;
	 const int blinkDuration = 30;

	 /// ã‚«ãƒ¡ãƒ©
	 Camera* camera = nullptr;

	//std::unique_ptr<SceneTransition> sceneTransition;

};



============================================================
File Path: MyEngine.vcxproj
============================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{26572032-4A93-4273-8278-E5D02B30B209}</ProjectGuid>
    <RootNamespace>MyEngine</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LibraryPath>$(ProjectDir)Lib;$(LibraryPath)</LibraryPath>
    <IntDir>$(SolutionDir)..\generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)..\generated\outputs\$(Configuration)\</OutDir>
    <IncludePath>$(SolutionDir)imgui;$(SolutionDir)DirectXTex;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LibraryPath>$(ProjectDir)Lib;$(LibraryPath)</LibraryPath>
    <IntDir>$(SolutionDir)..\generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)..\generated\outputs\$(Configuration)\</OutDir>
    <IncludePath>$(SolutionDir)imgui;$(SolutionDir)DirectXTex;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;USE_IMGUI;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <TreatWarningAsError>true</TreatWarningAsError>
      <AdditionalIncludeDirectories>C:\Users\k023g\Desktop\GE3\engine\math;$(ProjectDir)engine\2d;$(ProjectDir)engine\3d;$(ProjectDir)engine\audio;$(ProjectDir)engine\base;$(ProjectDir)engine\math;$(ProjectDir)engine\scene;$(ProjectDir)imgui;$(ProjectDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalOptions>/ignore:4049 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <AdditionalLibraryDirectories>$(SolutionDir)..\generated\outputs\$(Configuration)\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>imgui.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>copy /y "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxcompiler.dll" "$(TargetDir)dxcompiler.dll" &amp;&amp; copy /y "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxil.dll" "$(TargetDir)dxil.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>C:\Users\k023g\Desktop\GE3\engine\math;$(ProjectDir)engine\2d;$(ProjectDir)engine\3d;$(ProjectDir)engine\audio;$(ProjectDir)engine\base;$(ProjectDir)engine\math;$(ProjectDir)engine\scene;$(ProjectDir)imgui;$(ProjectDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)..\generated\outputs\$(Configuration)\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>copy /y "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxcompiler.dll" "$(TargetDir)dxcompiler.dll" &amp;&amp; copy /y "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxil.dll" "$(TargetDir)dxil.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Game\Application\UI\DamageFeedBack.cpp" />
    <ClCompile Include="Game\Application\UI\GamePlayHUD.cpp" />
    <ClCompile Include="Game\Camera\CameraController.cpp" />
    <ClCompile Include="Game\Application\BackGround.cpp" />
    <ClCompile Include="Game\Collision\CollisionManager.cpp" />
    <ClCompile Include="Game\Application\Enemy\FlyingEnemy.cpp" />
    <ClCompile Include="Game\Application\Enemy\EnemyBase.cpp" />
    <ClCompile Include="Game\Application\Enemy\EnemyFactory.cpp" />
    <ClCompile Include="Game\Collision\Collider.cpp" />
    <ClCompile Include="Game\Application\Map\CsvLoader.cpp" />
    <ClCompile Include="Game\Application\Block\Block.cpp" />
    <ClCompile Include="Game\Application\ModelList.cpp" />
    <ClCompile Include="engine\InsideScene\AbstractSceneFactory.cpp" />
    <ClCompile Include="engine\Audio\Audio.cpp" />
    <ClCompile Include="engine\InsideScene\BaseScene.cpp" />
    <ClCompile Include="Game\Camera\Camera.cpp" />
    <ClCompile Include="engine\base\D3DResourceLeakChecker.cpp" />
    <ClCompile Include="engine\base\DirectXCommon.cpp" />
    <ClCompile Include="engine\base\Input.cpp" />
    <ClCompile Include="engine\base\Logger.cpp" />
    <ClCompile Include="engine\InsideScene\Framework.cpp" />
    <ClCompile Include="Game\Scene\GamePlayScene.cpp" />
    <ClCompile Include="engine\base\ImGuiManager.cpp" />
    <ClCompile Include="Game\Loader\LevelLoader.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="engine\math\MakeMatrix.cpp" />
    <ClCompile Include="engine\3d\Model.cpp" />
    <ClCompile Include="engine\3d\ModelCommon.cpp" />
    <ClCompile Include="engine\3d\ModelManager.cpp" />
    <ClCompile Include="engine\3d\Object3D.cpp" />
    <ClCompile Include="engine\3d\Object3DCommon.cpp" />
    <ClCompile Include="engine\2d\Sprite.cpp" />
    <ClCompile Include="engine\2d\SpriteCommon.cpp" />
    <ClCompile Include="engine\base\StringUtility.cpp" />
    <ClCompile Include="engine\base\TextureManager.cpp" />
    <ClCompile Include="engine\base\WinAPI.cpp" />
    <ClCompile Include="Game\Scene\MyGame.cpp" />
    <ClCompile Include="Game\Particle\ParticleSystem.cpp" />
    <ClCompile Include="Game\Particle\ParticleManager.cpp" />
    <ClCompile Include="engine\InsideScene\SceneFactory.cpp" />
    <ClCompile Include="engine\InsideScene\SceneManager.cpp" />
    <ClCompile Include="engine\base\SrvManager.cpp" />
    <ClCompile Include="Game\Scene\TitleScene.cpp" />
    <ClCompile Include="Game\Application\StageType.cpp" />
    <ClCompile Include="Game\Application\Enemy\NormalEnemy.cpp" />
    <ClCompile Include="engine\3d\SkyBox\SkyBox.cpp" />
    <ClCompile Include="engine\2d\RenderTexture.cpp" />
    <ClCompile Include="Game\Scene\SceneTransition\SceneTransition.cpp" />
    <ClCompile Include="Game\Application\Player\Player.cpp" />
    <ClCompile Include="Game\Application\Map\Map.cpp" />
    <ClCompile Include="Game\Scene\StageClearScene.cpp" />
    <ClCompile Include="Game\Scene\StageSelectScene.cpp" />
    <ClCompile Include="Game\Scene\SceneSelectGraph\StageSelectGraph.cpp" />
    <ClCompile Include="Game\Scene\Pause\PauseUI.cpp" />
    <ClCompile Include="Game\Camera\StartCamPhase.cpp" />
    <ClCompile Include="Game\Scene\Pause\PauseSystem.cpp" />
    <ClCompile Include="Game\Application\PlayContext.cpp" />
    <ClCompile Include="Game\Particle\ParticlePresets.cpp" />
    <ClCompile Include="Game\Particle\ModelParticleManager.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Game\Application\UI\DamageFeedBack.h" />
    <ClInclude Include="Game\Application\UI\GamePlayHUD.h" />
    <ClInclude Include="Game\Application\Enemy\EnemyType.h" />
    <ClInclude Include="Game\Camera\CameraController.h" />
    <ClInclude Include="Game\Application\BackGround.h" />
    <ClInclude Include="Game\Collision\CollisionManager.h" />
    <ClInclude Include="Game\Application\Enemy\FlyingEnemy.h" />
    <ClInclude Include="Game\Application\Enemy\EnemyBase.h" />
    <ClInclude Include="Game\Application\Enemy\EnemyFactory.h" />
    <ClInclude Include="Game\Collision\Collider.h" />
    <ClInclude Include="Game\Application\Block\BlockType.h" />
    <ClInclude Include="Game\Application\Map\CsvLoader.h" />
    <ClInclude Include="Game\Application\Block\Block.h" />
    <ClInclude Include="Game\Application\ModelList.h" />
    <ClInclude Include="engine\InsideScene\AbstractSceneFactory.h" />
    <ClInclude Include="engine\Audio\Audio.h" />
    <ClInclude Include="engine\InsideScene\BaseScene.h" />
    <ClInclude Include="Game\Camera\Camera.h" />
    <ClInclude Include="engine\base\D3DResourceLeakChecker.h" />
    <ClInclude Include="engine\base\DirectXCommon.h" />
    <ClInclude Include="engine\base\Input.h" />
    <ClInclude Include="engine\base\Logger.h" />
    <ClInclude Include="engine\math\MakeMatrix.h" />
    <ClInclude Include="engine\math\MyMath.h" />
    <ClInclude Include="engine\3d\Model.h" />
    <ClInclude Include="engine\3d\ModelCommon.h" />
    <ClInclude Include="engine\3d\ModelManager.h" />
    <ClInclude Include="engine\3d\Object3D.h" />
    <ClInclude Include="engine\3d\Object3DCommon.h" />
    <ClInclude Include="engine\2d\Sprite.h" />
    <ClInclude Include="engine\2d\SpriteCommon.h" />
    <ClInclude Include="engine\base\StringUtility.h" />
    <ClInclude Include="engine\base\TextureManager.h" />
    <ClInclude Include="engine\base\WinAPI.h" />
    <ClInclude Include="engine\InsideScene\Framework.h" />
    <ClInclude Include="Game\Scene\GamePlayScene.h" />
    <ClInclude Include="engine\base\ImGuiManager.h" />
    <ClInclude Include="Game\Scene\MyGame.h" />
    <ClInclude Include="Game\Particle\ParticleSystem.h" />
    <ClInclude Include="Game\Particle\ParticleManager.h" />
    <ClInclude Include="engine\InsideScene\SceneFactory.h" />
    <ClInclude Include="engine\InsideScene\SceneManager.h" />
    <ClInclude Include="engine\base\SrvManager.h" />
    <ClInclude Include="Game\Scene\TitleScene.h" />
    <ClInclude Include="Game\Application\StageType.h" />
    <ClInclude Include="Game\Application\Enemy\NormalEnemy.h" />
    <ClInclude Include="Game\Loader\LevelLoader.h" />
    <ClInclude Include="engine\3d\SkyBox\SkyBox.h" />
    <ClInclude Include="engine\2d\RenderTexture.h" />
    <ClInclude Include="Game\Scene\SceneTransition\SceneTransition.h" />
    <ClInclude Include="Game\Application\Player\Player.h" />
    <ClInclude Include="Game\Application\Map\Map.h" />
    <ClInclude Include="Game\Scene\StageClearScene.h" />
    <ClInclude Include="Game\Scene\StageSelectScene.h" />
    <ClInclude Include="Game\Scene\SceneSelectGraph\StageSelectGraph.h" />
    <ClInclude Include="Game\Scene\Pause\PauseUI.h" />
    <ClInclude Include="Game\Camera\StartCamPhase.h" />
    <ClInclude Include="Game\Scene\Pause\PauseSystem.h" />
    <ClInclude Include="Game\Application\PlayContext.h" />
    <ClInclude Include="Game\Particle\ParticlePresets.h" />
    <ClInclude Include="Game\Particle\ModelParticleManager.h" />
  </ItemGroup>
  <ItemGroup>
    <Text Include="externals\imgui\LICENSE.txt" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="externals\DirectXTex\DirectXTex_Desktop_2022_Win10.vcxproj">
      <Project>{371b9fa9-4c90-4ac6-a123-aced756d6c77}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="resources\shaders\Object3d.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Object3d.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

============================================================
File Path: MyEngine.vcxproj.filters
============================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <FxCompile Include="resources\shaders\Object3d.VS.hlsl">
      <Filter>Shader</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Object3d.PS.hlsl">
      <Filter>Shader</Filter>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <!-- çµ±åˆã•ã‚ŒãŸClCompileã€‚é‡è¤‡æ’é™¤ãƒ»Filterä¿æŒ -->
    <!-- masterãƒ–ãƒ©ãƒ³ãƒã‹ã‚‰è¿½åŠ ã•ã‚ŒãŸåˆ† -->
    <ClCompile Include="main.cpp" />
    <ClCompile Include="engine\InsideScene\AbstractSceneFactory.cpp">
      <Filter>engine\InsideScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\InsideScene\BaseScene.cpp">
      <Filter>engine\InsideScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\Audio\Audio.cpp">
      <Filter>engine\Audio</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Block\Block.cpp">
      <Filter>Game\Application\Block</Filter>
    </ClCompile>
    <ClCompile Include="Game\Camera\Camera.cpp">
      <Filter>Game\Camera</Filter>
    </ClCompile>
    <ClCompile Include="Game\Collision\Collider.cpp">
      <Filter>Game\Collision</Filter>
    </ClCompile>
    <ClCompile Include="Game\Collision\CollisionManager.cpp">
      <Filter>Game\Collision</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Map\CsvLoader.cpp">
      <Filter>Game\Loader</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\D3DResourceLeakChecker.cpp">
      <Filter>engine\base</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\DirectXCommon.cpp">
      <Filter>engine\base</Filter>
    </ClCompile>
    <ClCompile Include="Game\Particle\ParticleSystem.cpp">
      <Filter>Game\Particle</Filter>
    </ClCompile>
    <ClCompile Include="Game\Particle\ParticleManager.cpp">
      <Filter>Game\Particle</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Enemy\EnemyBase.cpp">
      <Filter>Game\Application\Enemy</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Enemy\EnemyFactory.cpp">
      <Filter>Game\Application\Enemy</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Enemy\FlyingEnemy.cpp">
      <Filter>Game\Application\Enemy</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Enemy\NormalEnemy.cpp">
      <Filter>Game\Application\Enemy</Filter>
    </ClCompile>
    <ClCompile Include="engine\InsideScene\Framework.cpp">
      <Filter>engine\InsideScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\InsideScene\SceneManager.cpp">
      <Filter>engine\InsideScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\InsideScene\SceneFactory.cpp">
      <Filter>engine\InsideScene</Filter>
    </ClCompile>
    <ClCompile Include="Game\Scene\GamePlayScene.cpp">
      <Filter>Game\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Game\Scene\MyGame.cpp">
      <Filter>Game\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Game\Scene\TitleScene.cpp">
      <Filter>Game\Scene</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\ImGuiManager.cpp">
      <Filter>engine\base</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\Input.cpp">
      <Filter>engine\base</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\Logger.cpp">
      <Filter>engine\base</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\SrvManager.cpp">
      <Filter>engine\base</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\StringUtility.cpp">
      <Filter>engine\base</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\TextureManager.cpp">
      <Filter>engine\base</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\WinAPI.cpp">
      <Filter>engine\base</Filter>
    </ClCompile>
    <ClCompile Include="Game\Loader\LevelLoader.cpp">
      <Filter>Game\Application\Loader</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\MakeMatrix.cpp">
      <Filter>engine\math</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Object3DCommon.cpp">
      <Filter>engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Model.cpp">
      <Filter>engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\ModelCommon.cpp">
      <Filter>engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\ModelManager.cpp">
      <Filter>engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Object3D.cpp">
      <Filter>engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\ModelList.cpp">
      <Filter>Game</Filter>
    </ClCompile>
    <ClCompile Include="engine\2d\RenderTexture.cpp">
      <Filter>engine\2d</Filter>
    </ClCompile>
    <ClCompile Include="engine\2d\Sprite.cpp">
      <Filter>engine\2d</Filter>
    </ClCompile>
    <ClCompile Include="engine\2d\SpriteCommon.cpp">
      <Filter>engine\2d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\SkyBox\SkyBox.cpp">
      <Filter>engine\3d\SkyBox</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\StageType.cpp">
      <Filter>Game\Application\Map</Filter>
    </ClCompile>
    <ClCompile Include="Game\Camera\CameraController.cpp">
      <Filter>Game\Camera</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Player\Player.cpp">
      <Filter>Game\Application\Player</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Map\Map.cpp">
      <Filter>Game\Application\Map</Filter>
    </ClCompile>
    <ClCompile Include="Game\Scene\StageClearScene.cpp">
      <Filter>Game\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Game\Scene\SceneSelectGraph\StageSelectGraph.cpp">
      <Filter>Game\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Game\Scene\StageSelectScene.cpp">
      <Filter>Game\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Game\Scene\Pause\PauseUI.cpp">
      <Filter>Game\Application\UI</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\BackGround.cpp">
      <Filter>Game\Application\UI</Filter>
    </ClCompile>
    <ClCompile Include="Game\Scene\SceneTransition\SceneTransition.cpp">
      <Filter>Game\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Game\Camera\StartCamPhase.cpp" />
    <ClCompile Include="Game\Scene\Pause\PauseSystem.cpp" />
    <ClCompile Include="Game\Application\UI\DamageFeedBack.cpp" />
    <ClCompile Include="Game\Application\UI\GamePlayHUD.cpp" />
    <ClCompile Include="Game\Application\PlayContext.cpp" />
    <ClCompile Include="Game\Particle\ParticlePresets.cpp" />
    <ClCompile Include="Game\Particle\ModelParticleManager.cpp" />
  </ItemGroup>
  <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã®ItemGroupã‚‚åŒæ§˜ã«çµ±åˆã™ã‚‹å¿…è¦ã‚ã‚Šï¼ˆé•·ã„ãŸã‚ã“ã“ã§ã¯çœç•¥ï¼‰ -->
  <ItemGroup>
    <ClInclude Include="engine\InsideScene\AbstractSceneFactory.h">
      <Filter>engine\InsideScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\InsideScene\BaseScene.h">
      <Filter>engine\InsideScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\Audio\Audio.h">
      <Filter>engine\Audio</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Block\Block.h">
      <Filter>Game\Application\Block</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Block\BlockType.h">
      <Filter>Game\Application\Block</Filter>
    </ClInclude>
    <ClInclude Include="Game\Camera\Camera.h">
      <Filter>Game\Camera</Filter>
    </ClInclude>
    <ClInclude Include="Game\Collision\Collider.h">
      <Filter>Game\Collision</Filter>
    </ClInclude>
    <ClInclude Include="Game\Collision\CollisionManager.h">
      <Filter>Game\Collision</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Map\CsvLoader.h">
      <Filter>Game\Loader</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\D3DResourceLeakChecker.h">
      <Filter>engine\base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\DirectXCommon.h">
      <Filter>engine\base</Filter>
    </ClInclude>
    <ClInclude Include="Game\Particle\ParticleSystem.h">
      <Filter>Game\Particle</Filter>
    </ClInclude>
    <ClInclude Include="Game\Particle\ParticleManager.h">
      <Filter>Game\Particle</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Enemy\EnemyBase.h">
      <Filter>Game\Application\Enemy</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Enemy\EnemyFactory.h">
      <Filter>Game\Application\Enemy</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Enemy\FlyingEnemy.h">
      <Filter>Game\Application\Enemy</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Enemy\NormalEnemy.h">
      <Filter>Game\Application\Enemy</Filter>
    </ClInclude>
    <ClInclude Include="engine\InsideScene\Framework.h">
      <Filter>engine\InsideScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\InsideScene\SceneManager.h">
      <Filter>engine\InsideScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\InsideScene\SceneFactory.h">
      <Filter>engine\InsideScene</Filter>
    </ClInclude>
    <ClInclude Include="Game\Scene\GamePlayScene.h">
      <Filter>Game\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Game\Scene\MyGame.h">
      <Filter>Game\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Game\Scene\TitleScene.h">
      <Filter>Game\Scene</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\ImGuiManager.h">
      <Filter>engine\base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\Input.h">
      <Filter>engine\base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\Logger.h">
      <Filter>engine\base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\SrvManager.h">
      <Filter>engine\base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\StringUtility.h">
      <Filter>engine\base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\TextureManager.h">
      <Filter>engine\base</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\WinAPI.h">
      <Filter>engine\base</Filter>
    </ClInclude>
    <ClInclude Include="Game\Loader\LevelLoader.h">
      <Filter>Game\Application\Loader</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\MakeMatrix.h">
      <Filter>engine\math</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\MyMath.h">
      <Filter>engine\math</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Model.h">
      <Filter>engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\ModelCommon.h">
      <Filter>engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\ModelManager.h">
      <Filter>engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Object3DCommon.h">
      <Filter>engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Object3D.h">
      <Filter>engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\2d\RenderTexture.h">
      <Filter>engine\2d</Filter>
    </ClInclude>
    <ClInclude Include="engine\2d\Sprite.h">
      <Filter>engine\2d</Filter>
    </ClInclude>
    <ClInclude Include="engine\2d\SpriteCommon.h">
      <Filter>engine\2d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\SkyBox\SkyBox.h">
      <Filter>engine\3d\SkyBox</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\StageType.h">
      <Filter>Game\Application\Map</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\ModelList.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Game\Camera\CameraController.h">
      <Filter>Game\Camera</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Enemy\EnemyType.h">
      <Filter>Game\Application\Enemy</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Player\Player.h">
      <Filter>Game\Application\Player</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Map\Map.h">
      <Filter>Game\Application\Map</Filter>
    </ClInclude>
    <ClInclude Include="Game\Scene\StageClearScene.h">
      <Filter>Game\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Game\Scene\SceneSelectGraph\StageSelectGraph.h">
      <Filter>Game\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Game\Scene\StageSelectScene.h">
      <Filter>Game\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Game\Scene\Pause\PauseUI.h">
      <Filter>Game\Application\UI</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\BackGround.h">
      <Filter>Game\Application\UI</Filter>
    </ClInclude>
    <ClInclude Include="Game\Scene\SceneTransition\SceneTransition.h">
      <Filter>Game\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Game\Camera\StartCamPhase.h" />
    <ClInclude Include="Game\Scene\Pause\PauseSystem.h" />
    <ClInclude Include="Game\Application\UI\DamageFeedBack.h" />
    <ClInclude Include="Game\Application\UI\GamePlayHUD.h" />
    <ClInclude Include="Game\Application\PlayContext.h" />
    <ClInclude Include="Game\Particle\ParticlePresets.h" />
    <ClInclude Include="Game\Particle\ModelParticleManager.h" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="engine">
      <UniqueIdentifier>{ee17d952-0bf6-4acb-a07a-097567b033f2}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\2d">
      <UniqueIdentifier>{e6dec0f4-c1ba-4564-b7f8-43a4702b7709}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\3d">
      <UniqueIdentifier>{3d6b7474-81f6-49dd-acae-417a23b1d4ae}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\Audio">
      <UniqueIdentifier>{71dd5415-3c4e-4bb0-b3f9-1bffe38d396b}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\math">
      <UniqueIdentifier>{8c514b5d-934d-48fe-adfb-7259d210c0a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game">
      <UniqueIdentifier>{248199f7-9718-4f0f-a4fc-d29fbcb161cd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application">
      <UniqueIdentifier>{2b6d880a-23c0-407b-bfe4-d3e390002643}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Camera">
      <UniqueIdentifier>{a511e52b-bcbb-4b6c-9164-4d31d4b5270b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Collision">
      <UniqueIdentifier>{434365a8-cfd3-4303-9644-1d8cc1e7eefd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Loader">
      <UniqueIdentifier>{b43b2173-3150-4925-a8f5-73e7c339636f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Particle">
      <UniqueIdentifier>{712eb409-80f7-4d34-b7d2-020031345795}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Scene">
      <UniqueIdentifier>{c6eecef6-e7d8-4050-a866-f31dd4a028a8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application\Enemy">
      <UniqueIdentifier>{431302d6-9528-409f-a6cc-c4076693d624}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application\Block">
      <UniqueIdentifier>{9f952b4e-216f-4d0e-9d9b-e0526d0f7dd8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application\Player">
      <UniqueIdentifier>{a5f28842-bbb1-4ea9-9cb7-621672d64d7f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application\Loader">
      <UniqueIdentifier>{956e0651-fb05-4ab0-bbd3-e6c26087402f}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\3d\SkyBox">
      <UniqueIdentifier>{6d5cf266-090d-47f2-8455-e452b0e5657b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application\Map">
      <UniqueIdentifier>{5250f676-f79a-456a-bd60-fd967b81f381}</UniqueIdentifier>
    </Filter>
    <Filter Include="Shader">
      <UniqueIdentifier>{588ada5e-8e2c-43c1-8997-4bcf269d6a66}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\InsideScene">
      <UniqueIdentifier>{90e59181-f685-48db-808d-73212c0b33ea}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application\UI">
      <UniqueIdentifier>{5c38ea4b-3666-4e57-aad9-65c2b1358921}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\base">
      <UniqueIdentifier>{0790bce2-65e2-41da-bfa7-48956890b70c}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="externals\imgui\LICENSE.txt">
      <Filter>Game\Application</Filter>
    </Text>
  </ItemGroup>
</Project>

============================================================
File Path: engine/2d/RenderTexture.cpp
============================================================
#include "RenderTexture.h"
#include "engine/base/DirectXCommon.h"
#include "engine/base/SrvManager.h"
#include <map>

using namespace Engine;

RenderTexture::RenderTexture()
{
}
RenderTexture::~RenderTexture()
{
}
void RenderTexture::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, uint32_t width, uint32_t height, 
	DXGI_FORMAT format, const Vector4& clearColor)
{
	/// å¼•ãæ•°ã‚’æ¸¡ã™
	this->dxCommon_ = dxCommon;
	this->srvManager_ = srvManager;
	this->clearColor_ = clearColor;


	const Vector4 kRenderTargetClearValue = clearColor;
	textureResource = CreateRenderTextureResource(
		dxCommon_->GetDevice(),width, height,
		DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, kRenderTargetClearValue
	);

	rtvHeap = dxCommon_->CreateDescriptorHeap(
		D3D12_DESCRIPTOR_HEAP_TYPE_RTV, 1, false);
	rtvHandle = dxCommon_->GetCPUDescriptorHandle(rtvHeap, dxCommon_->GetDescriptorSizeRTV(), 0);


	dxCommon_->GetDevice()->CreateRenderTargetView(textureResource.Get(), nullptr, rtvHandle);


	srvIndex = srvManager_->Allocate();
	srvManager_->CreateSRVforTexture2D(srvIndex, textureResource.Get(), format, 1);

	currentState = D3D12_RESOURCE_STATE_RENDER_TARGET;

	CreateGraphicsPipeLine();
	CreateVertexBuffer();
	
}

Microsoft::WRL::ComPtr<ID3D12Resource> RenderTexture::CreateRenderTextureResource(Microsoft::WRL::ComPtr<ID3D12Device> device, uint32_t width, uint32_t height, DXGI_FORMAT format, const Vector4& clearColor)
{
	
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	resourceDesc.Width = width;
	resourceDesc.Height = height;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.Format = format;
	resourceDesc.SampleDesc.Count = 1;
	resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;

	D3D12_HEAP_PROPERTIES heapProp{};
	heapProp.Type = D3D12_HEAP_TYPE_DEFAULT;

	D3D12_CLEAR_VALUE clear{};
	clear.Format = format;
	clear.Color[0] = clearColor.x;
	clear.Color[1] = clearColor.y;
	clear.Color[2] = clearColor.z;
	clear.Color[3] = clearColor.w;

	
	HRESULT hr = device->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_RENDER_TARGET,
		&clear,
		IID_PPV_ARGS(&textureResource));
	assert(SUCCEEDED(hr));

	return textureResource;
}

void RenderTexture::BeginRender()
{
	if (currentState != D3D12_RESOURCE_STATE_RENDER_TARGET) {
		auto barrier = CD3DX12_RESOURCE_BARRIER::Transition(
			textureResource.Get(),
			currentState,
			D3D12_RESOURCE_STATE_RENDER_TARGET
		);
		dxCommon_->GetCommandList()->ResourceBarrier(1, &barrier);
		currentState = D3D12_RESOURCE_STATE_RENDER_TARGET;
	}

	// DSV ã®è¨­å®š
	D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle = dxCommon_->GetDSVHandle();
	dxCommon_->GetCommandList()->OMSetRenderTargets(1, &rtvHandle, false, &dsvHandle);

	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã¨ã‚·ã‚¶ãƒ¼è¨­å®š
	D3D12_VIEWPORT viewport{};
	viewport.TopLeftX = 0.0f;
	viewport.TopLeftY = 0.0f;
	viewport.Width = static_cast<float>(resourceDesc.Width);
	viewport.Height = static_cast<float>(resourceDesc.Height);
	viewport.MinDepth = 0.0f;
	viewport.MaxDepth = 1.0f;

	D3D12_RECT scissorRect{};
	scissorRect.left = 0;
	scissorRect.top = 0;
	scissorRect.right = static_cast<LONG>(resourceDesc.Width);
	scissorRect.bottom = static_cast<LONG>(resourceDesc.Height);

	dxCommon_->GetCommandList()->RSSetViewports(1, &viewport);
	dxCommon_->GetCommandList()->RSSetScissorRects(1, &scissorRect);

	// ã‚¯ãƒªã‚¢ã‚«ãƒ©ãƒ¼
	float  clearColor[4] = { clearColor_.x,clearColor_.y,clearColor_.z,clearColor_.w };
	dxCommon_->GetCommandList()->ClearRenderTargetView(
		rtvHandle,
		clearColor,
		0,
		nullptr
	);
}


void RenderTexture::EndRender()
{
	if (currentState != D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE) {
		auto barrier = CD3DX12_RESOURCE_BARRIER::Transition(
			textureResource.Get(),
			currentState,
			D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE
		);
		dxCommon_->GetCommandList()->ResourceBarrier(1, &barrier);
		currentState = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
	}

}

D3D12_GPU_DESCRIPTOR_HANDLE RenderTexture::GetGPUHandle() const {
	return srvManager_->GetGPUDescriptorHandle(srvIndex);
}


void RenderTexture::Draw() {

	//// SRVãƒ’ãƒ¼ãƒ—ã‚’è¨­å®šï¼ˆãƒ«ãƒ¼ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«ç”¨ï¼‰
	//ID3D12DescriptorHeap* heaps[] = { srvManager_->GetSRVHeap().Get()};
	//dxCommon_->GetCommandList()->SetDescriptorHeaps(1, heaps);

	// PSO / RootSignature ã‚’ã‚»ãƒƒãƒˆ
	dxCommon_->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
	dxCommon_->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());

	// SRVã‚’ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«ãƒã‚¤ãƒ³ãƒ‰ï¼ˆãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿0ã«SRVãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰
	dxCommon_->GetCommandList()->SetGraphicsRootDescriptorTable(0, GetGPUHandle());

	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒãƒ­ã‚¸ãƒ¼ã‚’è¨­å®šï¼ˆä¸‰è§’å½¢ãƒªã‚¹ãƒˆï¼‰
	dxCommon_->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	dxCommon_->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚’ä½¿ã‚ãš3é ‚ç‚¹ã§å…¨ç”»é¢æç”»ï¼ˆVSã§SV_VertexIDä½¿ç”¨å‰æï¼‰
	dxCommon_->GetCommandList()->DrawInstanced(3, 1, 0, 0);
}




void RenderTexture::CreateGraphicsPipeLine() {

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	CreateRootSignature();

	// é ‚ç‚¹ã®ä½ç½®ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’è¨­å®š
	inputElementDescs[0].SemanticName = "POSITION";
	inputElementDescs[0].SemanticIndex = 0;
	inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã®åº§æ¨™
	inputElementDescs[1].SemanticName = "TEXCOORD";
	inputElementDescs[1].SemanticIndex = 0;
	inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	

	inputLayoutDescs.pInputElementDescs = nullptr;
	inputLayoutDescs.NumElements = 0;

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ›¸ãè¾¼ã¿ãƒã‚¹ã‚¯ã‚’è¨­å®šã€‚å…¨ã¦ã®è‰²ãƒãƒ£ãƒ³ãƒãƒ«ã«æ›¸ãè¾¼ã¿ã‚’è¨±å¯
	blendDesc.RenderTarget[0].RenderTargetWriteMask =
		D3D12_COLOR_WRITE_ENABLE_ALL;


	// ã‚«ãƒªãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®š
	rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
	// ãƒãƒªã‚´ãƒ³ã®ãƒ•ã‚£ãƒ«ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®šã€‚ãƒãƒªã‚´ãƒ³ã®å¡—ã‚Šæ½°ã—
	rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;

	//ã€€é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	vertexShaderBlob = dxCommon_->CompileShader(
		L"resources/shaders/Fullscreen.VS.hlsl", L"vs_6_0");
	assert(vertexShaderBlob != nullptr);
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	pixelShaderBlob = dxCommon_->CompileShader(
		L"resources/shaders/Grayscale.PS.hlsl", L"ps_6_0");
	assert(pixelShaderBlob != nullptr);


	//Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
	depthStencilDesc.DepthEnable = false;
	//æ›¸ãè¾¼ã¿ã—ã¾ã™
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
	//æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;



	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
	graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();
	// ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.InputLayout = { nullptr,0 };
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®è¨­å®š
	graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),vertexShaderBlob->GetBufferSize() };
	graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),pixelShaderBlob->GetBufferSize() };
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.BlendState = blendDesc;
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	graphicsPipelineStateDesc.RasterizerState = rasterizerDesc;
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ãƒãƒ­æ™‚ã®è¨­å®š
	graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	// DepthStencilã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_UNKNOWN;

	HRESULT hr = dxCommon_->GetDevice()->CreateGraphicsPipelineState(
		&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState));

	assert(SUCCEEDED(hr));
}

void RenderTexture::CreateRootSignature()
{
#pragma region RootParameter
	//RootSignatureä½œæˆ
	descriptionRootSignature.Flags =
		D3D12_ROOT_SIGNATURE_FLAG_NONE;
#pragma region DescriptorRange
	D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
	descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
	descriptorRange[0].NumDescriptors = 1;
	descriptorRange[0].BaseShaderRegister = 0;
	descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;
#pragma endregion

	//RootParameterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚ä»Šå›ã¯çµæœãŒï¼‘ã¤ã ã‘ãªã®ã§é•·ã•ï¼‘ã®é…åˆ—
	D3D12_ROOT_PARAMETER rootParam[1] = {};
	rootParam[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	rootParam[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParam[0].DescriptorTable.pDescriptorRanges = descriptorRange;
	rootParam[0].DescriptorTable.NumDescriptorRanges = 1;

	descriptionRootSignature.pParameters = rootParam;
	descriptionRootSignature.NumParameters = 1;
#pragma endregion



	D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
	staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
	staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	//staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	//staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;
	staticSamplers[0].ShaderRegister = 0;
	staticSamplers[0].RegisterSpace = 0;
	staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;

	descriptionRootSignature.pStaticSamplers = staticSamplers;
	descriptionRootSignature.NumStaticSamplers = 1;

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºçµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr <ID3DBlob> signatureBlob = nullptr;
	// ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç™ºç”Ÿã—ãŸå ´åˆã«æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr <ID3DBlob> errorBlob = nullptr;
	HRESULT hr = D3D12SerializeRootSignature(&descriptionRootSignature, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(hr)) {
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	hr = dxCommon_->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
	assert(SUCCEEDED(hr));

}

void RenderTexture::CreateVertexBuffer() {
	TextureVertex vertices[] = {
		{{-1.0f, -1.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},
		{{-1.0f,  3.0f, 0.0f, 1.0f}, {0.0f, -1.0f}},
		{{ 3.0f, -1.0f, 0.0f, 1.0f}, {2.0f, 1.0f}},
	};

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ä½œæˆï¼ˆUPLOADãƒ’ãƒ¼ãƒ—ï¼‰
	vertexBufferResource = dxCommon_->CreateBufferResource(sizeof(vertices));

	// Map ã—ã¦ã‹ã‚‰å®‰å…¨ã«ã‚³ãƒ”ãƒ¼
	void* mappedPtr = nullptr;
	HRESULT hr = vertexBufferResource->Map(0, nullptr, &mappedPtr);
	assert(SUCCEEDED(hr));
	memcpy(mappedPtr, vertices, sizeof(vertices));
	vertexBufferResource->Unmap(0, nullptr);

	// ãƒ“ãƒ¥ãƒ¼ã®è¨­å®š
	vertexBufferView.BufferLocation = vertexBufferResource->GetGPUVirtualAddress();
	vertexBufferView.SizeInBytes = sizeof(vertices);
	vertexBufferView.StrideInBytes = sizeof(TextureVertex);
}


============================================================
File Path: engine/2d/RenderTexture.h
============================================================
#pragma once
#include <d3d12.h>
#include <wrl.h>
#include "engine/math/MyMath.h"
#include "engine/base/Logger.h"
#include "engine/base/SrvManager.h"

namespace Engine {
	class DirectXCommon;
}
class SrvManager;
/// <summary>
/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¯ãƒ©ã‚¹
/// </summary>
class RenderTexture
{
public:
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	RenderTexture();

	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~RenderTexture();

	/// <summary>
	/// åˆæœŸåŒ–
	/// RenderTarget ãƒªã‚½ãƒ¼ã‚¹ã‚’ç”Ÿæˆã—ã€RTV / SRV ã‚’ä½œæˆã™ã‚‹ã€‚ã¾ãŸã€æç”»ã«å¿…è¦ãªãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã¨é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®åˆæœŸåŒ–ã‚‚è¡Œã†ã€‚
	/// </summary>
	/// <param name="dxCommon">DirectX12 ã®ãƒ‡ãƒã‚¤ã‚¹ãƒ»ã‚³ãƒãƒ³ãƒ‰ç®¡ç†ã‚’è¡Œã†å…±é€šã‚¯ãƒ©ã‚¹</param>
	/// <param name="srvManager">RV ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ç®¡ç†ãŠã‚ˆã³ SRV ä½œæˆã‚’è¡Œã†ãƒãƒãƒ¼ã‚¸ãƒ£</param>
	/// <param name="width">ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®æ¨ªå¹…ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰</param>
	/// <param name="height">ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç¸¦å¹…ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰</param>
	/// <param name="format">SRV ã¨ã—ã¦ä½¿ç”¨ã™ã‚‹éš›ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ</param>
	/// <param name="clearColor">ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã‚’ã‚¯ãƒªã‚¢ã™ã‚‹éš›ã®ã‚¯ãƒªã‚¢ã‚«ãƒ©ãƒ¼</param>
	void Initialize(Engine::DirectXCommon* dxCommon, SrvManager* srvManager, uint32_t width, uint32_t height, DXGI_FORMAT format, const Vector4& clearColor);

	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®é–‹å§‹
	/// </summary>
	void BeginRender();

	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®çµ‚äº†
	/// </summary>
	void EndRender();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();


	/// <summary>
	///RenderTarget ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã‚’ç”Ÿæˆ
	/// æŒ‡å®šã•ã‚ŒãŸã‚µã‚¤ã‚ºãƒ»ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ 2D ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½œæˆã—ã€RenderTarget ã¨ã—ã¦ä½¿ç”¨å¯èƒ½ãªçŠ¶æ…‹ã§åˆæœŸåŒ–ã™ã‚‹
	/// </summary>
	/// <param name="device">DirectX12 ã®ãƒ‡ãƒã‚¤ã‚¹</param>
	/// <param name="width">ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®æ¨ªå¹…ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰</param>
	/// <param name="height">ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ç¸¦å¹…ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰</param>
	/// <param name="format">ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ</param>
	/// <param name="clearColor">ä½¿ç”¨ã™ã‚‹ã‚¯ãƒªã‚¢ã‚«ãƒ©ãƒ¼</param>
	/// <returns>ä½œæˆã•ã‚ŒãŸ RenderTarget ç”¨ ID3D12Resource</returns>
	Microsoft::WRL::ComPtr<ID3D12Resource> CreateRenderTextureResource(Microsoft::WRL::ComPtr<ID3D12Device>device, uint32_t width, uint32_t height, DXGI_FORMAT format, const Vector4& clearColor);

private:
	/// <summary>
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	/// </summary>
	void CreateGraphicsPipeLine();
	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	/// </summary>
	void CreateRootSignature();
	/// <summary>
	/// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	/// </summary>
	void CreateVertexBuffer();

public: // Getter, Setter
	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’å–å¾—
	/// </summary>
	D3D12_GPU_DESCRIPTOR_HANDLE GetGPUHandle() const;
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	/// DirectXCommonãƒã‚¤ãƒ³ã‚¿
	Engine::DirectXCommon* dxCommon_ = nullptr;
	/// SrvManagerãƒã‚¤ãƒ³ã‚¿
	SrvManager* srvManager_ = nullptr;

	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> texture;

	/// RTVãƒ’ãƒ¼ãƒ—
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> rtvHeap;
	/// RTVãƒãƒ³ãƒ‰ãƒ«
	D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle;
	/// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	uint32_t srvIndex = 0;
	/// ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ†ãƒ¼ãƒˆ
	D3D12_RESOURCE_STATES currentState = D3D12_RESOURCE_STATE_RENDER_TARGET;

	/// ã‚¯ãƒªã‚¢ã‚«ãƒ©ãƒ¼
	Vector4 clearColor_;

private:
	D3D12_INPUT_LAYOUT_DESC inputLayoutDescs{};
	D3D12_INPUT_ELEMENT_DESC inputElementDescs[2] = {};
	Microsoft::WRL::ComPtr<ID3D12RootSignature> rootSignature;
	/// ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ‡ã‚¹ã‚¯
	D3D12_BLEND_DESC blendDesc{};
	D3D12_RASTERIZER_DESC rasterizerDesc{};
	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob = nullptr;
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob = nullptr;
	// DepthStencilStateã®è¨­å®š
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};
	// RootSignatureä½œæˆ
	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ä½œæˆ
	Microsoft::WRL::ComPtr <ID3D12PipelineState> graphicsPipelineState = nullptr;
	// VertexBufferResource
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexBufferResource;
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView{};

	D3D12_RESOURCE_DESC resourceDesc{};

	Microsoft::WRL::ComPtr<ID3D12Resource> textureResource;

};



============================================================
File Path: engine/2d/Sprite.cpp
============================================================
#include "Sprite.h"
#include "SpriteCommon.h"
#include "TextureManager.h"
void Sprite::Initialize(std::string_view textureFilePath)
{
	this->textureFilePath_ = textureFilePath;
	CreateVertexResourceData();
	CreateMaterialResource();
	CreateTransformationMatrixData();
	// å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
	TextureManager::GetInstance()->LoadTexture(textureFilePath_);
	textureIndex = TextureManager::GetInstance()->GetSrvIndex(textureFilePath_);
	transform = { {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f} };
	AdjustTextureSize();
}

void Sprite::Update()
{
#pragma region é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®è¨­å®š
	float left = 0.0f - anchorPoint.x;
	float right = 1.0f - anchorPoint.x;
	float top = 0.0f - anchorPoint.y;
	float bottom = 1.0f - anchorPoint.y;

	// å·¦å³åè»¢
	if (isFlipX) {
		left = -left;
		right = -right;
	}

	// ä¸Šä¸‹åè»¢
	if (isFlipY) {
		top = -top;
		bottom = -bottom;
	}

	const DirectX::TexMetadata& metadata = TextureManager::GetInstance()->GetMetadata(textureFilePath_);

	float texleft = textureLeftTop.x / metadata.width;
	float texright = (textureLeftTop.x + textureSize.x) / metadata.width;
	float textop = textureLeftTop.y / metadata.height;
	float texbottom = (textureLeftTop.y + textureSize.y) / metadata.height;

	// 1æšç›®ã®ä¸‰è§’å½¢
	// å·¦ä¸Š
	vertexData[0].position = { left, bottom, 0.0f, 1.0f };
	vertexData[0].texcoord = { texleft, texbottom };
	// å·¦ä¸‹
	vertexData[1].position = { left, top, 0.0f, 1.0f };
	vertexData[1].texcoord = { texleft, textop };
	//	å³ä¸‹
	vertexData[2].position = { right, bottom, 0.0f, 1.0f };
	vertexData[2].texcoord = { texright, texbottom };

	// 2æšç›®ã®ä¸‰è§’å½¢
	// å·¦ä¸Š
	vertexData[3].position = vertexData[1].position;
	vertexData[3].texcoord = vertexData[1].texcoord;
	// å³ä¸Š
	vertexData[4].position = { right, top, 0.0f, 1.0f };
	vertexData[4].texcoord = { texright, textop };
	// å³ä¸‹
	vertexData[5].position = vertexData[2].position;
	vertexData[5].texcoord = vertexData[2].texcoord;
#pragma endregion
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€(6å€‹åˆ†)
	for (int i = 0; i < 6; ++i) {
		vertexData[i].normal = { 0.0f, 0.0f, -1.0f };
	}


	// Transformæƒ…å ±ã‚’ä½œã‚‹

	transform.translate = { position.x, position.y, 0.0f };
	transform.rotate = { 0.0f, 0.0f, rotation };
	transform.scale = { size.x, size.y, 1.0f };
	// Transformã‹ã‚‰Worldè¡Œåˆ—ã‚’ä½œã‚‹
	Matrix4x4 worldMatrix = MakeAffineMatrix(transform.scale, transform.rotate, transform.translate);

	// ViewMatrixã‚’ä½œã£ã¦å˜ä½è¡Œåˆ—ã‚’ä»£å…¥
	Matrix4x4 viewMatrix = MakeIdentity4x4();

	// ProjectionMatrixã‚’ä½œã£ã¦å¹³è¡ŒæŠ•å½±è¡Œåˆ—ã‚’ä»£å…¥
	Matrix4x4 projectionMatrix = MakeOrthographicMatrix(0.0f, 0.0f, float(WinAPI::kClientWidth), float(WinAPI::kClientHeight), 0.0f, 100.0f);
	Matrix4x4 worldProjectionMatrix = Multiply(worldMatrix, Multiply(viewMatrix, projectionMatrix));

	// WVPè¡Œåˆ—ã‚’è¨ˆç®—
	transformationMatrix->WVP = worldProjectionMatrix;
	transformationMatrix->World = worldMatrix;
}





void Sprite::Draw()
{

	//Spriteã®æç”»æº–å‚™ã€‚Spriteã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
	SpriteCommon::GetInstance().DrawSettingCommon();

	// Vertex bufferViewã‚’è¨­å®š
	SpriteCommon::GetInstance().GetDxCommon()->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);
	// IndexBufferViewã‚’è¨­å®š
	SpriteCommon::GetInstance().GetDxCommon()->GetCommandList()->IASetIndexBuffer(&indexBufferView);
	// ãƒãƒ†ãƒªã‚¢ãƒ«CBufferã®å ´æ‰€ã‚’è¨­å®š
	SpriteCommon::GetInstance().GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());
	// åº§æ¨™å¤‰æ›è¡Œåˆ—CBufferã®å ´æ‰€ã‚’è¨­å®š
	SpriteCommon::GetInstance().GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(1, transformationMatrixResource->GetGPUVirtualAddress());
	// SRVã®DescriptorHeapã®å ´æ‰€ã‚’è¨­å®š
	SpriteCommon::GetInstance().GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(2, TextureManager::GetInstance()->GetSrvHandleGPU(textureFilePath_));
	// æç”»
	SpriteCommon::GetInstance().GetDxCommon()->GetCommandList()->DrawInstanced(6, 1, 0, 0);
}

void Sprite::CreateVertexResourceData()
{

	// VertexResourceã‚’ä½œã‚‹
	vertexResource = SpriteCommon::GetInstance().CreateSpriteVertexResource();
	// VertexBufferViewã‚’ä½œæˆã™ã‚‹(å€¤ã‚’è¨­å®šã™ã‚‹ã ã‘)
	vertexBufferView.BufferLocation = vertexResource->GetGPUVirtualAddress();
	// 6å€‹åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ã®ã§6å€
	vertexBufferView.SizeInBytes = sizeof(VertexData) * 6;
	// 1é ‚ç‚¹åˆ†ã®ã‚µã‚¤ã‚º
	vertexBufferView.StrideInBytes = sizeof(VertexData);

	// IndexResourceã‚’ä½œã‚‹
	indexResource = SpriteCommon::GetInstance().CreateSpriteIndexResource();

	// IndexBufferViewã‚’ä½œæˆã™ã‚‹
	indexBufferView.BufferLocation = indexResource->GetGPUVirtualAddress();
	// 6å€‹åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ã®ã§6å€
	indexBufferView.SizeInBytes = sizeof(uint32_t) * 6;
	// 1é ‚ç‚¹åˆ†ã®ã‚µã‚¤ã‚º
	indexBufferView.Format = DXGI_FORMAT_R32_UINT;

	// IndexResourceã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦indexDataã«å‰²ã‚Šå½“ã¦ã‚‹
	indexData = nullptr;	// nullptrã‚’ä»£å…¥ã—ã¦ãŠã
	indexResource->Map(0, nullptr, reinterpret_cast<void**>(&indexData));	// ãƒãƒƒãƒ—ã™ã‚‹

	// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€(4ç‚¹åˆ†)
	indexData[0] = 0; indexData[1] = 1; indexData[2] = 2;
	indexData[3] = 1; indexData[4] = 3; indexData[5] = 2;

	// VertexResourceã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦vertexDataã«å‰²ã‚Šå½“ã¦ã‚‹
	vertexData = nullptr;	// nullptrã‚’ä»£å…¥ã—ã¦ãŠã
	vertexResource->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));	// ãƒãƒƒãƒ—ã™ã‚‹

}


void Sprite::CreateMaterialResource() {
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã™ã‚‹
	materialResource = SpriteCommon::GetInstance().GetDxCommon()->CreateBufferResource(sizeof(Material));
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦materialã«å‰²ã‚Šå½“ã¦ã‚‹
	materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));	// ãƒãƒƒãƒ—ã™ã‚‹

	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	materialData->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	materialData->enableLighting = false;
	materialData->uvTransform = MakeIdentity4x4();
}

void Sprite::CreateTransformationMatrixData()
{
	// å¤‰æ›è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã™ã‚‹
	transformationMatrixResource = SpriteCommon::GetInstance().GetDxCommon()->CreateBufferResource(sizeof(TransformationMatrix));

	// å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦transformationMatrixã«å‰²ã‚Šå½“ã¦ã‚‹
	transformationMatrix = nullptr; // nullptrã‚’ä»£å…¥ã—ã¦ãŠã
	transformationMatrixResource->Map(0, nullptr, reinterpret_cast<void**>(&transformationMatrix)); // ãƒãƒƒãƒ—ã™ã‚‹

	//å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
	transformationMatrix->WVP = MakeIdentity4x4();
	transformationMatrix->World = MakeIdentity4x4();
}

void Sprite::AdjustTextureSize()
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	const DirectX::TexMetadata& metadata = TextureManager::GetInstance()->GetMetadata(textureFilePath_);
	textureSize = { static_cast<float>(metadata.width),static_cast<float>(metadata.height) };
	// ç”»åƒã‚µã‚¤ã‚ºã‚’ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹
	size = textureSize;
}



============================================================
File Path: engine/2d/Sprite.h
============================================================
#pragma once
#include "MyMath.h"
#include <d3d12.h>
#include <wrl.h>
#include "MakeMatrix.h"
class SpriteCommon;
/// <summary>
/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚¯ãƒ©ã‚¹
/// </summary>
class Sprite
{
public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize(std::string_view textureFilePath);
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

public:	// Getter/Setter
	/// <summary>
	/// åº§æ¨™å–å¾— / è¨­å®š
	/// </summary>
	/// <returns></returns>
	const Vector2& GetPosition()const { return position; }
	void SetPosition(const Vector2& position) { this->position = position; }
	/// <summary>
	/// å›è»¢å–å¾— / è¨­å®š
	/// </summary>
	float GetRotation()const { return rotation; }
	void SetRotation(float rotation) { this->rotation = rotation; }
	/// <summary>
	/// è‰²å–å¾— / è¨­å®š
	/// </summary>
	const Vector4& GetColor()const { return materialData->color; }
	void SetColor(const Vector4& color) { materialData->color = color; }
	/// <summary>
	/// ã‚µã‚¤ã‚ºå–å¾— / è¨­å®š
	/// </summary>
	const Vector2& GetSize()const { return size; }
	void SetSize(const Vector2& size) { this->size = size; }

	/// <summary>
	/// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆå–å¾— / è¨­å®š
	/// </summary>
	const Vector2& GetAnchorPoint()const { return anchorPoint; }
	void SetAnchorPoint(const Vector2& anchorPoint) { this->anchorPoint = anchorPoint; }

	/// <summary>
	/// FlipXå–å¾— / è¨­å®š
	/// </summary>
	bool GetFlipX()const { return isFlipX; }
	void SetFlipX(bool isFlipX) { this->isFlipX = isFlipX; }
	/// <summary>
	/// FlipYå–å¾— / è¨­å®š
	/// </summary>
	bool GetFlipY()const { return isFlipY; }
	void SetFlipY(bool isFlipY) { this->isFlipY = isFlipY; }
	/// <summary>
	/// TextureLeftTopå–å¾— / è¨­å®š
	/// </summary>
	/// <returns></returns>
	const Vector2& GetTextureLeftTop()const { return textureLeftTop; }
	void SetTextureLeftTop(const Vector2& textureLeftTop) { this->textureLeftTop = textureLeftTop; }
	/// <summary>
	/// TextureSizeå–å¾— / è¨­å®š
	/// </summary>
	const Vector2& GetTextureSize()const { return textureSize; }
	void SetTextureSize(const Vector2& textureSize) { this->textureSize = textureSize; }


private:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	/// </summary>
	void CreateVertexResourceData();
	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚½ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	/// </summary>
	void CreateMaterialResource();
	/// <summary>
	/// å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	/// </summary>
	void CreateTransformationMatrixData();
	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºèª¿æ•´
	/// </summary>
	void AdjustTextureSize();

	//void DrawSetting();
private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	std::string textureFilePath_;
	
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource> vertexResource;
	Microsoft::WRL::ComPtr <ID3D12Resource> indexResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	VertexData* vertexData = nullptr;
	uint32_t* indexData = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ä½¿ã„é“ã‚’è£œè¶³ã™ã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView{};
	D3D12_INDEX_BUFFER_VIEW indexBufferView{};

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource> materialResource = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’ç¤ºã™ãƒã‚¤ãƒ³ã‚¿
	Material* materialData = nullptr;

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource>transformationMatrixResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’ç¤ºã™ãƒã‚¤ãƒ³ã‚¿
	TransformationMatrix* transformationMatrix = nullptr;

	// åº§æ¨™
	Vector2 position = { 0.0f,0.0f };
	float rotation = 0.0f;
	// è‰²ã¯materialDataã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã®ã§ãã¡ã‚‰ã‚’å‚ç…§
	Vector2 size = { 640.0f,360.0f };

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç•ªå·
	uint32_t textureIndex = 0;

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
	Transform transform;

	// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆ
	Vector2 anchorPoint = { 0.0f,0.0f };
	// å·¦å³ä¸Šä¸‹ã®åè»¢ãƒ•ãƒ©ã‚°
	// å·¦å³ãƒ•ãƒªãƒƒãƒ—
	bool isFlipX = false;
	// ä¸Šä¸‹ãƒ•ãƒªãƒƒãƒ—
	bool isFlipY = false;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Šåº§æ¨™
	Vector2 textureLeftTop = { 0.0f,0.0f };
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚º
	Vector2 textureSize = { 100.0f,100.0f };
};



============================================================
File Path: engine/2d/SpriteCommon.cpp
============================================================
#include "SpriteCommon.h"
#include "Logger.h"
#include "MyMath.h"

using namespace Engine;

SpriteCommon* SpriteCommon::instance = nullptr;
SpriteCommon& SpriteCommon::GetInstance()
{
	static SpriteCommon instance;
	return instance;
}

void SpriteCommon::DeleteInstance()
{
	if (instance != nullptr) {
		delete instance;
		instance = nullptr;
	}
}

void SpriteCommon::Initialize(DirectXCommon* dxCommon)
{
	//å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
	dxCommon_ = dxCommon;
	CreateGraphicsPipeLine();
}

void SpriteCommon::CreateRootSignature()
{
#pragma region RootParameter
	//RootSignatureä½œæˆ
	descriptionRootSignature.Flags =
		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
#pragma region DescriptorRange
	D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
	descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;//SRVã‚’ä½¿ã†
	descriptorRange[0].NumDescriptors = 1;//æ•°ã¯ï¼‘ã¤
	descriptorRange[0].BaseShaderRegister = 0;//0ã‹ã‚‰å§‹ã¾ã‚‹
	descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;//offsetã‚’è‡ªå‹•è¨ˆç®—

	


#pragma endregion
	
	//RootParameterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚ä»Šå›ã¯çµæœãŒï¼‘ã¤ã ã‘ãªã®ã§é•·ã•ï¼‘ã®é…åˆ—
	D3D12_ROOT_PARAMETER rootParameters[4] = {};
	rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;//CBVã‚’ä½¿ã†
	rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
	rootParameters[0].Descriptor.ShaderRegister = 0;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼ã¨ãƒã‚¤ãƒ³ãƒ‰

	rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;//
	rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;//
	rootParameters[1].Descriptor.ShaderRegister = 0;//

	rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;//DescriptorTableã‚’ä½¿ã†
	rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
	rootParameters[2].DescriptorTable.pDescriptorRanges = descriptorRange;//Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
	rootParameters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange);//Tableã§åˆ©ç”¨ã™ã‚‹æ•°

	rootParameters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;	//CBVã§ä½¿ã†
	rootParameters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;	//PixelShaderã§ä½¿ã†
	rootParameters[3].Descriptor.ShaderRegister = 1;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼‘ã‚’ä½¿ã†

	

	descriptionRootSignature.pParameters = rootParameters;//ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	descriptionRootSignature.NumParameters = _countof(rootParameters);//
#pragma endregion



	D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
	staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;//ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿
	staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//0ï½1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ
	staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//
	staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//
	staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;//æ¯”è¼ƒã—ãªã„
	staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;//ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†
	staticSamplers[0].ShaderRegister = 0;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†
	staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†

	descriptionRootSignature.pStaticSamplers = staticSamplers;
	descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºçµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr <ID3DBlob> signatureBlob = nullptr;
	// ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç™ºç”Ÿã—ãŸå ´åˆã«æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr <ID3DBlob> errorBlob = nullptr;
	HRESULT hr = D3D12SerializeRootSignature(&descriptionRootSignature, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(hr)) {
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	hr = dxCommon_->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
	assert(SUCCEEDED(hr));
	
}

void SpriteCommon::InitializePixelShaderOutput()
{
	
	
}

void SpriteCommon::DrawSettingCommon()
{
	
	// RootSignatureã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‘ã©åˆ¥é€”è¨­å®šãŒå¿…è¦
	dxCommon_->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());

	dxCommon_->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());  // PSOã‚’è¨­å®š

	// å½¢çŠ¶ã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‚‚ã®ã¨ã¯ã¾ãŸåˆ¥ã€‚åŒã˜ã‚‚ã®ã‚’è¨­å®šã™ã‚‹ã¨è€ƒãˆã¦ãŠã‘ã°è‰¯ã„
	dxCommon_->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

}


void SpriteCommon::CreateGraphicsPipeLine()
{
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	CreateRootSignature();

	// é ‚ç‚¹ã®ä½ç½®ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’è¨­å®š
	inputElementDescs[0].SemanticName = "POSITION";
	inputElementDescs[0].SemanticIndex = 0;
	inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã®åº§æ¨™
	inputElementDescs[1].SemanticName = "TEXCOORD";
	inputElementDescs[1].SemanticIndex = 0;
	inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	// æ³•ç·šãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’è¨­å®š
	inputElementDescs[2].SemanticName = "NORMAL";
	inputElementDescs[2].SemanticIndex = 0;
	inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputLayoutDescs.pInputElementDescs = inputElementDescs;
	inputLayoutDescs.NumElements = _countof(inputElementDescs);

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ›¸ãè¾¼ã¿ãƒã‚¹ã‚¯ã‚’è¨­å®šã€‚å…¨ã¦ã®è‰²ãƒãƒ£ãƒ³ãƒãƒ«ã«æ›¸ãè¾¼ã¿ã‚’è¨±å¯
	blendDesc.RenderTarget[0].RenderTargetWriteMask =
		D3D12_COLOR_WRITE_ENABLE_ALL;
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚’æœ‰åŠ¹åŒ–
	blendDesc.RenderTarget[0].BlendEnable = true;
	// åŠ ç®—åˆæˆ
	blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
	// æ¸›ç®—åˆæˆ
	blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯åŠ ç®—
	blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;

	// Î±å€¤è‡ªä½“ã®åˆæˆè¨­å®š
	blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;
	blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;
	blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;

	// ã‚«ãƒªãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®š
	rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
	// ãƒãƒªã‚´ãƒ³ã®ãƒ•ã‚£ãƒ«ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®šã€‚ãƒãƒªã‚´ãƒ³ã®å¡—ã‚Šæ½°ã—
	rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;

	//ã€€é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	vertexShaderBlob = dxCommon_->CompileShader(
		L"resources/shaders/Sprite.VS.hlsl", L"vs_6_0");
	assert(vertexShaderBlob != nullptr);
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	pixelShaderBlob = dxCommon_->CompileShader(
		L"resources/shaders/Sprite.PS.hlsl", L"ps_6_0");
	assert(pixelShaderBlob != nullptr);


	//Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
	depthStencilDesc.DepthEnable = true;
	//æ›¸ãè¾¼ã¿ã—ã¾ã™
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
	//æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;



	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
	graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();
	// ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.InputLayout = inputLayoutDescs;
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®è¨­å®š
	graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),vertexShaderBlob->GetBufferSize() };//
	graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),pixelShaderBlob->GetBufferSize() };//
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.BlendState = blendDesc;
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	graphicsPipelineStateDesc.RasterizerState = rasterizerDesc;
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ãƒãƒ­æ™‚ã®è¨­å®š
	graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	// DepthStencilã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
	
	HRESULT hr = dxCommon_->GetDevice()->CreateGraphicsPipelineState(
		&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState));

	assert(SUCCEEDED(hr));
}



Microsoft::WRL::ComPtr<ID3D12Resource>
SpriteCommon::CreateSpriteVertexResource()
{
	vertexResource = nullptr;
	vertexResource = dxCommon_->CreateBufferResource(sizeof(VertexData) * 6);
	return vertexResource;
}

Microsoft::WRL::ComPtr<ID3D12Resource>
SpriteCommon::CreateSpriteIndexResource()
{
	indexResource = nullptr;
	indexResource = dxCommon_->CreateBufferResource(sizeof(uint32_t) * 6);
	return indexResource;
}


============================================================
File Path: engine/2d/SpriteCommon.h
============================================================
#pragma once
#include "DirectXCommon.h"
/// <summary>
/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šã‚¯ãƒ©ã‚¹
/// </summary>
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹
class SpriteCommon
{
public:	
	/// <summary>
	/// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	static SpriteCommon& GetInstance();
	/// <summary>
	/// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å‰Šé™¤
	/// </summary>
	static void DeleteInstance();


public:		// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon"></param>
	void Initialize(Engine::DirectXCommon* dxCommon);

	/// <summary>
	/// å…±é€šæç”»è¨­å®š
	/// </summary>
	void DrawSettingCommon();
public:		//	Getter,Setter
	/// <summary>
	/// DirectXCommonå–å¾—é–¢æ•°
	/// </summary>
	Engine::DirectXCommon* GetDxCommon()const { return dxCommon_; }

public:	// Spriteã‚¯ãƒ©ã‚¹ã«å‘ã‘ãŸãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°(wrapper function)
	/// <summary>
	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆé ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> CreateSpriteVertexResource();
	/// <summary>
	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> CreateSpriteIndexResource();
private:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	/// </summary>
	void CreateRootSignature();

	/// <summary>
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	/// </summary>
	void CreateGraphicsPipeLine();
	/// <summary>
	/// PSO
	/// </summary>
	void InitializePixelShaderOutput();
	

private:	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ç”¨ãƒ¡ãƒ³ãƒå¤‰æ•°ã¨é–¢æ•°
	/// <summary>
	/// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	/// </summary>
	static SpriteCommon* instance;
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ã‚³ãƒ”ãƒ¼ç¦æ­¢
	/// </summary>
	SpriteCommon() = default;
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~SpriteCommon() = default;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ç¦æ­¢
	/// </summary>
	SpriteCommon(SpriteCommon&) = delete;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ç¦æ­¢
	/// </summary>
	SpriteCommon& operator=(SpriteCommon&) = delete;

private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// çµ¶å¯¾ã«new,deleteã—ãªã„
	Engine::DirectXCommon* dxCommon_;
	// RootSignatureä½œæˆ
	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
	// å…¥åŠ›ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨˜è¿°ã‚’è¨­å®š
	D3D12_INPUT_LAYOUT_DESC inputLayoutDescs{};
	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob = nullptr;
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob = nullptr;
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	D3D12_BLEND_DESC blendDesc{};
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ãƒ¼ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	D3D12_RASTERIZER_DESC rasterizerDesc{};
	// DepthStencilStateã®è¨­å®š
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	Microsoft::WRL::ComPtr <ID3D12RootSignature> rootSignature = nullptr;
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ä½œæˆ
	Microsoft::WRL::ComPtr <ID3D12PipelineState> graphicsPipelineState = nullptr;
	// å…¥åŠ›è¦ç´ ã®å®šç¾©é…åˆ—ã‚’åˆæœŸåŒ–
	D3D12_INPUT_ELEMENT_DESC inputElementDescs[3] = {};


private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	Microsoft::WRL::ComPtr<ID3D12Resource>vertexResource = nullptr;
	Microsoft::WRL::ComPtr<ID3D12Resource>indexResource = nullptr;

};



============================================================
File Path: engine/3d/Model.cpp
============================================================
#include "Model.h"
using namespace std;



void Model::Initialize(ModelCommon* modelCommon, const string& directorypath, const string& filename)
{
	// ModelCommonã®ãƒã‚¤ãƒ³ã‚¿ã‚’å¼•æ•°ã‹ã‚‰ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²
	this->modelCommon = modelCommon;
	// ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
	modelData = LoadObjFile(directorypath, filename);
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	CreateVertexResourceData();
	// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ–
	CreateMaterialResource();
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½¿ç”¨ã™ã‚‹
	if(modelData.material.textureFilePath.empty()) {
		// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½¿ç”¨ã™ã‚‹
		modelData.material.textureFilePath = "Resources/texture/default.png";
	}
	// .objã®å‚ç…§ã—ã¦ã„ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
	TextureManager::GetInstance()->LoadTexture(modelData.material.textureFilePath);
	// èª­ã¿è¾¼ã‚“ã ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
	TextureManager::GetInstance()->GetSrvIndex(modelData.material.textureFilePath);
}

void Model::Draw()
{
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	modelCommon->GetDxCommon()->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚»ãƒƒãƒˆ
	modelCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());
	// 
	modelCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(2,
		TextureManager::GetInstance()->GetSrvHandleGPU(modelData.material.textureFilePath));

	// ç’°å¢ƒãƒãƒƒãƒ—
	modelCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(4,
		TextureManager::GetInstance()->GetSrvHandleGPU(cubeMapPath));


	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚»ãƒƒãƒˆ
	//modelCommon->GetDxCommon()->GetCommandList()->SetGraphicsRoot32BitConstant(3, modelData.material.textureIndex, 0);
	// æç”»
	modelCommon->GetDxCommon()->GetCommandList()->DrawInstanced(UINT(modelData.vertices.size()), 1, 0, 0);

}



ModelData Model::LoadObjFile(const std::string& directoryPath, const std::string& filename)
{

	// 1. å¿…è¦ãªå¤‰æ•°å®£è¨€
	ModelData modelData;			// æ§‹ç¯‰ã™ã‚‹ModelData
	vector<Vector4> positions;		// ä½ç½®
	vector<Vector3> normals;		// æ³•ç·š
	vector<Vector2> texcoords;		// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™
	string line;					// ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã‚“ã 1è¡Œã‚’æ ¼ç´

	// 2. ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	ifstream file(directoryPath + "/" + filename);
	assert(file.is_open());         // é–‹ã‘ãªã‹ã£ãŸã‚‰æ­¢ã‚ã‚‹

	while (getline(file, line)) {
		string identifier;
		istringstream s(line);
		s >> identifier; // å…ˆé ­ã®è­˜åˆ¥å­ã‚’èª­ã‚€

		// identifierã«å¿œã˜ãŸå‡¦ç†
		if (identifier == "v") {
			Vector4 position;
			s >> position.x >> position.y >> position.z;
			position.x *= -1;
			position.w = 1.0f;
			positions.push_back(position);
		}
		else if (identifier == "vt") {
			Vector2 texcoord;
			s >> texcoord.x >> texcoord.y;
			texcoord.y = 1.0f - texcoord.y;
			texcoords.push_back(texcoord);
		}
		else if (identifier == "vn") {
			Vector3 normal;
			s >> normal.x >> normal.y >> normal.z;
			normal.x *= -1;
			normals.push_back(normal);
		}
		else if (identifier == "f") {
			VertexData triangle[3];
			// é¢ã¯ä¸‰è§’å½¢é™å®šã€‚ãã®ä»–ã¯æœªå®šã€‚
			for (int32_t faceVertex = 0; faceVertex < 3; ++faceVertex) {
				string vertexDefinition;
				s >> vertexDefinition;
				// é ‚ç‚¹ã®è¦ç´ ã¸ã®Indexã¯ã€€ï¼»ä½ç½®/UV/æ³•ç·šï¼½ã€€ã§æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã®ã§åˆ†è§£ã—ã¦Indexã‚’å–å¾—ã™ã‚‹
				istringstream v(vertexDefinition);
				uint32_t elementIndices[3];
				for (int32_t element = 0; element < 3; ++element) {
					string index;
					getline(v, index, '/');      // åŒºåˆ‡ã‚Šã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã†ãƒèª­ã‚“ã§ã„ã
					elementIndices[element] = stoi(index);
				}
				// è¦ç´ ã¸ã®Indexã‹ã‚‰ã€å®Ÿéš›ã®è¦ç´ ã®å€¤ã‚’å–å¾—ã—ã¦ã€é ‚ç‚¹ã‚’æ§‹ç¯‰ã™ã‚‹
				Vector4 position = positions[elementIndices[0] - 1];
				Vector2 texcoord = texcoords[elementIndices[1] - 1];
				Vector3 normal = normals[elementIndices[2] - 1];

				triangle[faceVertex] = { position,texcoord,normal };
			}
			// é ‚ç‚¹ã‚’é€†é †ã™ã‚ã“ã¨ã§ã€å›ã‚Šé †ã‚’é€†ã«ã™ã‚‹
			modelData.vertices.push_back(triangle[2]);
			modelData.vertices.push_back(triangle[1]);
			modelData.vertices.push_back(triangle[0]);
		}
		else if (identifier == "mtllib") {
			std::string materialFilename;
			s >> materialFilename;
			modelData.material = LoadMaterialTempLateFile(directoryPath, materialFilename);
		}
	}
	return modelData;
}



MaterialData Model::LoadMaterialTempLateFile(const std::string& directoryPath, const std::string& filename)
{
	MaterialData materialData;	//æ§‹ç¯‰ã™ã‚‹MaterialData
	std::string line;			//ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã‚“ã ï¼‘è¡Œã‚’æ ¼ç´ã™ã‚‹ã‚‚ã®
	std::ifstream file(directoryPath + "/" + filename);//ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	assert(file.is_open());		//é–‹ã‘ãªã‹ã£ãŸã‚‰æ­¢ã‚ã‚‹

	while (std::getline(file, line)) {
		std::string identifier;
		std::istringstream s(line);
		s >> identifier;
		//identifierã«å¿œã˜ãŸå‡¦ç†
		if (identifier == "map_Kd") {
			std::string textureFilename;
			s >> textureFilename;
			//é€£çµã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã«ã™ã‚‹
			materialData.textureFilePath = directoryPath + "/" + textureFilename;
		}
	}
	return materialData;
}

void Model::CreateVertexResourceData()
{
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	vertexResource = modelCommon->GetDxCommon()->CreateBufferResource(sizeof(VertexData) * modelData.vertices.size());
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€
	vertexResource->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));
	memcpy(vertexData, modelData.vertices.data(), sizeof(VertexData) * modelData.vertices.size());
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆ
	// ãƒªã‚½ãƒ¼ã‚¹ã®å…ˆé ­ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ä½¿ç”¨
	vertexBufferView.BufferLocation = vertexResource->GetGPUVirtualAddress();
	// ä½¿ç”¨ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºã¯é ‚ç‚¹ã®ã‚µã‚¤ã‚º
	vertexBufferView.SizeInBytes = UINT(sizeof(VertexData) * modelData.vertices.size());
	vertexBufferView.StrideInBytes = sizeof(VertexData);
	//æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	vertexResource->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));
	//é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚½ãƒ¼ã‚¹ã«ã‚³ãƒ”ãƒ¼
	memcpy(vertexData, modelData.vertices.data(), sizeof(VertexData) * modelData.vertices.size());
}

void Model::CreateMaterialResource()
{
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	materialResource = modelCommon->GetDxCommon()->CreateBufferResource(sizeof(Material));
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦materialDataã«å‰²ã‚Šå½“ã¦ã‚‹
	materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	materialData->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	materialData->enableLighting = 0;
	materialData->uvTransform = MakeIdentity4x4();

}


============================================================
File Path: engine/3d/Model.h
============================================================
#pragma once
#include "ModelCommon.h"
#include "Math.h"
#include "TextureManager.h"
#include <string>
#include <vector>
#include <fstream>
#include <cassert>
#include <wrl.h>
#include <d3d12.h>
#include <numbers>
#include "MakeMatrix.h"
#include "MyMath.h"
using namespace std;
/// <summary>
/// 3Dãƒ¢ãƒ‡ãƒ«ã‚¯ãƒ©ã‚¹
/// </summary>
class Model
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="directory path">ãƒ¢ãƒ‡ãƒ«ã®ãƒ•ã‚¡ã‚¤ãƒ«å</param>
	/// <param name="filename">ãƒ¢ãƒ‡ãƒ«ã®åå‰</param>
	void Initialize(ModelCommon* modelCommon,const string& directorypath,const string&filename);
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

	/// <summary>
	/// OBJãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="directoryPath"></param>
	/// <param name="filename"></param>
	/// <returns></returns>
	ModelData LoadObjFile(const std::string& directoryPath, const std::string& filename);
public: // Getter / Setter
	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	/// </summary>
	ModelData GetModelData()const { return modelData; }
	/// <summary>
	/// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> GetVertexResource()const { return vertexResource; }
	/// <summary>
	/// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®å–å¾—
	/// </summary>
	D3D12_VERTEX_BUFFER_VIEW GetVertexBufferView()const { return vertexBufferView; }
	/// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ«ã‚½ãƒ¼ã‚¹ã®å–å¾—
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> GetMaterialResource()const { return materialResource; }
	/// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	/// </summary>
	Material* GetMaterialData()const { return materialData; }
private: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	/// </summary>
	MaterialData LoadMaterialTempLateFile(const std::string& directoryPath, const std::string& filename);
	/// <summary>
	/// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	/// </summary>
	void CreateVertexResourceData();
	/// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆ
	/// </summary>
	void CreateMaterialResource();

private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ModelCommon
	ModelCommon* modelCommon = nullptr;
	// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
	ModelData modelData;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ä½¿ã„é“ã‚’è£œè¶³ã™ã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView{};
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	VertexData* vertexData = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> materialResource;
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿
	Material* materialData = nullptr;

	std::string cubeMapPath = "resources/rostock_laage_airport_4k.dds";
};



============================================================
File Path: engine/3d/ModelCommon.cpp
============================================================
#include "ModelCommon.h"

using namespace Engine;

ModelCommon::ModelCommon()
{
}

ModelCommon::~ModelCommon()
{
}

void ModelCommon::Initialize(DirectXCommon* dxCommon)
{
	//å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
	this->dxCommon_ = dxCommon;
}


============================================================
File Path: engine/3d/ModelCommon.h
============================================================
#pragma once
#include "DirectXCommon.h"
/// <summary>
/// 3Dãƒ¢ãƒ‡ãƒ«å…±é€šéƒ¨
/// </summary>
class ModelCommon
{
public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	ModelCommon();
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~ModelCommon();
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize(Engine::DirectXCommon* dxCommon);
	/// <summary>
	/// å…±é€šæç”»è¨­å®š
	/// </summary>
	void DrawSettingCommon();
public:	// Getter/Setter
	// DirectXCommonã®å–å¾—
	Engine::DirectXCommon* GetDxCommon()const { return dxCommon_; }
private:
	// çµ¶å¯¾ã«new,deleteã—ãªã„
	Engine::DirectXCommon* dxCommon_;

};



============================================================
File Path: engine/3d/ModelManager.cpp
============================================================
#include "ModelManager.h"

using namespace std;
using namespace Engine;
ModelManager* ModelManager::instance = nullptr;

ModelManager& ModelManager::GetInstance()
{
	static ModelManager instance;
	return instance;
}

void ModelManager::Finalize()
{
	models.clear();

	modelCommon.reset();
}

void ModelManager::Initialize(DirectXCommon* dxCommon)
{
	modelCommon = std::make_unique<ModelCommon>();
	modelCommon->Initialize(dxCommon);
}

void ModelManager::LoadModel(string_view filePath)
{
	// ã‚­ãƒ¼æ–‡å­—åˆ—ã®ç”Ÿæˆ
	const string key(filePath);
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢
	if (models.contains(key))
	{
		// èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
		return;
	}
	// ãƒ¢ãƒ‡ãƒ«ã®ç”Ÿæˆã¨ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã€åˆæœŸåŒ–
	unique_ptr<Model>model = make_unique<Model>();
	model->Initialize(modelCommon.get(), "resources", key);

	// ãƒ¢ãƒ‡ãƒ«ãƒªã‚¹ãƒˆã«è¿½åŠ 
	//models[filePath] = move(model);
	models.insert(make_pair(filePath, move(model)));
}

Model* ModelManager::FindModel(string_view filePath)
{
	// ã‚­ãƒ¼æ–‡å­—åˆ—ã®ç”Ÿæˆ
	const string key(filePath);
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢
	if (models.contains(key))
	{
		// èª­ã¿è¾¼ã¿ãƒ¢ãƒ‡ãƒ«ã‚’æˆ»ã‚Šå€¤ã¨ã—ã¦è¿”ã™
		return models.at(key).get();
	}
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ã§ãªã„å ´åˆã¯nullptrã‚’è¿”ã™
	return nullptr;
}


============================================================
File Path: engine/3d/ModelManager.h
============================================================
#pragma once
#include "ModelCommon.h"
#include "Math.h"
#include "TextureManager.h"
#include <string>
#include <vector>
#include <fstream>
#include "Model.h"
#include <map>
/// <summary>
/// 3Dãƒ¢ãƒ‡ãƒ«ç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
class ModelManager
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	static ModelManager& GetInstance();
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å‰Šé™¤
	/// </summary>
	void Finalize();

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize(Engine::DirectXCommon* dxCommon);

	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="filePath">èª­ã¿è¾¼ã‚€ãƒ¢ãƒ‡ãƒ«ã®åå‰</param>
	void LoadModel(std::string_view filePath);
public: // Getter/Setter
	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ã®æ¤œç´¢
	/// </summary>
	/// <param name="filePath"></param>
	/// <returns></returns>
	Model* FindModel(std::string_view filePath);

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	/// </summary>
	static ModelManager* instance;
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	ModelManager() = default;
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~ModelManager() = default;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ç„¡åŠ¹åŒ–
	/// </summary>
	/// <param name=""></param>
	ModelManager(ModelManager&) = delete;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ä»£å…¥æ¼”ç®—å­ç„¡åŠ¹åŒ–
	/// </summary>
	ModelManager& operator=(ModelManager&) = delete;
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	std::unique_ptr<ModelCommon> modelCommon = nullptr;
	// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚¹ãƒˆ
	std::map<std::string, unique_ptr<Model>> models;

};



============================================================
File Path: engine/3d/Object3D.cpp
============================================================
#include "Object3D.h"
#include "Object3DCommon.h"
#include <fstream>
#include <sstream>
#include <cassert>
#include "MakeMatrix.h"
#include "ModelManager.h"
using namespace std;
using namespace Engine;
void Object3D::Initialize()
{

	this->camera = Object3DCommon::GetInstance()->GetDefaultCamera();

	CreateTransformationMatrixData();
	CreateDirectionalLightResource();
	// ã‚«ãƒ¡ãƒ©ãƒãƒƒãƒ•ã‚¡ã‚’ç”Ÿæˆ
	CreateCameraResource();

	// Transformã®åˆæœŸåŒ–
	transform = { { 1.0f, 1.0f, 1.0f },{ 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f  } };
}

void Object3D::Update()
{
	Matrix4x4 worldMatrix = MakeAffineMatrix(transform.scale, transform.rotate, transform.translate);
	Matrix4x4 worldViewProjection;
	if (camera) {
		const Matrix4x4& viewProjectionMatrix = camera->GetViewProjectionMatrix();
		worldViewProjection = Multiply(worldMatrix, viewProjectionMatrix);
	} else {
		worldViewProjection = worldMatrix;
	}
	wvpData->WVP = worldViewProjection;
	wvpData->World = worldMatrix;
}

void Object3D::Draw() {

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™ã€‚3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
	Object3DCommon::GetInstance()->DrawSettingCommon();

	Object3DCommon::GetInstance()->GetDxCommon()->GetCommandList()->
		SetGraphicsRootConstantBufferView(1, wvpResource->GetGPUVirtualAddress());
	Object3DCommon::GetInstance()->GetDxCommon()->GetCommandList()->
		SetGraphicsRootConstantBufferView(3, directionalLightResource->GetGPUVirtualAddress());
	Object3DCommon::GetInstance()->GetDxCommon()->GetCommandList()->
		SetGraphicsRootConstantBufferView(5, cameraResource->GetGPUVirtualAddress());


	// é€šå¸¸ã®ãƒ¢ãƒ‡ãƒ«æç”»
	model->Draw();

}

void Object3D::Create(Model* model)
{
	assert(model); // ãƒ¢ãƒ‡ãƒ«ãŒnullptrã§ãªã„ã“ã¨ã‚’ç¢ºèª

	this->model = model;

	// ã‚«ãƒ¡ãƒ©ã‚’å–å¾—
	this->camera = Object3DCommon::GetInstance()->GetDefaultCamera();

	// å¤‰æ›è¡Œåˆ—ãƒãƒƒãƒ•ã‚¡ã‚’ç”Ÿæˆ
	CreateTransformationMatrixData();

	// å…‰æºãƒãƒƒãƒ•ã‚¡ã‚’ç”Ÿæˆ
	CreateDirectionalLightResource();

	// ã‚«ãƒ¡ãƒ©ãƒãƒƒãƒ•ã‚¡ã‚’ç”Ÿæˆ
	CreateCameraResource();


	// åˆæœŸTransform
	transform = {
		{ 1.0f, 1.0f, 1.0f },   // scale
		{ 0.0f, 0.0f, 0.0f },   // rotate
		{ 0.0f, 0.0f, 0.0f }    // translate
	};
}



void Object3D::SetModel(const std::string& filePath)
{
	// ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢ã—ã¦ã‚»ãƒƒãƒˆã™ã‚‹
	model = ModelManager::GetInstance().FindModel(filePath);
}





void Object3D::CreateTransformationMatrixData()
{
	// å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	wvpResource = Object3DCommon::GetInstance()->GetDxCommon()->
		CreateBufferResource(sizeof(TransformationMatrix));
	// å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹
	wvpResource->Map(0, nullptr, reinterpret_cast<void**>(&wvpData));
	// å¤‰æ›è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	wvpData->WVP = MakeIdentity4x4();
	wvpData->World = MakeIdentity4x4();

}

void Object3D::CreateDirectionalLightResource()
{
	// å¹³è¡Œå…‰æºãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	directionalLightResource = Object3DCommon::GetInstance()->GetDxCommon()->
		CreateBufferResource(sizeof(DirectionalLight));
	// å¹³è¡Œå…‰æºãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦directionalLightDataã«å‰²ã‚Šå½“ã¦ã‚‹
	directionalLightResource->Map(0, nullptr, reinterpret_cast<void**>(&directionalLightData));
	// å¹³è¡Œå…‰æºãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ– / ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
	// ãƒ©ã‚¤ãƒˆã®è‰²
	directionalLightData->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	// ãƒ©ã‚¤ãƒˆã®å‘ã
	directionalLightData->direction = { 0.0f, -1.0f, 0.0f };
	// è¼åº¦
	directionalLightData->intensity = 1.0f;
}

void Object3D::CreateCameraResource()
{
	// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆ
	cameraResource = Object3DCommon::GetInstance()->GetDxCommon()->
		CreateBufferResource(sizeof(CameraForGPU));
	// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦cameraForGpuDataã«å‰²ã‚Šå½“ã¦ã‚‹
	cameraResource->Map(0, nullptr, reinterpret_cast<void**>(&cameraForGpuData));
	// ã‚«ãƒ¡ãƒ©ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	cameraForGpuData->worldPosition = { 0.0f,4.0f,-10.0f };


}



============================================================
File Path: engine/3d/Object3D.h
============================================================
#pragma once
#include "Math.h"
#include <string>
#include <d3d12.h>
#include <vector>
#include <wrl.h>
#include "Model.h"
#include "Game/Camera/Camera.h"

// ãƒªãƒ³ã‚°çŠ¶ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
struct RingVertex {
	Vector4 position;
	Vector3 normal;
	Vector2 uv;
};
/// <summary>
/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹
/// </summary>
class Object3D
{

public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();
	/// <summary>
	///  ãƒ¬ãƒ™ãƒ«ãƒ­ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«ç”Ÿæˆ
	/// </summary>
	void Create(Model* model);

public:	// Getter/Setter
	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã®ã‚»ãƒƒãƒˆ
	/// </summary>
	void SetCamera(Camera* camera) { this->camera = camera; }
	/// <summary>
	/// Model å‹ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨­å®šã—ã¾ã™ã€‚
	/// </summary>
	void SetModel(Model* model) { this->model = model; }
	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã¨è¨­å®š
	/// </summary>
	void SetModel(const std::string& filePath);
	/// <summary>
	/// ã‚¹ã‚±ãƒ¼ãƒ«ã®è¨­å®š
	/// </summary>
	void SetScale(const Vector3& scale) { transform.scale = scale; }
	/// <summary>
	/// å›è»¢ã®è¨­å®š
	/// </summary>
	void SetRotate(const Vector3& rotate) { transform.rotate = rotate; }
	/// <summary>
	/// å¹³è¡Œç§»å‹•ã®è¨­å®š
	/// </summary>
	void SetTranslate(const Vector3& translate) { transform.translate = translate; }
	/// <summary>
	/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®è¨­å®š
	/// </summary>
	void SetTransform(const Transform& transform) { this->transform = transform; }

	/// <summary>
	/// ã‚¹ã‚±ãƒ¼ãƒ«ã®å–å¾—
	/// </summary>
	const Vector3 GetScale()const { return transform.scale; }
	/// <summary>
	/// å›è»¢ã®å–å¾—
	/// </summary>
	const Vector3 GetRotate()const { return transform.rotate; }
	/// <summary>
	/// å¹³è¡Œç§»å‹•ã®å–å¾—
	/// </summary>
	const Vector3 GetTranslate()const { return transform.translate; }
	/// <summary>
	/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®å–å¾—
	/// </summary>
	const Transform& GetTransform()const { return transform; }
private: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åº§æ¨™å¤‰æ›è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	/// </summary>
	void CreateTransformationMatrixData();
	/// <summary>
	/// å¹³è¡Œå…‰æºãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆ
	/// </summary>
	void CreateDirectionalLightResource();
	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆ
	/// </summary>
	void CreateCameraResource();


private:// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ã‚«ãƒ¡ãƒ©
	Camera* camera = nullptr;
	// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
	Model* model = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ / åº§æ¨™å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> wvpResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	TransformationMatrix* wvpData = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ / å¹³è¡Œå…‰æºãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> directionalLightResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	DirectionalLight* directionalLightData = nullptr;

	// Transform
	Transform transform;


	Microsoft::WRL::ComPtr<ID3D12Resource>vertexBuffer;
	Microsoft::WRL::ComPtr<ID3D12Resource>indexBuffer;
	D3D12_VERTEX_BUFFER_VIEW vbView{};
	D3D12_INDEX_BUFFER_VIEW ibView{};
	uint32_t indexCount = 0;

	// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> cameraResource;
	CameraForGPU* cameraForGpuData = nullptr;
};



============================================================
File Path: engine/3d/Object3DCommon.cpp
============================================================
#include "Object3DCommon.h"
#include "Logger.h"

using namespace Engine;

Object3DCommon* Object3DCommon::instance = nullptr;


void Object3DCommon::Initialize(DirectXCommon* dxCommon)
{
	dxCommon_ = dxCommon;
	CreateGraphicsPipeLine();
}

void Object3DCommon::DrawSettingCommon()
{
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚»ãƒƒãƒˆ
	dxCommon_->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ãƒ—ãƒ©ã‚¤ãƒ³ã®ã‚»ãƒƒãƒˆ
	dxCommon_->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒãƒ­ã‚¸ãƒ¼ã®ã‚»ãƒƒãƒˆ
	dxCommon_->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}


void Object3DCommon::CreateRootSignature()
{
#pragma region RootParameter
	//RootSignatureä½œæˆ
	descriptionRootSignature.Flags =
		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
#pragma region DescriptorRange
	D3D12_DESCRIPTOR_RANGE descriptorRange = {};
	descriptorRange.BaseShaderRegister = 0;//0ã‹ã‚‰å§‹ã¾ã‚‹
	descriptorRange.NumDescriptors = 1;//æ•°ã¯ï¼‘ã¤
	descriptorRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;//SRVã‚’ä½¿ã†
	descriptorRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;//offsetã‚’è‡ªå‹•è¨ˆç®—

	// ç’°å¢ƒãƒãƒƒãƒ—
	D3D12_DESCRIPTOR_RANGE descriptorRangeSkyBox = {};
	descriptorRangeSkyBox.BaseShaderRegister = 1;
	descriptorRangeSkyBox.NumDescriptors = 1;
	descriptorRangeSkyBox.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
	descriptorRangeSkyBox.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;//offsetã‚’è‡ªå‹•è¨ˆç®—

	#pragma endregion

	//RootParameterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚ä»Šå›ã¯çµæœãŒï¼‘ã¤ã ã‘ãªã®ã§é•·ã•ï¼‘ã®é…åˆ—
	D3D12_ROOT_PARAMETER rootParameters[6] = {};
	rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;//CBVã‚’ä½¿ã†
	rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
	rootParameters[0].Descriptor.ShaderRegister = 0;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼ã¨ãƒã‚¤ãƒ³ãƒ‰

	rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;//
	rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;//
	rootParameters[1].Descriptor.ShaderRegister = 0;//

	rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;//DescriptorTableã‚’ä½¿ã†
	rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
	rootParameters[2].DescriptorTable.pDescriptorRanges = &descriptorRange;//Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
	rootParameters[2].DescriptorTable.NumDescriptorRanges = 1;//Tableã§åˆ©ç”¨ã™ã‚‹æ•°

	rootParameters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;	//CBVã§ä½¿ã†
	rootParameters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;	//PixelShaderã§ä½¿ã†
	rootParameters[3].Descriptor.ShaderRegister = 1;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼‘ã‚’ä½¿ã†

	// ç’°å¢ƒãƒãƒƒãƒ—
	rootParameters[4].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;//DescriptorTableã‚’ä½¿ã†
	rootParameters[4].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
	rootParameters[4].DescriptorTable.pDescriptorRanges = &descriptorRangeSkyBox;//Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
	rootParameters[4].DescriptorTable.NumDescriptorRanges = 1;//Tableã§åˆ©ç”¨ã™ã‚‹æ•°

	//ã‚«ãƒ¡ãƒ©
	rootParameters[5].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters[5].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters[5].Descriptor.ShaderRegister = 2;
	
	descriptionRootSignature.pParameters = rootParameters;//ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	descriptionRootSignature.NumParameters = _countof(rootParameters);//
#pragma endregion



	D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
	staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;//ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿
	staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//0ï½1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ
	staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//
	staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//
	staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;//æ¯”è¼ƒã—ãªã„
	staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;//ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†
	staticSamplers[0].ShaderRegister = 0;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†
	staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†

	descriptionRootSignature.pStaticSamplers = staticSamplers;
	descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºçµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr <ID3DBlob> signatureBlob = nullptr;
	// ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç™ºç”Ÿã—ãŸå ´åˆã«æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr <ID3DBlob> errorBlob = nullptr;
	HRESULT hr = D3D12SerializeRootSignature(&descriptionRootSignature, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(hr)) {
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	hr = dxCommon_->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
	assert(SUCCEEDED(hr));

}

void Object3DCommon::CreateGraphicsPipeLine()
{
	CreateRootSignature();

	// é ‚ç‚¹ã®ä½ç½®ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’è¨­å®š
	inputElementDescs[0].SemanticName = "POSITION";
	inputElementDescs[0].SemanticIndex = 0;
	inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã®åº§æ¨™
	inputElementDescs[1].SemanticName = "TEXCOORD";
	inputElementDescs[1].SemanticIndex = 0;
	inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	// æ³•ç·šãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’è¨­å®š
	inputElementDescs[2].SemanticName = "NORMAL";
	inputElementDescs[2].SemanticIndex = 0;
	inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputLayoutDescs.pInputElementDescs = inputElementDescs;
	inputLayoutDescs.NumElements = _countof(inputElementDescs);

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ›¸ãè¾¼ã¿ãƒã‚¹ã‚¯ã‚’è¨­å®šã€‚å…¨ã¦ã®è‰²ãƒãƒ£ãƒ³ãƒãƒ«ã«æ›¸ãè¾¼ã¿ã‚’è¨±å¯
	blendDesc.RenderTarget[0].RenderTargetWriteMask =
		D3D12_COLOR_WRITE_ENABLE_ALL;


	// ã‚«ãƒªãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®š
	rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
	// ãƒãƒªã‚´ãƒ³ã®ãƒ•ã‚£ãƒ«ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®šã€‚ãƒãƒªã‚´ãƒ³ã®å¡—ã‚Šæ½°ã—
	rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;

	//ã€€é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	vertexShaderBlob = dxCommon_->CompileShader(
		L"resources/shaders/Object3D.VS.hlsl", L"vs_6_0");
	assert(vertexShaderBlob != nullptr);
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	pixelShaderBlob = dxCommon_->CompileShader(
		L"resources/shaders/Object3D.PS.hlsl", L"ps_6_0");
	assert(pixelShaderBlob != nullptr);


	//Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
	depthStencilDesc.DepthEnable = true;
	//æ›¸ãè¾¼ã¿ã—ã¾ã™
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
	//æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;

#pragma region GraphicsPipelineState

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
	graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();
	// ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.InputLayout = inputLayoutDescs;
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®è¨­å®š
	graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),vertexShaderBlob->GetBufferSize() };//
	graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),pixelShaderBlob->GetBufferSize() };//
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.BlendState = blendDesc;
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	graphicsPipelineStateDesc.RasterizerState = rasterizerDesc;
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ãƒãƒ­æ™‚ã®è¨­å®š
	graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	// DepthStencilã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
	HRESULT hr = dxCommon_->GetDevice()->CreateGraphicsPipelineState(
		&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState));
	assert(SUCCEEDED(hr));
#pragma endregion

}



Object3DCommon* Object3DCommon::GetInstance() {
	if (instance == nullptr) {
		instance = new Object3DCommon();
	}
	return instance;
}

void Object3DCommon::DeleteInstance() {
	delete instance;
	instance = nullptr;
}

============================================================
File Path: engine/3d/Object3DCommon.h
============================================================
#pragma once
#include "DirectXCommon.h"
#include "Game/Camera/Camera.h"
/// <summary>
/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…±é€šéƒ¨
/// </summary>
class Object3DCommon
{
public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize(Engine::DirectXCommon* dxCommon);
	/// <summary>
	/// å…±é€šæç”»è¨­å®š
	/// </summary>
	void DrawSettingCommon();
public:	// Getter/Setter
	/// <summary>
	/// DirectXCommonã®å–å¾—
	/// </summary>
	Engine::DirectXCommon* GetDxCommon()const { return dxCommon_; }
	/// <summary>
	/// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã®è¨­å®š
	/// </summary>
	void SetDefaultCamera(Camera* camera) { this->defaultCamera = camera; }
	/// <summary>
	/// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã®å–å¾—
	/// </summary>
	Camera* GetDefaultCamera()const { return defaultCamera; }
private:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	/// </summary>
	void CreateRootSignature();
	/// <summary>
	///ã€€ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ä½œæˆ
	/// </summary>
	void CreateGraphicsPipeLine();

private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ã‚«ãƒ¡ãƒ©
	Camera* defaultCamera = nullptr;
	// çµ¶å¯¾ã«new,deleteã—ãªã„
	Engine::DirectXCommon* dxCommon_;
	// RootSignatureä½œæˆ
	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
	// å…¥åŠ›ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨˜è¿°ã‚’è¨­å®š
	D3D12_INPUT_LAYOUT_DESC inputLayoutDescs{};
	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob = nullptr;
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob = nullptr;
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	D3D12_BLEND_DESC blendDesc{};
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ãƒ¼ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	D3D12_RASTERIZER_DESC rasterizerDesc{};
	// DepthStencilStateã®è¨­å®š
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	Microsoft::WRL::ComPtr <ID3D12RootSignature> rootSignature = nullptr;
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ä½œæˆ
	Microsoft::WRL::ComPtr <ID3D12PipelineState> graphicsPipelineState = nullptr;
	// å…¥åŠ›è¦ç´ ã®å®šç¾©é…åˆ—ã‚’åˆæœŸåŒ–
	D3D12_INPUT_ELEMENT_DESC inputElementDescs[3] = {};

public:	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³åŒ–
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	static Object3DCommon* GetInstance();
	static void DeleteInstance();

private:
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ / ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	Object3DCommon() = default;
	~Object3DCommon() = default;

	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ / ã‚³ãƒ”ãƒ¼ä»£å…¥æ¼”ç®—å­ã®ç¦æ­¢
	/// </summary>
	/// <param name=""></param>
	Object3DCommon(const Object3DCommon&) = delete;
	Object3DCommon& operator=(const Object3DCommon&) = delete;

	static Object3DCommon* instance;
};



============================================================
File Path: engine/3d/SkyBox/SkyBox.cpp
============================================================
#include "SkyBox.h"
#include <Logger.h>
#include "MakeMatrix.h"
#include "TextureManager.h"
#include "Object3DCommon.h"

using namespace Engine;

void SkyBox::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager)
{
	this->dxCommon = dxCommon;
	this->srvManager = srvManager;
	this->camera = Object3DCommon::GetInstance()->GetDefaultCamera();
	TextureManager::GetInstance()->LoadTexture("resources/rostock_laage_airport_4k.dds");
	modelData.material.textureFilePath = "resources/rostock_laage_airport_4k.dds";
	/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	CreatePipeline();
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	CreateRootSignature();
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	SetGraphicsPipeline();
	/// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®é ‚ç‚¹ç”Ÿæˆ
	CreateVertexData();
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ–
	InitializeMaterial();
	/// 
	CreateTransformationMatrix();
}

void SkyBox::Update()
{
	// ã‚«ãƒ¡ãƒ©ã®ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã‚’å–å¾—
	const Matrix4x4& viewMatrix = camera->GetViewMatrix();
	const Matrix4x4& projectionMatrix = camera->GetProjectionMatrix();

	// å›è»¢ã¯ãã®ã¾ã¾ã€ä½ç½®ã ã‘ã‚’ç„¡è¦–ã—ãŸãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã‚’ä½œæˆ
	Matrix4x4 viewNoTranslation = viewMatrix;
	viewNoTranslation.m[3][0] = 0.0f;
	viewNoTranslation.m[3][1] = 0.0f;
	viewNoTranslation.m[3][2] = 0.0f;

	// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ç”¨ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ã®ã¿ã€ä½ç½®ã‚‚å›è»¢ã‚‚ãªã—ï¼‰
	Matrix4x4 worldMatrix = MakeScaleMatrix({ 1.0f, 1.0f, 1.0f });

	// WVPè¡Œåˆ—ã‚’æ§‹ç¯‰ï¼ˆè¦–ç‚¹å›ºå®šï¼‰
	Matrix4x4 viewProj = Multiply(viewNoTranslation, projectionMatrix);
	Matrix4x4 worldViewProjection = Multiply(worldMatrix, viewProj);

	wvpData->WVP = worldViewProjection;
	wvpData->World = worldMatrix;
}



void SkyBox::Draw()
{
	/// ã‚³ãƒãƒ³ãƒ‰ : ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’è¨­å®š
	dxCommon->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
	/// ã‚³ãƒãƒ³ãƒ‰ : ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¨­å®š
	dxCommon->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
	/// ã‚³ãƒãƒ³ãƒ‰ : ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒ­ãƒã‚¸(æç”»å½¢çŠ¶)ã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	/// ã‚³ãƒãƒ³ãƒ‰ : VertexBufferViewã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);
	/// ã‚³ãƒãƒ³ãƒ‰ : ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetIndexBuffer(&indexBufferView);
	/// ã‚³ãƒãƒ³ãƒ‰ : ãƒãƒ†ãƒªã‚¢ãƒ«ã®å®šæ•°ãƒãƒƒãƒ•ã‚¡ã‚’è¨­å®š
	dxCommon->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());
	///
	dxCommon->GetCommandList()->SetGraphicsRootConstantBufferView(1, wvpResource->GetGPUVirtualAddress());
	
	D3D12_GPU_DESCRIPTOR_HANDLE textureHandle =
		TextureManager::GetInstance()->GetSrvHandleGPU(modelData.material.textureFilePath);
	/// ã‚³ãƒãƒ³ãƒ‰ : ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ“ãƒ¥ãƒ¼ã‚’è¨­å®š
	dxCommon->GetCommandList()->SetGraphicsRootDescriptorTable(2,textureHandle);
	/// ã‚³ãƒãƒ³ãƒ‰ : æç”»
	//dxCommon->GetCommandList()->DrawInstanced(UINT(modelData.indices.size()), 1, 0, 0);
	dxCommon->GetCommandList()->DrawIndexedInstanced(UINT(modelData.indices.size()), 1, 0, 0, 0);
	
}

void SkyBox::CreatePipeline()
{
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	CreateRootSignature();
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	SetGraphicsPipeline();
}

void SkyBox::CreateRootSignature() {
	D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
	//D3D12_DESCRIPTOR_RANGE descriptorRangeInstancing[1] = {};
	descriptorRange[0].BaseShaderRegister = 0; // 0ã‹ã‚‰å§‹ã¾ã‚‹
	descriptorRange[0].NumDescriptors = 1; // æ•°ã¯1ã¤
	descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRV
	descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—

	// 1. RootSignatureã®ä½œæˆ
	descriptionRootSignature.Flags =
		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	// RootParameterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚
	// 0.Material
	rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters[0].Descriptor.ShaderRegister = 0;

	// 1. TransformMatrix
	rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
	rootParameters[1].Descriptor.ShaderRegister = 1;

	// 2.Texture
	rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters[2].DescriptorTable.pDescriptorRanges = descriptorRange;
	rootParameters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange);

	descriptionRootSignature.pParameters = rootParameters;
	descriptionRootSignature.NumParameters = _countof(rootParameters);

	// Samplerã®è¨­å®š
	staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR; // ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿
	staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP; // 0~1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ
	staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
	staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER; // æ¯”è¼ƒã—ãªã„
	staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX; // ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†
	staticSamplers[0].ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†
	staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
	descriptionRootSignature.pStaticSamplers = staticSamplers;
	descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

	// ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒã‚¤ãƒŠãƒªã«ã™ã‚‹
	Microsoft::WRL::ComPtr<ID3DBlob> signatureBlob = nullptr;
	Microsoft::WRL::ComPtr<ID3DBlob> errorBlob = nullptr;
	HRESULT hr = D3D12SerializeRootSignature(&descriptionRootSignature,
		D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(hr)) {
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	// ãƒã‚¤ãƒŠãƒªã‚’å…ƒã«ç”Ÿæˆ

	hr = dxCommon->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(),
		signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
	assert(SUCCEEDED(hr));



	// 2. InputLayoutã®è¨­å®š
	inputElementDescs[0].SemanticName = "POSITION";
	inputElementDescs[0].SemanticIndex = 0;
	inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs[1].SemanticName = "TEXCOORD";
	inputElementDescs[1].SemanticIndex = 0;
	inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs[2].SemanticName = "NORMAL";
	inputElementDescs[2].SemanticIndex = 0;
	inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	inputLayoutDesc.pInputElementDescs = inputElementDescs;
	inputLayoutDesc.NumElements = _countof(inputElementDescs);

	// 3. BlendDtateã®è¨­å®š
	blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
	blendDesc.RenderTarget[0].BlendEnable = true;

	SetBlendMode(blendDesc, blendMode);
	currentBlendMode = BlendMode::kBlendModeAdd;  // ç¾åœ¨ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰
	// Î±å€¤ã®ãƒ–ãƒ¬ãƒ³ãƒ‰
	blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;
	blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;
	// RasterrizerStateã®è¨­å®š
	// ã‚«ãƒªãƒ³ã‚°ãªã—
	rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
	// å¡—ã‚Šã¤ã¶ã—ãƒ¢ãƒ¼ãƒ‰
	rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;
	// 4. Shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	vertexShaderBlob = dxCommon->CompileShader(L"resources/shaders/SkyBox.VS.hlsl",
		L"vs_6_0");
	assert(vertexShaderBlob != nullptr);
	pixelShaderBlob = dxCommon->CompileShader(L"resources/shaders/SkyBox.PS.hlsl",
		L"ps_6_0");
	assert(pixelShaderBlob != nullptr);

	// DepthStencilStateã®è¨­å®š
	// Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
	depthStencilDesc.DepthEnable = true;
	//æ›¸ãè¾¼ã¿ã—ã¾ã™
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
	//æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
}

void SkyBox::SetGraphicsPipeline()
{
	graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();
	graphicsPipelineStateDesc.InputLayout = inputLayoutDesc;
	graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),
										vertexShaderBlob->GetBufferSize() };
	graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),
										pixelShaderBlob->GetBufferSize() };
	graphicsPipelineStateDesc.BlendState = blendDesc;
	graphicsPipelineStateDesc.RasterizerState = rasterizerDesc;
	// Depthstencitã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
	// æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	// åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸ï¼ˆå½¢çŠ¶ï¼‰ã®ã‚¿ã‚¤ãƒ—.ä¸‰è§’å½¢
	graphicsPipelineStateDesc.PrimitiveTopologyType =
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	// ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã®ã‹è¨­å®šï¼ˆæ°—ã«ã—ãªãã¦è‰¯ã„ï¼‰
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	// å®Ÿéš›ã«ç”Ÿæˆ
	HRESULT hr = dxCommon->GetDevice()->CreateGraphicsPipelineState(&graphicsPipelineStateDesc,
		IID_PPV_ARGS(&graphicsPipelineState));
	assert(SUCCEEDED(hr));
}

void SkyBox::CreateVertexBufferView() {

	vertexResource = dxCommon->CreateBufferResource(sizeof(VertexData) * modelData.vertices.size());
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼
	vertexBufferView.BufferLocation = vertexResource->GetGPUVirtualAddress();
	// 1é ‚ç‚¹åˆ†ã®ã‚µã‚¤ã‚º
	vertexBufferView.StrideInBytes = sizeof(VertexData);
	// é ‚ç‚¹æ•°
	vertexBufferView.SizeInBytes = UINT(sizeof(VertexData) * modelData.vertices.size());
	// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿ / ãƒãƒƒãƒ—
	vertexResource->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));
	// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	memcpy(vertexData, modelData.vertices.data(), sizeof(VertexData) * modelData.vertices.size());

}

void SkyBox::InitializeMaterial()
{
	// ãƒªã‚½ãƒ¼ã‚¹ç”Ÿæˆ
	materialResource = dxCommon->CreateBufferResource(sizeof(Material));
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã«æ›¸ãè¾¼ã¿
	materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	materialData->color = Vector4(1.0f, 1.0f, 1.0f, 1.0f);
	materialData->enableLighting = true;
	materialData->uvTransform = MakeIdentity4x4();
}

void SkyBox::CreateVertexData()
{
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆå„é¢ï¼š2ä¸‰è§’å½¢ï¼6ã¤ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰
	indices = {
		// å„é¢ã”ã¨ã«2æšã®ä¸‰è§’å½¢ (6ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹)
		0, 1, 2,  2, 1, 3,   // å³é¢
		4, 5, 6,  6, 5, 7,   // å·¦é¢
		8, 9, 10, 10, 9,11,  // å‰é¢
		12,13,14, 14,13,15,  // å¾Œé¢
		16,17,18, 18,17,19,  // ä¸Šé¢
		20,21,22, 22,21,23   // ä¸‹é¢
	};

	modelData.indices = indices;


	// å³é¢ (+X) / æç”»index [0,1,2] [2,1,3]
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, -1.0f, 1.0f}, .texcoord = {1.0f, 0.0f}, .normal = {1, 0, 0} });
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, 1.0f, 1.0f},  .texcoord = {1.0f, 1.0f}, .normal = {1, 0, 0} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, -1.0f, 1.0f}, .texcoord = {0.0f, 0.0f}, .normal = {1, 0, 0} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, 1.0f, 1.0f},  .texcoord = {0.0f, 1.0f}, .normal = {1, 0, 0} });

	// å·¦é¢ (-X) / æç”»index [4,5,6] [6,5,7]
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, 1.0f, 1.0f},  .texcoord = {1.0f, 0.0f}, .normal = {-1, 0, 0} });
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, -1.0f, 1.0f}, .texcoord = {1.0f, 1.0f}, .normal = {-1, 0, 0} });
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, 1.0f, 1.0f}, .texcoord = {0.0f, 0.0f}, .normal = {-1, 0, 0} });
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, -1.0f, 1.0f},.texcoord = {0.0f, 1.0f}, .normal = {-1, 0, 0} });

	// å‰é¢ (+Z) / æç”»index [8,9,10] [10,9,11]
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, 1.0f, 1.0f},  .texcoord = {1.0f, 0.0f}, .normal = {0, 0, 1} });
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, 1.0f, 1.0f},   .texcoord = {1.0f, 1.0f}, .normal = {0, 0, 1} });
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, 1.0f, 1.0f}, .texcoord = {0.0f, 0.0f}, .normal = {0, 0, 1} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, 1.0f, 1.0f},  .texcoord = {0.0f, 1.0f}, .normal = {0, 0, 1} });

	// å¾Œé¢ (-Z) / æç”»index [12,13,14] [14,13,15]
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, -1.0f, 1.0f},  .texcoord = {1.0f, 0.0f}, .normal = {0, 0, -1} });
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, -1.0f, 1.0f}, .texcoord = {1.0f, 1.0f}, .normal = {0, 0, -1} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, -1.0f, 1.0f}, .texcoord = {0.0f, 0.0f}, .normal = {0, 0, -1} });
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, -1.0f, 1.0f},.texcoord = {0.0f, 1.0f}, .normal = {0, 0, -1} });

	// ä¸Šé¢ (+Y) / æç”»index [16,17,18] [18,17,19]
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, -1.0f, 1.0f}, .texcoord = {0.0f, 0.0f}, .normal = {0, 1, 0} });
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, -1.0f, 1.0f},  .texcoord = {0.0f, 1.0f}, .normal = {0, 1, 0} });
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, 1.0f, 1.0f},  .texcoord = {1.0f, 0.0f}, .normal = {0, 1, 0} });
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, 1.0f, 1.0f},   .texcoord = {1.0f, 1.0f}, .normal = {0, 1, 0} });

	// ä¸‹é¢ (-Y) / æç”»index [20,21,22] [22,21,23]
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, 1.0f, 1.0f}, .texcoord = {0.0f, 0.0f}, .normal = {0, -1, 0} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, 1.0f, 1.0f},  .texcoord = {0.0f, 1.0f}, .normal = {0, -1, 0} });
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, -1.0f, 1.0f},.texcoord = {1.0f, 0.0f}, .normal = {0, -1, 0} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, -1.0f, 1.0f}, .texcoord = {1.0f, 1.0f}, .normal = {0, -1, 0} });

	CreateVertexBufferView();
	CreateIndexBufferView();
}


void SkyBox::SetBlendMode(D3D12_BLEND_DESC& desc, BlendMode mode)
{
	switch (mode)
	{
	case kBlendModeAdd:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;
		break;
	case kBlendModeSubtract:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_REV_SUBTRACT;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;
		break;
	case kBlendModeMultiply:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_DEST_COLOR;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ZERO;
		break;
	case kBlendModeScreen:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_COLOR;
		break;
	default:
		assert(false);
		break;
	}
}

void SkyBox::CreateTransformationMatrix()
{
	// å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	wvpResource =Object3DCommon::GetInstance()->GetDxCommon()->
		CreateBufferResource(sizeof(TransformationMatrix));
	// å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹
	wvpResource->Map(0, nullptr, reinterpret_cast<void**>(&wvpData));
	// å¤‰æ›è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	wvpData->WVP = MakeIdentity4x4();
	wvpData->World = MakeIdentity4x4();
}

void SkyBox::CreateIndexBufferView() {

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚½ãƒ¼ã‚¹ä½œæˆ
	indexResource = dxCommon->CreateBufferResource(sizeof(uint32_t) * modelData.indices.size());

	// IndexBufferView è¨­å®š
	indexBufferView.BufferLocation = indexResource->GetGPUVirtualAddress();
	indexBufferView.SizeInBytes = UINT(sizeof(uint32_t) * modelData.indices.size());
	indexBufferView.Format = DXGI_FORMAT_R32_UINT;

	// ãƒãƒƒãƒ—ã—ã¦ãƒ‡ãƒ¼ã‚¿æ›¸ãè¾¼ã¿
	uint32_t* indexData = nullptr;
	indexResource->Map(0, nullptr, reinterpret_cast<void**>(&indexData));
	memcpy(indexData, modelData.indices.data(), sizeof(uint32_t) * modelData.indices.size());
}


============================================================
File Path: engine/3d/SkyBox/SkyBox.h
============================================================
#pragma once
#include "engine/math/MyMath.h"
#include "engine/base/DirectXCommon.h"
#include "engine/base/SrvManager.h"
#include "Game/Camera/camera.h"
/// <summary>
/// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã‚¯ãƒ©ã‚¹
/// </summary>
class SkyBox
{
private:
	/// <summary>
	/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	/// </summary>
	void CreatePipeline();

	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	/// </summary>
	void CreateRootSignature();

	/// <summary>
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	/// </summary>
	void SetGraphicsPipeline();

	/// <summary>
	/// ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ
	/// </summary>
	void CreateVertexBufferView();
	/// <summary>
	/// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®é ‚ç‚¹ç”Ÿæˆ
	/// </summary>
	void CreateVertexData();

	/// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ–
	/// </summary>
	void InitializeMaterial();

	/// <summary>
	/// ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š
	/// </summary>
	/// <param name="desc">è¨­å®šå¯¾è±¡ã®D3D12_BLEND_DESC</param>
	/// <param name="mode">ä½¿ç”¨ã™ã‚‹ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰</param>
	void SetBlendMode(D3D12_BLEND_DESC& desc, BlendMode mode);

	/// <summary>
	/// è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
	/// </summary>
	void CreateTransformationMatrix();

	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ç”Ÿæˆ
	/// </summary>
	void CreateIndexBufferView();
public:
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize(Engine::DirectXCommon* dxCommon, SrvManager* srvManager);
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();
private:
	///  ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
	ModelData modelData;


	// Initialize
	/// DxCommonã®ãƒã‚¤ãƒ³ã‚¿
	Engine::DirectXCommon* dxCommon = nullptr;
	/// SRVãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿
	SrvManager* srvManager = nullptr;

	// CreateRootSignature
	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
	/// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	D3D12_ROOT_PARAMETER rootParameters[3] = {};
	/// ã‚µãƒ³ãƒ—ãƒ©ãƒ¼
	D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
	/// å…¥åŠ›ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	D3D12_INPUT_ELEMENT_DESC inputElementDescs[3];
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	Microsoft::WRL::ComPtr<ID3D12RootSignature> rootSignature = nullptr;
	/// å…¥åŠ›ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_LAYOUT_DESC inputLayoutDesc{};

	/// ãƒ–ãƒ¬ãƒ³ãƒ‰
	D3D12_BLEND_DESC blendDesc{};
	BlendMode blendMode = BlendMode::kBlendModeAdd;
	BlendMode currentBlendMode = BlendMode::kBlendModeAdd;  // ç¾åœ¨ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰

	/// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ãƒ¼
	D3D12_RASTERIZER_DESC rasterizerDesc{};

	/// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒã‚¤ãƒŠãƒª
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob = nullptr;
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob = nullptr;

	/// æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};

	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
	Microsoft::WRL::ComPtr<ID3D12PipelineState> graphicsPipelineState = nullptr;
	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};

	// CreateVertexBufferView
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView{};
	/// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexResource = nullptr;
	/// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
	VertexData* vertexData = nullptr;

	// InitializeMaterial
	Microsoft::WRL::ComPtr<ID3D12Resource> materialResource = nullptr;
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿
	Material* materialData = nullptr;

	// CreateTransformationMatrix
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ / åº§æ¨™å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> wvpResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	TransformationMatrix* wvpData = nullptr;

	/// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ 
	std::vector<uint32_t> indices;
	Microsoft::WRL::ComPtr<ID3D12Resource> indexResource;
	D3D12_INDEX_BUFFER_VIEW indexBufferView{};

	/// ã‚«ãƒ¡ãƒ©å¼•æ•°
	Camera* camera = nullptr;
public:

	/// <summary>
	/// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> skyBoxTexture = nullptr;
	/// <summary>
	/// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ“ãƒ¥ãƒ¼
	/// </summary>
	D3D12_GPU_DESCRIPTOR_HANDLE skyBoxTextureView = {};
};



============================================================
File Path: engine/Audio/Audio.cpp
============================================================
#include "Audio.h"
#include <xaudio2.h> 
#include <cassert>
Audio* Audio::instance = nullptr;
Audio& Audio::GetInstance()
{
    static Audio instance;
    return instance;
}

void Audio::DeleteInstance()
{
	if (instance != nullptr)
	{
		delete instance;
		instance = nullptr;
	}
}

void Audio::Initialize()
{
	HRESULT hr;
	hr = XAudio2Create(&xaudio2_, 0, XAUDIO2_DEFAULT_PROCESSOR);
	hr = xaudio2_->CreateMasteringVoice(&masterVoice);
}

SoundData Audio::LoadWave(const char* filename)
{
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
    std::ifstream file(filename, std::ios_base::binary);
    // ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸã‚‰æ¤œå‡º
    assert(file.is_open());
    // RIFFãƒ˜ãƒƒãƒ€ãƒ¼ã‚’èª­ã¿è¾¼ã‚€
    RIFFHeader riff;
    file.read((char*)&riff, sizeof(riff));
    // ãƒ•ã‚¡ã‚¤ãƒ«ãŒRIFFã‹ãƒã‚§ãƒƒã‚¯
    assert(strncmp(riff.chunk.chunkID, "RIFF", 4) == 0);
    // ã‚¿ã‚¤ãƒ—ãŒWAVEã‹ãƒã‚§ãƒƒã‚¯
    assert(strncmp(riff.type, "WAVE", 4) == 0);

    // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒãƒ£ãƒ³ã‚¯ã‚’èª­ã¿è¾¼ã‚€
    FormatChunk fmt;
    file.read((char*)&fmt, sizeof(ChunkHeader));
    assert(strncmp(fmt.chunk.chunkID, "fmt ", 4) == 0);
    // ãƒãƒ£ãƒ³ã‚¯æœ¬ä½“ã®èª­ã¿è¾¼ã¿
    assert(fmt.chunk.chunkSize <= sizeof(fmt.format));
    file.read((char*)&fmt.format, fmt.chunk.chunkSize);

    // ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒ³ã‚¯ã‚’æ¢ã—ã¦èª­ã¿è¾¼ã‚€
    ChunkHeader data;
    while (file.read((char*)&data, sizeof(data)))
    {
        if (strncmp(data.chunkID, "data", 4) == 0)
        {
            break;
        }
        // èª­ã¿å–ã‚Šä½ç½®ã‚’æ¬¡ã®ãƒãƒ£ãƒ³ã‚¯ã«ç§»å‹•
        file.seekg(data.chunkSize, std::ios_base::cur);
    }
    assert(strncmp(data.chunkID, "data", 4) == 0);

    // ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒ³ã‚¯ã®ãƒ‡ãƒ¼ã‚¿éƒ¨ã®èª­ã¿è¾¼ã¿
    char* pBuffer = new char[data.chunkSize];
    file.read(pBuffer, data.chunkSize);

    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã‚‹
    file.close();

    // ãƒ‡ãƒ¼ã‚¿ã®è¨­å®š
    SoundData soundData;
    soundData.wfex = fmt.format;
    soundData.pBuffer = reinterpret_cast<BYTE*>(pBuffer);
    soundData.bufferSize = data.chunkSize;

    return soundData;
}


void Audio::SoundUnload(SoundData* soundData)
{
	// ãƒãƒƒãƒ•ã‚¡ã®è§£æ”¾
	delete[] soundData->pBuffer;
	soundData->pBuffer = 0;
	soundData->bufferSize = 0;
	soundData->wfex = {};

}

void Audio::SoundPlayWave(IXAudio2* xAudio2, const SoundData& soundData)
{
	HRESULT hr;
	// ã‚½ãƒ¼ã‚¹ãƒœã‚¤ã‚¹ã®ä½œæˆ
	IXAudio2SourceVoice* sourceVoice = nullptr;
	hr = xAudio2->CreateSourceVoice(&sourceVoice, reinterpret_cast<const WAVEFORMATEX*>(&soundData.wfex));
	assert(SUCCEEDED(hr));
	

	// å†ç”Ÿã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®è¨­å®š
	XAUDIO2_BUFFER buffer = {};
	buffer.AudioBytes = soundData.bufferSize;
	buffer.pAudioData = soundData.pBuffer;
	buffer.Flags = XAUDIO2_END_OF_STREAM;
		
	// å†ç”Ÿ
	hr = sourceVoice->SubmitSourceBuffer(&buffer);
	hr = sourceVoice->Start();
}



============================================================
File Path: engine/Audio/Audio.h
============================================================
#pragma once
#include <xaudio2.h>
#pragma comment(lib, "xaudio2.lib")
#include <fstream>
#include <wrl.h>

/// <summary>
/// ã‚µã‚¦ãƒ³ãƒ‰ç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
/// <remarks>
/// XAudio2ã‚’ç”¨ã„ã¦ã‚µã‚¦ãƒ³ãƒ‰ã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹
/// </remarks>


struct ChunkHeader
{
	char chunkID[4];
	uint32_t chunkSize;
};
struct RIFFHeader
{
	ChunkHeader chunk;
	char type[4];
};
struct FormatChunk {
	ChunkHeader chunk;
	WAVEFORMATEX format;
};
struct SoundData {
	// æ³¢å½¢ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	WAVEFORMATEX wfex;
	// ãƒãƒƒãƒ•ã‚¡ã®å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹
	BYTE* pBuffer;
	// ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚º
	unsigned int bufferSize;
};
class Audio
{
public:
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	static Audio& GetInstance();
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å‰Šé™¤
	/// </summary>
	static void DeleteInstance();
	
private:
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	/// </summary>
	static Audio* instance;
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	Audio() = default;
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~Audio() = default;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ä»£å…¥æ¼”ç®—å­ã®ç¦æ­¢
	/// </summary>
	Audio(Audio&) = delete;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ä»£å…¥æ¼”ç®—å­ã®ç¦æ­¢
	/// </summary>
	Audio& operator=(Audio&) = delete;


public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();
	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰ã®èª­ã¿è¾¼ã¿
	/// </summary>
	SoundData LoadWave(const char* filename);
	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰ã®è§£æ”¾
	///ã€€</summary>
	void SoundUnload(SoundData* soundData);
	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰ã®å†ç”Ÿ
	///ã€€</summary>
	void SoundPlayWave(IXAudio2* xAudio2, const SoundData& soundData);

public:
	/// <summary>
	/// XAudio2ã®å–å¾—
	/// </summary>
	IXAudio2* GetXAudio2() const { return xaudio2_.Get(); }

private:
	/// XAudio2
	Microsoft::WRL::ComPtr<IXAudio2> xaudio2_;
	// â†“ã®å‹ã«ã¯Release()ãŒç„¡ã„ã®ã§ã€ComPtrã‚’ä½¿ã‚ãªã„
	IXAudio2MasteringVoice* masterVoice;
};


============================================================
File Path: engine/InsideScene/AbstractSceneFactory.cpp
============================================================
#include "AbstractSceneFactory.h"


============================================================
File Path: engine/InsideScene/AbstractSceneFactory.h
============================================================
#pragma once
#include "BaseScene.h"
#include <string>
#include <memory>
// ã‚·ãƒ¼ãƒ³å·¥å ´ã‚¯ãƒ©ã‚¹
class AbstractSceneFactory
{
public:
	/// <summary>
	/// ä»®æƒ³ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	virtual ~AbstractSceneFactory() = default;
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	/// </summary>
	/// <param name="sceneName"></param>
	/// <returns></returns>
	virtual std::unique_ptr<BaseScene> CreateScene(const std::string&sceneName) = 0;
};



============================================================
File Path: engine/InsideScene/BaseScene.cpp
============================================================
#include "BaseScene.h"


============================================================
File Path: engine/InsideScene/BaseScene.h
============================================================
#pragma once
#include "DirectXCommon.h"

/// <summary>
/// ã‚·ãƒ¼ãƒ³åŸºåº•ã‚¯ãƒ©ã‚¹
/// </summary>
class SceneManager;
class BaseScene
{
public:
    /// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BaseScene() = default;
    /// <summary>
	/// åˆæœŸåŒ–
    /// </summary>
    /// <param name="dxCommon"></param>
    virtual void Initialize(Engine::DirectXCommon* dxCommon) = 0;
    /// <summary>
	/// æ›´æ–°
    /// </summary>
    virtual void Update() = 0;
    /// <summary>
	/// æç”»
    /// </summary>
    virtual void Draw() = 0;
    /// <summary>
	/// çµ‚äº†å‡¦ç†
    /// </summary>
    virtual void Finalize() = 0;
    // Setter
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ã‚»ãƒƒãƒˆ
	/// </summary>
    virtual void SetSceneManager(SceneManager* sceneManager) { this->sceneManager = sceneManager; }

protected:
	// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
    SceneManager* sceneManager = nullptr;
};



============================================================
File Path: engine/InsideScene/Framework.cpp
============================================================
#include "Framework.h"
#include "engine/InsideScene/SceneManager.h"
#include "Game/Particle/ModelParticleManager.h"
using namespace Engine;

void Framework::Initialize()
{
	//WindowsAPIã®åˆæœŸåŒ–
	winAPI = make_unique<WinAPI>();
	winAPI->Initialize();
	// dxCommonã®åˆæœŸåŒ–
	dxCommon = make_unique<DirectXCommon>();
	dxCommon->Initialize(winAPI.get());

	// å…¥åŠ›å‡¦ç†ã®ã‚¯ãƒ©ã‚¹ãƒã‚¤ãƒ³ã‚¿
	
	Input::GetInstance()->Initialize(winAPI.get());

	// SRVãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
	srvManager = make_unique<SrvManager>();
	srvManager->Initialize(dxCommon.get());
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
	TextureManager::GetInstance()->Initialize(dxCommon.get(), srvManager.get());


#ifdef USE_IMGUI
	// ImGuiã®åˆæœŸåŒ–
	imGui = make_unique<ImGuiManager>();
	imGui->Initialize(winAPI.get(), dxCommon.get());
#endif

	// 3Dãƒ¢ãƒ‡ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
	ModelManager::GetInstance().Initialize(dxCommon.get());
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…±é€šéƒ¨ã®åˆæœŸåŒ–
	Object3DCommon::GetInstance()->Initialize(dxCommon.get());

	// ãƒ¢ãƒ‡ãƒ«å…±é€šéƒ¨ã®åˆæœŸåŒ–
	modelCommon = make_unique<ModelCommon>();
	modelCommon->Initialize(dxCommon.get());

	// ã‚«ãƒ¡ãƒ©
	camera = make_unique<Camera>();
	camera->SetRotate({ 0.0f, 0.0f, 0.0f });
	camera->SetTranslate({ 0.0f, 0.0f, -5.0f });

	// å…¨ã‚·ãƒ¼ãƒ³ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã‚«ãƒ¡ãƒ©ã«è¨­å®š
	mainCamera_ = camera.get();

	Object3DCommon::GetInstance()->SetDefaultCamera(camera.get());

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	ParticleManager::GetInstance()->Initialize(dxCommon.get(), srvManager.get(), camera.get());
	
	

	/// ãƒãƒƒãƒ—ã«åˆã‚ã›ã‚‹
	/*cameraTransform.translate = { 7.5f,-4.0f,0.0f };
	camera->SetTranslate(cameraTransform.translate);*/

}

void Framework::Update()
{
#pragma region WindowsAPIã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
	//Windowã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
	if (winAPI->ProcessMessage()) {
		//ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
		isEndRequest_ = true;
		return;
	}
#pragma endregion

	Input::GetInstance()->Update();
	// ã‚«ãƒ¡ãƒ©ã®æ›´æ–°
	camera->Update();

	SceneManager::GetInstance()->Update(dxCommon.get());
	
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°
	ParticleManager::GetInstance()->Update();
	
}


void Framework::Draw()
{
	
}


void Framework::Finalize()
{
	/// å„ç¨®ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®çµ‚äº†å‡¦ç†

	SceneManager::GetInstance()->Finalize();
	SceneManager::DestroyInstance();
	Audio::GetInstance().DeleteInstance();
	Object3DCommon::GetInstance()->DeleteInstance();
	TextureManager::GetInstance()->DeleteInstance();
	ModelManager::GetInstance().Finalize();
	Input::GetInstance()->DeleteInstance();
	winAPI->Finalize();
	mainCamera_ = nullptr;
	ParticleManager::GetInstance()->DeleteInstance();

}

void Framework::Run()
{
	// ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–
	Initialize();
	// ã‚²ãƒ¼ãƒ ã®ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
	while (true) {
		// ã‚²ãƒ¼ãƒ ã®æ›´æ–°
		Update();
		if (IsEndRequest()) {
			break;
		}
		// ã‚²ãƒ¼ãƒ ã®æç”»
		Draw();
	}
	// ã‚²ãƒ¼ãƒ ã®çµ‚äº†å‡¦ç†
	Finalize();
}



============================================================
File Path: engine/InsideScene/Framework.h
============================================================
#pragma once
#include<fstream>
#include<sstream>
#include<wrl.h>
#include "numbers"
#include "WinAPI.h"
#include "DirectXCommon.h"
#include "Sprite.h"
#include "SpriteCommon.h"
#include "TextureManager.h"
#include "Object3D.h"
#include "Object3DCommon.h"
#include "ModelManager.h"
#ifdef USE_IMGUI
#include "ImGuiManager.h"
#endif
#include "Audio.h"
#include "SceneManager.h"
#include "Game/Particle/ParticleManager.h"
#include "engine/3d/SkyBox/SkyBox.h"
#include "AbstractSceneFactory.h"
#include "D3DResourceLeakChecker.h"
#include "Input.h"
#include "engine/2d/RenderTexture.h"
/// <summary>
/// ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯åŸºåº•ã‚¯ãƒ©ã‚¹
/// </summary>
class Framework
{

public:
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	virtual ~Framework() = default;
public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	virtual void Initialize();
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	virtual void Update();
	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	virtual void Draw() = 0;
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	virtual void Finalize();
	/// <summary>
	/// å®Ÿè¡Œ
	/// </summary>
	void Run();
	/// <summary>
	/// çµ‚äº†ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æœ‰ç„¡
	/// </summary>
	/// <returns></returns>
	bool IsEndRequest() { return isEndRequest_; }

protected:
	// çµ‚äº†ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
	bool isEndRequest_ = false;
protected:// Initializeé–¢é€£
	// ãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚«ãƒ¼
	//D3DResourceLeakChecker leakCheck;
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦API
	std::unique_ptr<WinAPI> winAPI;
	// DirectXå…±é€šéƒ¨
	std::unique_ptr<Engine::DirectXCommon> dxCommon;
	// ImGui
#ifdef USE_IMGUI
	std::unique_ptr<ImGuiManager> imGui;
#endif
	// SRVãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
	std::unique_ptr<SrvManager> srvManager;
	// ãƒ¢ãƒ‡ãƒ«å…±é€šéƒ¨
	std::unique_ptr<ModelCommon> modelCommon;
	// ã‚«ãƒ¡ãƒ©
	std::unique_ptr<Camera> camera;


	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
	std::unique_ptr<RenderTexture> renderTexture = nullptr;

public:
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
	std::unique_ptr<AbstractSceneFactory> sceneFactory_ = nullptr;
	// å…¨ã‚·ãƒ¼ãƒ³ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã‚«ãƒ¡ãƒ©
	static Camera* GetMainCamera() { return mainCamera_; }
private:
	
	/// ã‚«ãƒ¡ãƒ©ã®åº§æ¨™
	Transform cameraTransform = {
		{0.0f, 0.0f, -10.0f}, // translate
		{0.0f, 0.0f, 0.0f}, // rotate
		{ 1.0f, 1.0f,-10.0f } // scale
	};

	static inline Camera* mainCamera_ = nullptr;
	
};



============================================================
File Path: engine/InsideScene/SceneFactory.cpp
============================================================
#include "SceneFactory.h"
#include "Game/Scene/TitleScene.h"
#include "Game/Scene/GamePlayScene.h"
#include "Game/Scene/StageSelectScene.h"
#include "Game/Scene/StageClearScene.h"
std::unique_ptr<BaseScene> SceneFactory::CreateScene(const std::string& sceneName)
{
    // æ¬¡ã®ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	if (sceneName == "TITLE") {
		return std::make_unique<TitleScene>();
	}
	else if (sceneName == "GAMEPLAY") {
		return std::make_unique<GamePlayScene>();
	}
	else if (sceneName == "STAGESELECT") {
		return std::make_unique<StageSelectScene>();
	}
	else if (sceneName == "STAGECLEAR") {
		return std::make_unique<StageClearScene>();
	}
	return nullptr;
}


============================================================
File Path: engine/InsideScene/SceneFactory.h
============================================================
#pragma once
#include "AbstractSceneFactory.h"
#include <memory>
/// <summary>
/// ã‚·ãƒ¼ãƒ³å·¥å ´ã‚¯ãƒ©ã‚¹
/// </summary>
class SceneFactory : public AbstractSceneFactory
{
public:
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	/// </summary>
	/// <param name="sceneName"></param>
	/// <returns></returns>
	std::unique_ptr<BaseScene> CreateScene(const std::string& sceneName)override;
};



============================================================
File Path: engine/InsideScene/SceneManager.cpp
============================================================
#include "SceneManager.h"

using namespace Engine;

static SceneManager* instance = nullptr;


SceneManager* SceneManager::GetInstance()
{
	if (instance == nullptr)
	{
		instance = new SceneManager();
	}
	return instance;
}

void SceneManager::DestroyInstance()
{
	if (instance != nullptr)
	{
		delete instance;
		instance = nullptr;
	}
}

void SceneManager::Update(DirectXCommon* dxCommon)
{
    // æ¬¡ã®ã‚·ãƒ¼ãƒ³ãŒäºˆç´„ã•ã‚Œã¦ã„ã‚‹å ´åˆ
    if (nextScene_) {
        // ä»Šã®ã‚·ãƒ¼ãƒ³ã®çµ‚äº†å‡¦ç†
        if (scene_) {
            scene_->Finalize();
			scene_.reset();
        }
        // æ¬¡ã®ã‚·ãƒ¼ãƒ³ã®åˆæœŸåŒ–
        scene_ = std::move(nextScene_);
        // ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®è¨­å®š
        scene_->SetSceneManager(this);
        scene_->Initialize(dxCommon);
    }
    // å®Ÿè¡Œä¸­ã‚·ãƒ¼ãƒ³ã‚’æ›´æ–°
    if (scene_) {
        scene_->Update();
    }
}


void SceneManager::Draw()
{
    // å®Ÿè¡Œä¸­ã‚·ãƒ¼ãƒ³ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿æç”»
    if (scene_) {
        scene_->Draw();
    }
}

void SceneManager::Finalize()
{
    // æœ€å¾Œã®ã‚·ãƒ¼ãƒ³ã®çµ‚äº†å‡¦ç†
    if (scene_)
    {
        scene_->Finalize();
        scene_.reset();
    }
}

void SceneManager::ChangeScene(const std::string& sceneName)
{
    assert(!nextScene_);
    assert(sceneFactory_);

	// æ¬¡ã®ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	nextScene_ = sceneFactory_->CreateScene(sceneName);
}






============================================================
File Path: engine/InsideScene/SceneManager.h
============================================================
#pragma once
#include "BaseScene.h"
#include "AbstractSceneFactory.h"
// ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚¯ãƒ©ã‚¹
// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹
class SceneManager
{
public:
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	static SceneManager* GetInstance();
	static void DestroyInstance();
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	SceneManager() = default;
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~SceneManager() = default;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ç„¡åŠ¹åŒ–
	/// </summary>
	/// <param name=""></param>
	SceneManager(SceneManager&) = delete;
	/// <summary>
	/// ä»£å…¥æ¼”ç®—å­ã®ç„¡åŠ¹åŒ–
	/// </summary>
	/// <param name=""></param>
	/// <returns></returns>
	SceneManager& operator=(SceneManager&) = delete;

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon"></param>
	void Update(Engine::DirectXCommon*dxCommon);
	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();

public:
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="sceneFactory"></param>
	void SetSceneFactory(AbstractSceneFactory* sceneFactory) { sceneFactory_ = sceneFactory; }
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³å¤‰æ›´
	/// </summary>
	/// <param name="sceneName"></param>
	void ChangeScene(const std::string& sceneName);

private:
	// ä»Šã®ã‚·ãƒ¼ãƒ³
	std::unique_ptr<BaseScene> scene_ = nullptr;
	// æ¬¡ã®ã‚·ãƒ¼ãƒ³
	std::unique_ptr<BaseScene> nextScene_ = nullptr;

	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ // å€Ÿã‚Šç‰©
	AbstractSceneFactory* sceneFactory_ = nullptr;
	
};



============================================================
File Path: engine/base/D3DResourceLeakChecker.cpp
============================================================
#include "D3DResourceLeakChecker.h"
#include <dxgidebug.h>
#include <d3d12.h>
#include <dxgi1_6.h>
#include <wrl.h>

D3DResourceLeakChecker::~D3DResourceLeakChecker() {

	//ãƒªã‚½ãƒ¼ã‚¹ãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚¯
	Microsoft::WRL::ComPtr<IDXGIDebug1> debug;
	if (SUCCEEDED(DXGIGetDebugInterface1(0, IID_PPV_ARGS(&debug)))) {
		debug->ReportLiveObjects(DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_ALL);
		debug->ReportLiveObjects(DXGI_DEBUG_APP, DXGI_DEBUG_RLO_ALL);
		debug->ReportLiveObjects(DXGI_DEBUG_D3D12, DXGI_DEBUG_RLO_ALL);
	}
}

============================================================
File Path: engine/base/D3DResourceLeakChecker.h
============================================================
#pragma once

/// <summary>
/// D3Dãƒªã‚½ãƒ¼ã‚¹ãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚«ãƒ¼
/// </summary>
/// <remarks>
/// D3Dãƒªã‚½ãƒ¼ã‚¹ã®ãƒªãƒ¼ã‚¯ã‚’æ¤œå‡ºã™ã‚‹
/// </remarks>
class D3DResourceLeakChecker
{
public:

	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~D3DResourceLeakChecker();


};



============================================================
File Path: engine/base/DirectXCommon.cpp
============================================================
#include "DirectXCommon.h"
#include <cassert>
#include <format>
#include <string>
#include <thread>
#include "Logger.h"
#include "StringUtility.h"
#ifdef USE_IMGUI
#include "externals/imgui/imgui.h"
#include "externals/imgui/imgui_impl_dx12.h"
#include "externals/imgui/imgui_impl_win32.h"
#endif

#pragma comment(lib,"d3d12.lib")
#pragma comment(lib,"dxgi.lib")
#pragma comment(lib,"dxcompiler.lib")
#pragma comment(lib,"dxguid.lib")

using namespace Microsoft::WRL;
using namespace Logger;
using namespace Engine;



DirectXCommon::DirectXCommon()
{
}
void DirectXCommon::Initialize(WinAPI* winAPI)
{
	// NULLæ¤œå‡º
	assert(winAPI);
	// FPSå›ºå®šåˆæœŸåŒ–
	InitializeFixFPS();

	//å€Ÿã‚Šã¦ããŸWinAPIã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¨˜éŒ²
	this->winAPI_ = winAPI;
	//ãƒ‡ãƒã‚¤ã‚¹ã®ç”Ÿæˆ
	InitDevice();
	//ã‚³ãƒãƒ³ãƒ‰é–¢é€£ã®åˆæœŸåŒ–
	InitCommand();
	//ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³ã®ç”Ÿæˆ
	CreateSwapChain();
	//å„ç¨®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	CreateDescriptorHeaps();
	//ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
	InitRenderTargetView();
	//æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
	InitDepthStencilView();
	//ãƒ•ã‚§ãƒ³ã‚¹ã®åˆæœŸåŒ–
	InitFence();
	//ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆçŸ©å½¢ã®åˆæœŸåŒ–
	InitViewportRect();
	//ã‚·ã‚¶ãƒªãƒ³ã‚°çŸ©å½¢ã®åˆæœŸåŒ–
	InitScissorRect();
	// imguiã®åˆæœŸåŒ–
	//InitImGui();

	//DXCã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ç”Ÿæˆ
	CreateDXCCompiler();


}

void DirectXCommon::InitCommand()
{
#pragma region commandAllocator
	//ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’èµ·å‹•ã™ã‚‹
	HRESULT hr = device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&commandAllocator));
	//ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã®ç”ŸæˆãŒä¸Šæ‰‹ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region CommandList
	hr = device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator.Get(), nullptr, IID_PPV_ARGS(commandList.GetAddressOf()));
	//ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ç”ŸæˆãŒä¸Šæ‰‹ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region CommandQueue
	//ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã‚’ç”Ÿæˆã™ã‚‹
	D3D12_COMMAND_QUEUE_DESC commandQueueDesc{};
	hr = device->CreateCommandQueue(&commandQueueDesc, IID_PPV_ARGS(&commandQueue));
	//ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã®ç”ŸæˆãŒä¸Šæ‰‹ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
#pragma endregion
}

void DirectXCommon::InitDevice()
{
	HRESULT hr;

#pragma region ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚ªãƒ³
	Microsoft::WRL::ComPtr < ID3D12Debug1> debugController = nullptr;
	if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController)))) {
		debugController->EnableDebugLayer();
		debugController->SetEnableGPUBasedValidation(TRUE);
	}
#pragma endregion
#pragma region DXGIFactoryã®ç”Ÿæˆ
	//DXGIãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ç”Ÿæˆ

	//HRESULTã¯Windowsç³»ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚Š
	//é–¢æ•°ãŒæˆåŠŸã—ãŸã‹å‹•ã‹ã‚’SUCCEEDEDãƒã‚¯ãƒ­åˆ¤å®šã§ãã‚‹
	hr = CreateDXGIFactory(IID_PPV_ARGS(&dxgiFactory));//IID_PPV_ARGSã¯å¼•æ•°ã‚’ä¸€ã¤ã«ã—ã¦ãã‚Œã‚‹ãŠã¾ã˜ãªã„
	//åˆæœŸåŒ–ã®æ ¹æœ¬çš„ãªéƒ¨åˆ†ã§ã‚¨ãƒ©ãƒ¼ãŒå‡ºãŸå ´åˆã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒé–“é•ã£ã¦ã„ã‚‹ã‹ã€
	//ã©ã†ã«ã‚‚ã§ããªã„å ´åˆãŒå¤šã„ã®ã§assertã«ã—ã¦ãŠã
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼
	Microsoft::WRL::ComPtr<IDXGIAdapter4> useAdapter = nullptr;
	//è‰¯ã„é †ã«ã‚¢ãƒ€ãƒ—ã‚¿ã‚’é ¼ã‚€
	for (UINT i = 0; dxgiFactory->EnumAdapterByGpuPreference(i,
		DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE, IID_PPV_ARGS(useAdapter.GetAddressOf())) !=
		DXGI_ERROR_NOT_FOUND; ++i) {
		//ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®æƒ…å ±ã‚’å–å¾—ã™ã‚‹
		DXGI_ADAPTER_DESC3 adapterDesc{};
		hr = useAdapter->GetDesc3(&adapterDesc);
		assert(SUCCEEDED(hr));//å–å¾—ã§ããªã„ã®ã¯ä¸€å¤§äº‹
		//ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¢ãƒ€ãƒ—ã‚¿ã§ç„¡ã‘ã‚Œã°æ¡ç”¨
		if (!(adapterDesc.Flags & DXGI_ADAPTER_FLAG3_SOFTWARE)) {
			//æ¡ç”¨ã—ãŸã‚¢ãƒ€ãƒ—ã‚¿ã‚ã®æƒ…å ±ã‚’ãƒ­ã‚°ã«å‡ºåŠ› wstringãªã®ã§æ³¨æ„
			Log(StringUtility::ConvertString(std::format(L"Use Adapter:{}\n", adapterDesc.Description)));
			break;
		}
		useAdapter.Reset();//ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¢ãƒ€ãƒ—ã‚¿ã®å ´åˆã¯è¦³ãªã‹ã£ãŸã“ã¨ã«ã™ã‚‹
	}
	assert(useAdapter != nullptr);//é©åˆ‡ãªã‚¢ãƒ€ãƒ—ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚‰èµ·å‹•ã§ããªã„

#pragma endregion
#pragma region Deviceã®ç”Ÿæˆ
	_putenv("D3D12_ENABLE_LEAK_TRACKING=1");
	//æ©Ÿèƒ½ãƒ¬ãƒ™ãƒ«ã¨ãƒ­ã‚°å‡ºåŠ›ç”¨ã®æ–‡å­—åˆ—
	D3D_FEATURE_LEVEL featureLevels[] = {
		D3D_FEATURE_LEVEL_12_2,D3D_FEATURE_LEVEL_12_1,D3D_FEATURE_LEVEL_12_0
	};
	const char* featureLevelStrings[] = { "12.2","12.1","12.0" };
	//é«˜ã„é †ã«ç”Ÿæˆã§ãã‚‹ã‹è©¦ã—ã¦ã„ã
	for (size_t i = 0; i < _countof(featureLevels); ++i) {
		//æ¡ç”¨ã—ãŸã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã§ãƒ‡ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆ
		hr = D3D12CreateDevice(useAdapter.Get(),
			featureLevels[i],
			IID_PPV_ARGS(&device));
		//æŒ‡å®šã—ãŸæ©Ÿèƒ½ãƒ¬ãƒ™ãƒ«ã§ãƒ‡ãƒã‚¤ã‚¹ãŒç”Ÿæˆã•ã‚ŒãŸã‹ã‚’ç¢ºèª
		if (SUCCEEDED(hr)) {
			//ç”Ÿæˆã§ããŸã®ã§ãƒ­ã‚°å‡ºåŠ›ã‚’è¡Œã£ã¦ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
			Log(std::format("FeatureLevels : {}\n", featureLevelStrings[i]));
			break;
		}
	}
	//ãƒ‡ãƒã‚¤ã‚¹ã®ç”ŸæˆãŒä¸Šæ‰‹ãã„ã‹ãªã‹ã£ãŸã®ã§ç”Ÿæˆã§ããªã„
	assert(device != nullptr);
	Log("Complete create D3D12Device!!!\n");


#pragma endregion
#pragma region ã‚¨ãƒ©ãƒ¼æ™‚ã«ãƒ–ãƒ¬ã‚¤ã‚¯
#ifdef _DEBUG // ã‚¨ãƒ©ãƒ¼æ™‚ã«ãƒ–ãƒ¬ãƒ¼ã‚¯ã‚’ç™ºç”Ÿã•ã›ã‚‹è¨­å®š
	Microsoft::WRL::ComPtr<ID3D12InfoQueue> infoQueue;
	if (SUCCEEDED(device.As(&infoQueue))) {
		//ã‚„ã°ã„ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
		//ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true);
		//è­¦å‘Šæ™‚ã«æ­¢ã¾ã‚‹
		//infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, true);
		D3D12_MESSAGE_ID denyIds[] = {
			//
			D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_COMMAND_LIST_TYPE
		};
		//Windows11ã§ã®DXGIãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨DX12ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›¸äº’ä½œç”¨ãƒã‚°ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
		D3D12_MESSAGE_SEVERITY severities[] = { D3D12_MESSAGE_SEVERITY_INFO };
		D3D12_INFO_QUEUE_FILTER filter{};
		filter.DenyList.NumIDs = _countof(denyIds);
		filter.DenyList.pIDList = denyIds;
		filter.DenyList.NumSeverities = _countof(severities);
		filter.DenyList.pSeverityList = severities;
		//æŠ‘åˆ¶ã™ã‚‹ãƒ¬ãƒ™ãƒ«
		infoQueue->PushStorageFilter(&filter);
	}
#endif  _DEBUG
#pragma endregion



}

void DirectXCommon::CreateSwapChain()
{
#pragma region ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³ã®ç”Ÿæˆ
	swapChainDesc.Width = WinAPI::kClientWidth;		//ç”»é¢ã®å¹…ã€€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’åŒã˜ã‚‚ã®ã«ã—ã¦ãŠã
	swapChainDesc.Height = WinAPI::kClientHeight;	//ç”»é¢ã®é«˜ã•ã€€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”ºåŸŸã‚’åŒã˜ã‚‚ã®ã«ã—ã¦ãŠã
	swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;//
	swapChainDesc.SampleDesc.Count = 1;//è‰²ã®å½¢å¼
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;//ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ã—ãªã„
	swapChainDesc.BufferCount = 2;//ãƒ€ãƒ–ãƒ«ãƒãƒƒãƒ•ã‚¡
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;//ãƒ¢ãƒ‹ã‚¿ã«å†™ã—ãŸã‚‰ä¸­èº«ã‚’ç ´å£Š
	//ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«ã€è¨­å®šã‚’æ¸¡ã—ã¦ç”Ÿæˆã™ã‚‹
	HRESULT hr = dxgiFactory->CreateSwapChainForHwnd(commandQueue.Get(), winAPI_->GetHwnd(), &swapChainDesc, nullptr, nullptr, reinterpret_cast<IDXGISwapChain1**>(swapChain.GetAddressOf()));
	//ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®ç”ŸæˆãŒä¸Šæ‰‹ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
#pragma endregion


}

Microsoft::WRL::ComPtr<ID3D12Resource> DirectXCommon::CreateDepthBuffer(Microsoft::WRL::ComPtr<ID3D12Device> device, int32_t width, int32_t height)
{
	// ç”Ÿæˆã™ã‚‹Resourceã®è¨­å®š
	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Width = width;										// Textureã®ã¯å¹…
	resourceDesc.Height = height;									// Textureã®é«˜ã•
	resourceDesc.MipLevels = 1;										// mipmapã®æ•°
	resourceDesc.DepthOrArraySize = 1;								//å¥¥è¡Œã or é…åˆ—Textureã®é…åˆ—æ•°
	resourceDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;			// Depth stencilã¨ã—ã¦åˆ©ç”¨å¯èƒ½ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	resourceDesc.SampleDesc.Count = 1;								//ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚«ã‚¦ãƒ³ãƒˆã€‚1å›ºå®šã€‚
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	//2æ¬¡å…ƒ
	resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;	// DepthStencilã¨ã—ã¦ä½¿ã†é€šçŸ¥
	//.åˆ©ç”¨ã™ã‚‹Heapã®è¨­å®š
	D3D12_HEAP_PROPERTIES heapProperties{};
	heapProperties.Type = D3D12_HEAP_TYPE_DEFAULT;					// VRAMä¸Šã«ä½œã‚‹

	// æ·±åº¦å€¤ã®ã‚¯ãƒªã‚¢è¨­å®š
	D3D12_CLEAR_VALUE depthClearValue{};
	depthClearValue.DepthStencil.Depth = 1.0f;						// 1.0f (æœ€å¤§å€¤)ã€€ã§ã‚¯ãƒªã‚¢
	depthClearValue.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;			// ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã€‚Resourceã¨åˆã‚ã›ã‚‹

	// Resourceã®ç”Ÿæˆ

	HRESULT hr = device->CreateCommittedResource(
		&heapProperties, // Heapã®è¨­å®š
		D3D12_HEAP_FLAG_NONE,//Heapã®ç‰¹æ®Šãªè¨­å®šã€‚ç‰¹ã«ãªã—ã€‚
		&resourceDesc,// Resourceã®è¨­å®š
		D3D12_RESOURCE_STATE_DEPTH_WRITE,//æ·±åº¦å€¤ã‚’æ›¸ãè¾¼ã‚€çŠ¶æ…‹ã«ã—ã¦ãŠã
		&depthClearValue,// clearæœ€é©å€¤
		IID_PPV_ARGS(&resource));//ä½œæˆã™ã‚‹Resourceãƒã‚¤ãƒ³ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	assert(SUCCEEDED(hr));

	return resource;
}
ComPtr <ID3D12DescriptorHeap>
DirectXCommon::CreateDescriptorHeap(
	D3D12_DESCRIPTOR_HEAP_TYPE heapType,
	UINT numDescriptors,
	bool shaderVisible)
{
	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> descriptorHeap;
	D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc{};
	descriptorHeapDesc.Type = heapType;//ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼
	descriptorHeapDesc.NumDescriptors = numDescriptors;//ãƒ€ãƒ–ãƒ«ãƒãƒƒãƒ•ã‚¡ç”¨ã«ï¼’ã¤ã€‚å¤šãã¦ã‚‚ã‹ã¾ã‚ãªã„
	descriptorHeapDesc.Flags = shaderVisible ? D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE : D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	HRESULT hr = device->CreateDescriptorHeap(&descriptorHeapDesc, IID_PPV_ARGS(&descriptorHeap));//
	//ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ãŒã¤ãã‚Œãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
	return descriptorHeap;
}

void DirectXCommon::CreateDescriptorHeaps()
{
	//descriptorSizeSRV = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
	descriptorSizeRTV = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
	//dsv
#pragma region DescriptorHEAPã®ç”Ÿæˆ
	rtvDescriptorHeap = CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_RTV, 2, false);
	//srvDescriptorHeap = CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, kMaxSRVCount, true);
	// DSVç”¨ã®ãƒ’ãƒ¼ãƒ—ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ•°ã¯ï¼‘ã€‚DSVã¯Shaderå†…ã§è§¦ã‚‹ã‚‚ã®ã§ã¯ãªã„ã®ã§ã€ShaderVisibleã¯false
	dsvDescriptorHeap = CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_DSV, 1, false);
#pragma endregion

}

void DirectXCommon::InitRenderTargetView()
{
	//ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³ã‹ã‚‰ãƒªã‚½ãƒ¼ã‚¹ã‚’å¼•ã£å¼µã£ã¦ãã‚‹
	HRESULT hr = swapChain->GetBuffer(0, IID_PPV_ARGS(&swapChainResources[0]));
	//ä¸Šæ‰‹ãå–å¾—ã§ããªã‘ã‚Œã°èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
	hr = swapChain->GetBuffer(1, IID_PPV_ARGS(&swapChainResources[1]));
	assert(SUCCEEDED(hr));


	rtvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;

	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å…ˆé ­ã‚’å–å¾—ã™ã‚‹
	D3D12_CPU_DESCRIPTOR_HANDLE rtvStartHandle = rtvDescriptorHeap->GetCPUDescriptorHandleForHeapStart();


	for (uint32_t i = 0; i < 2; ++i) {
		rtvHandles[i] = rtvStartHandle;

		device->CreateRenderTargetView(swapChainResources[i].Get(), &rtvDesc, rtvHandles[i]);
		rtvStartHandle.ptr += device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
	}
}

D3D12_CPU_DESCRIPTOR_HANDLE DirectXCommon::GetCPUDescriptorHandle(const Microsoft::WRL::ComPtr<ID3D12DescriptorHeap>& descriptorHeap, uint32_t descriptorSize, uint32_t index)
{
	D3D12_CPU_DESCRIPTOR_HANDLE handleCPU = descriptorHeap->GetCPUDescriptorHandleForHeapStart();
	handleCPU.ptr += (descriptorSize * index);
	return handleCPU;
}
D3D12_GPU_DESCRIPTOR_HANDLE DirectXCommon::GetGPUDescriptorHandle(const Microsoft::WRL::ComPtr<ID3D12DescriptorHeap>& descriptorHeap, uint32_t descriptorSize, uint32_t index)
{
	D3D12_GPU_DESCRIPTOR_HANDLE handleGPU = descriptorHeap->GetGPUDescriptorHandleForHeapStart();
	handleGPU.ptr += (descriptorSize * index);
	return handleGPU;
}



void DirectXCommon::PreDraw()
{
#pragma region ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ç•ªå·å–å¾—
	// ã“ã“ã‹ã‚‰æ›¸ãè¾¼ã‚€ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
	backBufferIndex = swapChain->GetCurrentBackBufferIndex();
#pragma endregion

#pragma region ãƒªã‚½ãƒ¼ã‚¹ãƒãƒªã‚¢ã®è¨­å®š

	// ä»Šå›ã®ãƒãƒªã‚¢ã¯ Transition
	barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	// Noneã«ã—ã¦ãŠã
	barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	// ãƒãƒªã‚¢ã‚’å¼µã‚‹å¯¾è±¡ã®ãƒªã‚½ãƒ¼ã‚¹ã€‚ç¾åœ¨ã®ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã«å¯¾ã—ã¦è¡Œã†
	barrier.Transition.pResource = swapChainResources[backBufferIndex].Get();
	// é·ç§»å‰ï¼ˆç¾åœ¨ï¼‰ã® ResourceStart
	barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
	// é·ç§»å¾Œã® ResourceStart
	barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;
	// TransitionBarrier ã‚’å¼µã‚‹
	commandList->ResourceBarrier(1, &barrier);
#pragma endregion 

#pragma region RTVã¨DSVã®è¨­å®š
	// æç”»å…ˆã®RTVã¨DSVã‚’æŒ‡å®šã™ã‚‹
	D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle = dsvDescriptorHeap->GetCPUDescriptorHandleForHeapStart();

	commandList->OMSetRenderTargets(1, &rtvHandles[backBufferIndex], false, &dsvHandle);
#pragma endregion

#pragma region ç”»é¢å…¨ä½“ã®æ·±åº¦ã‚’ã‚¯ãƒªã‚¢
	// æŒ‡å®šã—ãŸæ·±åº¦ã§ç”»é¢å…¨ä½“ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹
	commandList->ClearDepthStencilView(dsvHandle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
#pragma endregion

#pragma region ç”»é¢å…¨ä½“ã®è‰²ã‚’ã‚¯ãƒªã‚¢
	// æŒ‡å®šã—ãŸè‰²ã§ç”»é¢å…¨ä½“ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹
	float clearColor[] = { 0.1f, 0.25f, 0.5f, 1.0f };  // é’ã£ã½ã„è‰²ã€‚RGBAã®é †
	commandList->ClearRenderTargetView(rtvHandles[backBufferIndex], clearColor, 0, nullptr);
#pragma endregion

#pragma region ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆé ˜åŸŸã®è¨­å®š
	commandList->RSSetViewports(1, &viewport);			// Viewportã‚’è¨­å®š
#pragma endregion

#pragma region ã‚·ã‚¶ãƒ¼çŸ©å½¢ã®è¨­å®š
	commandList->RSSetScissorRects(1, &scissorRect);	// Scissorã‚’è¨­å®š
#pragma endregion
}

void DirectXCommon::PostDraw()
{
	backBufferIndex = swapChain->GetCurrentBackBufferIndex();
#pragma region ãƒªã‚½ãƒ¼ã‚¹ãƒãƒªã‚¢ã§è¡¨ç¤ºå½¢æ…‹ã«å¤‰æ›´
	// ç”»é¢ã«æãå‡¦ç†ã¯ã™ã¹ã¦çµ‚ã‚ã‚Šã€ç”»é¢ã«æ˜ ã™ã®ã§ã€çŠ¶æ…‹ã‚’é·ç§»
		// ä»Šå›ã¯ RenderTarget ã‹ã‚‰ Present ã«ã™ã‚‹
	barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
	barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
	// TransitionBarrier ã‚’ã¯å¼µã‚‹
	commandList->ResourceBarrier(1, &barrier);
#pragma endregion
#pragma region ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚³ãƒãƒ³ãƒ‰ã‚’ã‚¯ãƒ­ãƒ¼ã‚º
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å†…å®¹ã‚’ç¢ºå®šã•ã›ã‚‹ã€‚ã™ã¹ã¦ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚“ã§ã‹ã‚‰ Close ã™ã‚‹ã“ã¨
	HRESULT hr = commandList->Close();
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region GPUã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œ
	//GPUã«ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å®Ÿè¡Œã‚’è¡Œã‚ã›ã‚‹
	ID3D12CommandList* commandLists[] = { commandList.Get() };
	commandQueue->ExecuteCommandLists(1, commandLists);
#pragma endregion
#pragma region GPUç”»é¢ã®äº¤æ›ã‚’é€šçŸ¥
	//GPUã¨OSã«ç”»é¢ã®äº¤æ¸‰ã‚’è¡Œã†ã‚ˆã†ã«é€šçŸ¥ã™ã‚‹
	swapChain->Present(1, 0);
#pragma endregion
#pragma region Fenceã®å€¤ã‚’æ›´æ–°
	//Fenceã®å€¤ã‚’æ›´æ–°
	fenceValue++;
	//GPUãŒã“ã“ã¾ã§ãŸã©ã‚Šç€ã„ãŸæ™‚ã«ã€Fenceã®å€¤ã‚’æŒ‡å®šã—ãŸå€¤ã«ä»£å…¥ã™ã‚‹ã‚ˆã†ã«Signalã‚’é€ã‚‹
	commandQueue->Signal(fence.Get(), fenceValue);
#pragma endregion
#pragma region ã‚³ãƒãƒ³ãƒ‰å®Œäº†å¾…ã¡
	// Fenceã®å€¤ãŒæŒ‡å®šã—ãŸSignalå€¤ã«ãŸã©ã‚Šç€ã„ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹
		//GetCompletedValueã®åˆæœŸå€¤ã¯Fenceä½œæˆæ™‚ã«æ¸¡ã—ãŸåˆæœŸå€¤
	if (fence->GetCompletedValue() < fenceValue) {
		//æŒ‡å®šã—ãŸSignalã«ãŸã©ã‚Šç€ã„ã¦ã„ãªã„ã®ã§ã€ãŸã©ã‚Šç€ãã¾ã§å¾…ã¤ã‚ˆã†ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®šã™ã‚‹
		fence->SetEventOnCompletion(fenceValue, fenceEvent);
		//ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¾…ã¤
		WaitForSingleObject(fenceEvent, INFINITE);
	}
#pragma endregion

	// FPSå›ºå®š
	UpdateFixFPS();

#pragma region ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã®ãƒªã‚»ãƒƒãƒˆ
	//æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ç”¨ã®ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’æº–å‚™
	hr = commandAllocator->Reset();
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒªã‚»ãƒƒãƒˆ
	hr = commandList->Reset(commandAllocator.Get(), nullptr);
	assert(SUCCEEDED(hr));
#pragma endregion



}

void DirectXCommon::WaitCommand()
{

#pragma region ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚³ãƒãƒ³ãƒ‰ã‚’ã‚¯ãƒ­ãƒ¼ã‚º
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å†…å®¹ã‚’ç¢ºå®šã•ã›ã‚‹ã€‚ã™ã¹ã¦ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚“ã§ã‹ã‚‰ Close ã™ã‚‹ã“ã¨
	HRESULT hr = commandList->Close();
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region GPUã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œ
	//GPUã«ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å®Ÿè¡Œã‚’è¡Œã‚ã›ã‚‹
	ID3D12CommandList* commandLists[] = { commandList.Get() };
	commandQueue->ExecuteCommandLists(1, commandLists);
#pragma endregion

#pragma region Fenceã®å€¤ã‚’æ›´æ–°
	//Fenceã®å€¤ã‚’æ›´æ–°
	fenceValue++;
	//GPUãŒã“ã“ã¾ã§ãŸã©ã‚Šç€ã„ãŸæ™‚ã«ã€Fenceã®å€¤ã‚’æŒ‡å®šã—ãŸå€¤ã«ä»£å…¥ã™ã‚‹ã‚ˆã†ã«Signalã‚’é€ã‚‹
	commandQueue->Signal(fence.Get(), fenceValue);
#pragma endregion
#pragma region ã‚³ãƒãƒ³ãƒ‰å®Œäº†å¾…ã¡
	// Fenceã®å€¤ãŒæŒ‡å®šã—ãŸSignalå€¤ã«ãŸã©ã‚Šç€ã„ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹
		//GetCompletedValueã®åˆæœŸå€¤ã¯Fenceä½œæˆæ™‚ã«æ¸¡ã—ãŸåˆæœŸå€¤
	if (fence->GetCompletedValue() < fenceValue) {
		//æŒ‡å®šã—ãŸSignalã«ãŸã©ã‚Šç€ã„ã¦ã„ãªã„ã®ã§ã€ãŸã©ã‚Šç€ãã¾ã§å¾…ã¤ã‚ˆã†ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®šã™ã‚‹
		fence->SetEventOnCompletion(fenceValue, fenceEvent);
		//ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¾…ã¤
		WaitForSingleObject(fenceEvent, INFINITE);
	}
#pragma endregion
#pragma region ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã®ãƒªã‚»ãƒƒãƒˆ
	//æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ç”¨ã®ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’æº–å‚™
	hr = commandAllocator->Reset();
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒªã‚»ãƒƒãƒˆ
	hr = commandList->Reset(commandAllocator.Get(), nullptr);
	assert(SUCCEEDED(hr));
#pragma endregion



}

//D3D12_CPU_DESCRIPTOR_HANDLE DirectXCommon::GetSRVCPUDescriptorHandle(uint32_t index)
//{
//	return GetCPUDescriptorHandle(srvDescriptorHeap, descriptorSizeSRV, index);
//}

//D3D12_GPU_DESCRIPTOR_HANDLE DirectXCommon::GetSRVGPUDescriptorHandle(uint32_t index)
//{
//	return GetGPUDescriptorHandle(srvDescriptorHeap, descriptorSizeSRV, index);
//}

void DirectXCommon::InitDepthStencilView()
{

	D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc{};
	dsvDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;//Format.åŸºæœ¬çš„ã«ã¯Resourceã«åˆã‚ã›ã‚‹
	dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;//2dTexture

	Microsoft::WRL::ComPtr <ID3D12Resource> depthStencilResource;
	depthStencilResource = CreateDepthBuffer(device, WinAPI::kClientWidth, WinAPI::kClientHeight);
	//DSVã®è¨­å®š									 

	//DSVHeapã®å…ˆé ­ã«DSVã‚’ã¤ãã‚‹
	device->CreateDepthStencilView(depthStencilResource.Get(), &dsvDesc, dsvDescriptorHeap->GetCPUDescriptorHandleForHeapStart());

}

void DirectXCommon::InitFence()
{
	HRESULT hr = device->CreateFence(fenceValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(fence.GetAddressOf()));
	assert(SUCCEEDED(hr));


	assert(fenceEvent != nullptr);
}

void DirectXCommon::InitViewportRect()
{
	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆçŸ©å½¢ã®è¨­å®š
	viewport.Width = WinAPI::kClientWidth;
	viewport.Height = WinAPI::kClientHeight;
	viewport.TopLeftX = 0.0f;
	viewport.TopLeftY = 0.0f;
	viewport.MinDepth = 0.0f;
	viewport.MaxDepth = 1.0f;
}

void DirectXCommon::InitScissorRect()
{

	scissorRect.left = 0;
	scissorRect.right = WinAPI::kClientWidth;
	scissorRect.top = 0;
	scissorRect.bottom = WinAPI::kClientHeight;
}

void DirectXCommon::CreateDXCCompiler()
{

	// DXCãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã®ç”Ÿæˆ
	HRESULT hr = DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(dxcUtils.GetAddressOf()));
	assert(SUCCEEDED(hr));
	// DXCã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ç”Ÿæˆ
	hr = DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(dxcCompiler.GetAddressOf()));
	assert(SUCCEEDED(hr));

	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ãƒ©ã®ç”Ÿæˆ
	// ç¾æ™‚ç‚¹ã§includeã¯ã—ãªã„ãŒã€includeã«å¯¾å¿œã™ã‚‹ãŸã‚ã®è¨­å®šã‚’è¡Œã£ã¦ãŠã
	hr = dxcUtils->CreateDefaultIncludeHandler(includeHandler.GetAddressOf());
	assert(SUCCEEDED(hr));

}

void DirectXCommon::InitImGui()
{
	////Imguiã®åˆæœŸåŒ–
	//IMGUI_CHECKVERSION();
	//ImGui::CreateContext();
	//ImGui::StyleColorsDark();
	//ImGui_ImplWin32_Init(winAPI_->GetHwnd());
	//ImGui_ImplDX12_Init(device.Get(), swapChainDesc.BufferCount, rtvDesc.Format, srvDescriptorHeap.Get(),
	//	srvDescriptorHeap->GetCPUDescriptorHandleForHeapStart(), srvDescriptorHeap->GetGPUDescriptorHandleForHeapStart());


}


Microsoft::WRL::ComPtr<IDxcBlob> DirectXCommon::CompileShader(
	const std::wstring& filePath, const wchar_t* profile)
{
	// ã“ã‚Œã‹ã‚‰ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹æ—¨ã‚’ãƒ­ã‚°ã«å‡ºã™
	Log(ConvertString(std::format(L"Begin CompileShader, profile:{}\n", filePath, profile)));

	// hlslãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
	Microsoft::WRL::ComPtr<IDxcBlobEncoding> shaderSource = nullptr;
	HRESULT hr = dxcUtils->LoadFile(filePath.c_str(), nullptr, &shaderSource);
	// èª­ã‚ãªã‹ã£ãŸã‚‰æ­¢ã‚ã‚‹
	assert(SUCCEEDED(hr));

	// èª­ã¿è¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’è¨­å®šã™ã‚‹
	DxcBuffer shaderSourceBuffer;
	shaderSourceBuffer.Ptr = shaderSource->GetBufferPointer();
	shaderSourceBuffer.Size = shaderSource->GetBufferSize();
	shaderSourceBuffer.Encoding = DXC_CP_UTF8; // UTFã®æ–‡å­—ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’é€šçŸ¥

	LPCWSTR arguments[] = {
		filePath.c_str(), // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¯¾è±¡ã®hlslãƒ•ã‚¡ã‚¤ãƒ«å
		L"-E", L"main", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã®æŒ‡å®šã€‚åŸºæœ¬çš„ã«mainä»¥å¤–ã«ã¯ã—ãªã„
		L"-T", profile, // Shader Profileã®è¨­å®š
		L"-Zi", L"-Qembed_debug", // ãƒ‡ãƒãƒƒã‚°ç”¨ã®æƒ…å ±ã‚’åŸ‹ã‚è¾¼ã‚€
		L"-Od", // æœ€é©åŒ–ã‚’å¤–ã—ã¦ãŠã
		L"-Zpr", // ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯è¡Œå„ªå…ˆ
	};

	// å®Ÿéš›ã«Shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	Microsoft::WRL::ComPtr<IDxcResult> shaderResult = nullptr;
	hr = dxcCompiler->Compile(
		&shaderSourceBuffer, // èª­ã¿è¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«
		arguments, // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³
		_countof(arguments), // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•°
		includeHandler.Get(), // includeãŒå«ã¾ã‚ŒãŸè«¸ã€…
		IID_PPV_ARGS(&shaderResult) // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœ
	);
	// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã§ã¯ãªãdxcãŒèµ·å‹•ã§ããªã„ãªã©è‡´å‘½çš„ãªçŠ¶æ³
	assert(SUCCEEDED(hr));

	Microsoft::WRL::ComPtr<IDxcBlobUtf8> shaderError = nullptr;
	shaderResult->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&shaderError), nullptr);
	if (shaderError != nullptr && shaderError->GetStringLength() != 0) {
		Log(shaderError->GetStringPointer());
		assert(false);
	}

	Microsoft::WRL::ComPtr<IDxcBlob> shaderBlob = nullptr;
	hr = shaderResult->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&shaderBlob), nullptr);
	assert(SUCCEEDED(hr));

	return shaderBlob;
}




std::wstring DirectXCommon::ConvertString(const std::string& str)
{
	if (str.empty()) {
		return std::wstring();
	}

	auto sizeNeeded = MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), NULL, 0);
	if (sizeNeeded == 0) {
		return std::wstring();
	}
	std::wstring result(sizeNeeded, 0);
	MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), &result[0], sizeNeeded);
	return result;
}

std::string DirectXCommon::ConvertString(const std::wstring& str)
{
	if (str.empty()) {
		return std::string();
	}

	auto sizeNeeded = WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), NULL, 0, NULL, NULL);
	if (sizeNeeded == 0) {
		return std::string();
	}
	std::string result(sizeNeeded, 0);
	WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), result.data(), sizeNeeded, NULL, NULL);
	return result;
}

Microsoft::WRL::ComPtr<ID3D12Resource>
DirectXCommon::CreateBufferResource(size_t sizeInBytes)
{
	//é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ç”¨ã®ãƒ’ãƒ¼ãƒ—è¨­å®š
	D3D12_HEAP_PROPERTIES uploadHeapProperties{};
	uploadHeapProperties.Type = D3D12_HEAP_TYPE_UPLOAD;//
	//ã€€ãƒªã‚½ãƒ¼ã‚¹ã®è¨­å®š
	D3D12_RESOURCE_DESC vertexResourceDesc{};
	// ãƒªã‚½ãƒ¼ã‚¹ã®æ¬¡å…ƒã‚’ãƒãƒƒãƒ•ã‚¡ã«è¨­å®š
	vertexResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	// ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã®æŒ‡å®š
	vertexResourceDesc.Width = sizeInBytes;

	vertexResourceDesc.Height = 1;				// ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºã¯å¸¸ã«ï¼‘
	vertexResourceDesc.DepthOrArraySize = 1;	// æ·±ã•ã¾ãŸã¯é…åˆ—ã‚µã‚¤ã‚ºã®ï¼‘
	vertexResourceDesc.MipLevels = 1;			// ãƒŸãƒƒãƒ—ãƒ¬ãƒ™ãƒ«
	vertexResourceDesc.SampleDesc.Count = 1;	// ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°æ•°

	vertexResourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
	//ã€€ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexResource = nullptr;
	HRESULT hr = device->CreateCommittedResource(&uploadHeapProperties, D3D12_HEAP_FLAG_NONE,
		&vertexResourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr, IID_PPV_ARGS(&vertexResource));
	assert(SUCCEEDED(hr));
	return vertexResource;
}

Microsoft::WRL::ComPtr<ID3D12Resource> DirectXCommon::CreateTextureResource(const DirectX::TexMetadata& metadata)
{
	// 1. metadataã‚’åŸºã«Resourceã®è¨­å®š
	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Width = static_cast<UINT>(metadata.width); // Textureã®å¹…
	resourceDesc.Height = static_cast<UINT>(metadata.height); // Textureã®é«˜ã•
	resourceDesc.MipLevels = static_cast<UINT16>(metadata.mipLevels); // mipmapã®æ•°
	resourceDesc.DepthOrArraySize = static_cast<UINT16>(metadata.arraySize); // å¥¥è¡Œoré…åˆ—Textureã®é…åˆ—æ•°
	resourceDesc.Format = metadata.format; // Textureã®Format
	resourceDesc.SampleDesc.Count = 1; // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚«ã‚¦ãƒ³ãƒˆ1å›ºå®š
	resourceDesc.Dimension = static_cast<D3D12_RESOURCE_DIMENSION>(metadata.dimension); // Textureã®æ¬¡å…ƒæ•°ã€‚æ™®æ®µä½¿ã£ã¦ã„ã‚‹ã®ã¯2æ¬¡å…ƒ

	// 2. åˆ©ç”¨ã™ã‚‹Heapã®è¨­å®š
	D3D12_HEAP_PROPERTIES heapProperties{};
	heapProperties.Type = D3D12_HEAP_TYPE_DEFAULT; // ç´°ã‹ã„è¨­å®šã‚’è¡Œã†

	// 3. Resourceã‚’ç”Ÿæˆã™ã‚‹
	Microsoft::WRL::ComPtr<ID3D12Resource> resource = nullptr;
	HRESULT hr = device->CreateCommittedResource(
		&heapProperties,				// Heapã®è¨­å®š
		D3D12_HEAP_FLAG_NONE,			// Heapã®ç‰¹æ®Šãªè¨­å®š,ç‰¹ã«ãªã—
		&resourceDesc,					// Resourceã®è¨­å®š
		D3D12_RESOURCE_STATE_COPY_DEST, // ãƒ‡ãƒ¼ã‚¿è»¢é€ã•ã‚Œã‚‹è¨­å®š
		nullptr,						// Clearæœ€é©å€¤ ä½¿ã‚ãªã„ã®ã§nullptr
		IID_PPV_ARGS(&resource)			// ä½œæˆã™ã‚‹Resourceãƒã‚¤ãƒ³ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	);

	assert(SUCCEEDED(hr));
	return resource;
}

Microsoft::WRL::ComPtr<ID3D12Resource> DirectXCommon::UploadTextureData(Microsoft::WRL::ComPtr<ID3D12Resource> texture, const DirectX::ScratchImage& mipImages)
{
	std::vector<D3D12_SUBRESOURCE_DATA> subresources;
	DirectX::PrepareUpload(device.Get(), mipImages.GetImages(), mipImages.GetImageCount(), mipImages.GetMetadata(), subresources);
	uint64_t intermediateSize = GetRequiredIntermediateSize(texture.Get(), 0, static_cast<UINT>(subresources.size()));
	Microsoft::WRL::ComPtr<ID3D12Resource> intermediateResource = CreateBufferResource(intermediateSize);
	UpdateSubresources(commandList.Get(), texture.Get(), intermediateResource.Get(), 0, 0, static_cast<UINT>(subresources.size()), subresources.data());

	// Textureã¸ã®è»¢é€å¾Œã¯åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã€D3D12_RESOURCE_STATE_COPY_DESTã‹ã‚‰D3D12_RESOURCE_STATE_GENERIC_READã¸ResourceStateã‚’å¤‰æ›´ã™ã‚‹
	D3D12_RESOURCE_BARRIER barrier{};
	barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	barrier.Transition.pResource = texture.Get();
	barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
	barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
	barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_GENERIC_READ;
	commandList->ResourceBarrier(1, &barrier);

	return intermediateResource;
}

void DirectXCommon::InitializeFixFPS()
{
	// ç¾åœ°æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹
	reference_ = std::chrono::steady_clock::now();
}

void DirectXCommon::UpdateFixFPS()
{
	// 1/60ç§’ã´ã£ãŸã‚Šã®æ™‚é–“
	const std::chrono::microseconds kMinTime(uint64_t(1000000.0f / 60.0f));
	// 1/60ç§’ã‚ˆã‚Šã‚ãšã‹ã«çŸ­ã„æ™‚é–“
	const std::chrono::microseconds kMinCheckTime(uint64_t(1000000.0f / 65.0f));

	// ç¾åœ°æ™‚é–“ã‚’å–å¾—ã™ã‚‹
	std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();
	// å‰å›è¨˜éŒ²ã‹ã‚‰ã®çµŒéæ™‚é–“ã‚’å–å¾—ã™ã‚‹
	std::chrono::microseconds elapsed =
		std::chrono::duration_cast<std::chrono::microseconds>(now - reference_);

	// 1/60ç§’ (ã‚ˆã‚Šã‚ãšã‹ã«çŸ­ã„æ™‚é–“)ç›¾å±…ãªã„å ´åˆ
	if (elapsed < kMinCheckTime) {
		// 1/60ç§’çµŒéã™ã‚‹ã¾ã§å¾®å°ãªã‚¹ãƒªãƒ¼ãƒ—ã‚’ç¹°ã‚Šè¿”ã™
		while (std::chrono::steady_clock::now() - reference_ < kMinTime) {
			// 1ãƒã‚¤ã‚¯ãƒ­ç§’ãƒªã‚½ãƒ¼ã‚¹
			std::this_thread::sleep_for(std::chrono::microseconds(1));
		}
	}
	// ç¾åœ¨ã®æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹
	reference_ = std::chrono::steady_clock::now();

}



============================================================
File Path: engine/base/DirectXCommon.h
============================================================
#pragma once
#include <d3d12.h>
#include <dxgi1_6.h>
#include <wrl.h>
#include <array>
#include <dxcapi.h>
#include <chrono>
#include "WinAPI.h"
#include <cstdlib>
#include"externals/DirectXTex/DirectXTex.h"
#include"externals/DirectXTex/d3dx12.h"


/// <summary>
/// DirectXåŸºç›¤ã‚¯ãƒ©ã‚¹
/// </summary>
/// <remarks>
/// DirectX12ã®åˆæœŸåŒ–ã€æç”»å‰å¾Œå‡¦ç†ã‚’è¡Œã†
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹
/// </remarks>

// nameSpace
namespace Engine {

	// DirectXåŸºç›¤
	class DirectXCommon
	{
	public:


		/// <summary>
		/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
		/// <summary>
		DirectXCommon();
		/// <summary>
		///åˆæœŸåŒ–
		/// <summary>
		void Initialize(WinAPI* winAPI);
		/// <summary>
		/// æç”»å‰å‡¦ç†
		/// </summary>
		void PreDraw();

		/// <summary>
		/// æç”»å¾Œå‡¦ç†
		/// </summary>
		void PostDraw();

		/// <summary>
		/// ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œ
		/// </summary>
		void WaitCommand();

		/// <summary>
		/// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«é–¢æ•°
		/// </summary>
		/// <param name="filePath">èª­ã¿è¾¼ã‚€ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®åå‰</param>
		Microsoft::WRL::ComPtr<IDxcBlob> CompileShader(
			const std::wstring& filePath,
			const wchar_t* profile);

		/// <summary>
		/// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
		/// </summary>
		Microsoft::WRL::ComPtr<ID3D12Resource>
			CreateBufferResource(size_t sizeInBytes);

		/// <summary>
		/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
		/// </summary>
		Microsoft::WRL::ComPtr<ID3D12Resource>CreateTextureResource(const DirectX::TexMetadata& metadata);

		/// <summary>
		/// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ä½œæˆé–¢æ•°
		/// </summary>
		Microsoft::WRL::ComPtr <ID3D12DescriptorHeap>  CreateDescriptorHeap(
			D3D12_DESCRIPTOR_HEAP_TYPE heapType,
			UINT numDescriptors,
			bool shaderVisible);
	public:		// Getter,Setter
		/// <summary>
		/// ãƒ‡ãƒã‚¤ã‚¹å–å¾—é–¢æ•°
		/// </summary>
		ID3D12Device* GetDevice() const { return device.Get(); }
		ID3D12GraphicsCommandList* GetCommandList()const { return commandList.Get(); }
		/// <summary>
		/// DxcUtilså–å¾—é–¢æ•°
		/// </summary>
		Microsoft::WRL::ComPtr <IDxcUtils>
			GetDxcUtils()const { return dxcUtils; }

		/// <summary>
		/// DxcCompilerå–å¾—é–¢æ•°
		/// </summary>
		Microsoft::WRL::ComPtr<IDxcCompiler3>
			GetDxcCompiler()const { return dxcCompiler; }

		/// <summary>
		/// ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ãƒ©å–å¾—é–¢æ•°
		/// </summary>
		Microsoft::WRL::ComPtr<IDxcIncludeHandler>
			GetIncludeHandler()const { return includeHandler; }

		/// <summary>
		/// srvDescriptorHeapå–å¾—é–¢æ•°
		/// </summary>
		/*Microsoft::WRL::ComPtr <ID3D12DescriptorHeap>
			GetSrvDescriptorHeap()const { return srvDescriptorHeap; }*/

			/// <summary>
			/// æŒ‡å®šç•ªå·ã®CPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
			/// </summary>
		static D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(const Microsoft::WRL::ComPtr<ID3D12DescriptorHeap>& descriptorHeap, uint32_t descriptorSize, uint32_t index);
		/// <summary>
		/// æŒ‡å®šç•ªå·ã®GPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
		/// </summary>
		static D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(const Microsoft::WRL::ComPtr<ID3D12DescriptorHeap>& descriptorHeap, uint32_t descriptorSize, uint32_t index);

		/// <summary>
		/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®è»¢é€
		/// [[no discard]]ã¨ã¯ã€æˆ»ã‚Šå€¤ãŒç„¡è¦–ã•ã‚Œã‚‹ã¨è­¦å‘Šã‚’å‡ºã™
		/// </summary>
		[[nodiscard]]
		Microsoft::WRL::ComPtr<ID3D12Resource> UploadTextureData
		(Microsoft::WRL::ComPtr<ID3D12Resource> texture, const DirectX::ScratchImage& mipImages);

		/// <summary>
		/// SRVã®æŒ‡å®šç•ªå·ã®CPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
		/// </summary>
		//D3D12_CPU_DESCRIPTOR_HANDLE GetSRVCPUDescriptorHandle(uint32_t index);

		/// <summary>
		/// SRVã®æŒ‡å®šç•ªå·ã®GPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
		/// </summary>
		//D3D12_GPU_DESCRIPTOR_HANDLE GetSRVGPUDescriptorHandle(uint32_t index);

		/// <summary>
		/// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®æ•°ã‚’å–å¾—
		/// </summary>
		size_t GetBackBufferCount() const { return backBufferIndex; }

		/// <summary>
		/// RTVã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚ºã‚’å–å¾—
		/// </summary>
		uint32_t GetDescriptorSizeRTV() const { return descriptorSizeRTV; }

		/// <summary>
		/// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
		/// </summary>
		D3D12_CPU_DESCRIPTOR_HANDLE GetDSVHandle()const { return dsvDescriptorHeap->GetCPUDescriptorHandleForHeapStart(); }

	private:	// å†…éƒ¨å‡¦ç†å°‚ç”¨é–¢æ•°
		/// <summary>
		/// ã‚³ãƒãƒ³ãƒ‰é–¢é€£ã®åˆæœŸåŒ–
		/// </summary>
		void InitCommand();

		/// <summary>
		/// ãƒ‡ãƒã‚¤ã‚¹ã®åˆæœŸåŒ–
		/// </summary>
		void InitDevice();

		/// <summary>
		/// SwapChainã®ç”Ÿæˆ
		/// </summary>
		void CreateSwapChain();

		/// <summary>
		/// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
		/// </summary>
		Microsoft::WRL::ComPtr<ID3D12Resource> CreateDepthBuffer(Microsoft::WRL::ComPtr<ID3D12Device> device, int32_t width, int32_t height);

		/// <summary>
		/// å„ç¨®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
		/// </summary>
		void CreateDescriptorHeaps();

		/// <summary>
		/// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
		/// </summary>
		void InitRenderTargetView();

		/// <summary>
		/// æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
		/// </summary>
		void InitDepthStencilView();

		/// <summary>
		/// ãƒ•ã‚§ãƒ³ã‚¹ã®ç”Ÿæˆ
		/// </summary>
		void InitFence();

		/// <summary>
		/// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆçŸ©å½¢ã®åˆæœŸåŒ–
		/// </summary>
		void InitViewportRect();

		/// <summary>
		/// ã‚·ã‚¶ãƒªãƒ³ã‚°çŸ©å½¢ã®åˆæœŸåŒ–
		/// </summary>
		void InitScissorRect();

		/// <summary>
		/// DXCã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ç”Ÿæˆ
		/// </summary>
		void CreateDXCCompiler();

		/// <summary>
		/// ImGuiã®åˆæœŸåŒ–
		/// </summary>
		void InitImGui();

		/// <summary>
		/// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«é–¢æ•°
		/// </summary>
		static std::wstring ConvertString(const std::string& str);
		static std::string ConvertString(const std::wstring& str);

		/// <summary>
		/// FPSå›ºå®šåˆæœŸåŒ–
		/// </summary>
		void InitializeFixFPS();

		/// <summary>
		/// FPSå›ºå®šæ›´æ–°
		/// </summary>
		void UpdateFixFPS();


	private:
		// WindowsAPI
		WinAPI* winAPI_ = nullptr;

	private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
		// DirectX12ãƒ‡ãƒã‚¤ã‚¹
		Microsoft::WRL::ComPtr<ID3D12Device> device;
		// DXGIãƒ•ã‚¡ã‚¯ãƒˆãƒª
		Microsoft::WRL::ComPtr<IDXGIFactory7> dxgiFactory;
		// ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼
		Microsoft::WRL::ComPtr <ID3D12CommandAllocator> commandAllocator;
		// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
		Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> commandList;
		// ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼
		Microsoft::WRL::ComPtr <ID3D12CommandQueue> commandQueue;
		// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³ã®ç”Ÿæˆ
		DXGI_SWAP_CHAIN_DESC1 swapChainDesc{};
		// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³
		Microsoft::WRL::ComPtr<IDXGISwapChain4> swapChain;
		// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³ãƒªã‚½ãƒ¼ã‚¹
		std::array<Microsoft::WRL::ComPtr<ID3D12Resource>, 2> swapChainResources;
		// ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
		Microsoft::WRL::ComPtr <ID3D12Resource> resource;
		// RTVã®è¨­å®š
		D3D12_RENDER_TARGET_VIEW_DESC rtvDesc{};
		// å„ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ã®ãƒ¡ãƒ³ãƒå¤‰æ•°
		Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> rtvDescriptorHeap;
		Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> dsvDescriptorHeap;
		// RTVãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º
		uint32_t descriptorSizeRTV;

		// ç”Ÿæˆã®æˆæœç‰©ã€ãƒ•ã‚§ãƒ³ã‚¹
		Microsoft::WRL::ComPtr<ID3D12Fence> fence = nullptr;
		//ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆçŸ©å½¢ã®è¨­å®šä¿å­˜ç”¨ãƒ¡ãƒ³ãƒå¤‰æ•°
		D3D12_VIEWPORT viewport{};
		// dxcCompilerã‚’åˆæœŸåŒ–
		Microsoft::WRL::ComPtr<IDxcUtils> dxcUtils = nullptr;
		Microsoft::WRL::ComPtr<IDxcCompiler3> dxcCompiler = nullptr;
		// ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ãƒ©
		Microsoft::WRL::ComPtr<IDxcIncludeHandler> includeHandler = nullptr;
		// TransitionBarrier ã®è¨­å®š
		D3D12_RESOURCE_BARRIER barrier{};
		// RTVã‚’2ã¤ä½œã‚‹ã®ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’2ã¤ç”¨æ„
		std::array<D3D12_CPU_DESCRIPTOR_HANDLE, 2> rtvHandles;
		// Fenceã®Signalã‚’å¾…ã¤ãŸã‚ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã™ã‚‹
		HANDLE fenceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
		// ã‚·ã‚¶ãƒªãƒ³ã‚°çŸ©å½¢ã®è¨­å®š
		D3D12_RECT scissorRect{};
		// åˆæœŸå€¤0ã§Fenceã‚’ä½œæˆ
		uint64_t fenceValue = 0;
		// ã“ã“ã‹ã‚‰æ›¸ãè¾¼ã‚€ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
		UINT backBufferIndex = 2;
		// æ·±åº¦ãƒªã‚½ãƒ¼ã‚¹
		Microsoft::WRL::ComPtr <ID3D12Resource> depthStencilResource;
		// è¨˜éŒ²æ™‚é–“(FPSå›ºå®šç”¨)
		std::chrono::steady_clock::time_point reference_;


	};

}// namespace Engine

============================================================
File Path: engine/base/ImGuiManager.cpp
============================================================
#include "ImGuiManager.h"
#include "externals/imgui/imgui_impl_win32.h"
#include "externals/imgui/imgui_impl_dx12.h"

using namespace Engine;

#ifdef USE_IMGUI
void ImGuiManager::Initialize(WinAPI* winAPI, DirectXCommon* dxCommon)
{
	// å¼•æ•°ã®nullptrãƒã‚§ãƒƒã‚¯
	assert(dxCommon);
	dxCommon_ = dxCommon;
	// ImGuiã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆ
	ImGui::CreateContext();
	// ImGuiã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®š
	ImGui::StyleColorsDark();
	// ImGuiã®Win32ã®åˆæœŸåŒ–
	ImGui_ImplWin32_Init(winAPI->GetHwnd());

	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—è¨­å®š
	D3D12_DESCRIPTOR_HEAP_DESC desc = {};
	desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	desc.NumDescriptors = 1;
	desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’ç”Ÿæˆ
	HRESULT result = dxCommon->GetDevice()->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&srvHeap_));
	assert(SUCCEEDED(result));

	// DirectX12ç”¨åˆæœŸåŒ–
	ImGui_ImplDX12_Init(
		// ãƒ‡ãƒã‚¤ã‚¹
		dxCommon->GetDevice(),
		// ãƒãƒƒãƒ•ã‚¡æ•° / å‹ãŒåˆã†ã‚ˆã†ã«ã‚­ãƒ£ã‚¹ãƒˆ
		static_cast<int>(dxCommon->GetBackBufferCount()),
		// RTVã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ / RTVã®è¨­å®šã¨ä¸€è‡´ã•ã›ã‚‹ / SRVãƒ’ãƒ¼ãƒ—
		DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, srvHeap_.Get(),
		// ImGuiã«å‰²ã‚Šå½“ã¦ã‚‹SRVã®ãƒ’ãƒ¼ãƒ—ãƒãƒ³ãƒ‰ãƒ« / SRVã®ç”Ÿæˆã¯ImGuiå´ãŒã‚„ã£ã¦ãã‚Œã‚‹
		srvHeap_->GetCPUDescriptorHandleForHeapStart(),
		// ImGuiã«å‰²ã‚Šå½“ã¦ã‚‹SRVã®ãƒ’ãƒ¼ãƒ—ãƒãƒ³ãƒ‰ãƒ« / GPUå´ã®ãƒ’ãƒ¼ãƒ—ãƒãƒ³ãƒ‰ãƒ«
		srvHeap_->GetGPUDescriptorHandleForHeapStart()
	);
	//ImGuiIO& io = ImGui::GetIO();
	//io.ConfigFlags |= ImGuiConfigFlags_DockingEnable; // ãƒ‰ãƒƒã‚­ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«ã™ã‚‹
}

void ImGuiManager::Finalize()
{
	// ImGuiã®çµ‚äº†å‡¦ç†
	ImGui_ImplDX12_Shutdown();
	ImGui_ImplWin32_Shutdown();
	ImGui::DestroyContext();

	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’è§£æ”¾
	srvHeap_.Reset();
}

void ImGuiManager::Begin()
{
	// ImGuiã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é–‹å§‹
	ImGui_ImplDX12_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();
}

void ImGuiManager::End()
{
	
	// ImGuiã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’çµ‚äº†
	ImGui::Render();
}

void ImGuiManager::Draw()
{
	ID3D12GraphicsCommandList* commandList = dxCommon_->GetCommandList();
	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®é…åˆ—ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã‚³ãƒãƒ³ãƒ‰
	ID3D12DescriptorHeap* ppHeaps[] = { srvHeap_.Get() };
	commandList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
	// ImGuiã®æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
	ImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), commandList);
}

#endif

============================================================
File Path: engine/base/ImGuiManager.h
============================================================
#pragma once
#include <d3d12.h>
#ifdef USE_IMGUI
#include "externals/imgui/imgui.h"
#endif
#include "engine/base/WinAPI.h" 
#include "engine/base/DirectXCommon.h"

/// <summary>
/// ImGuiç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
/// <remarks>
/// ImGuiã®åˆæœŸåŒ–ã€æç”»ã‚’è¡Œã†
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹
/// </remarks>

class ImGuiManager
{

public:
#ifdef USE_IMGUI
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize(WinAPI*winAPI, Engine::DirectXCommon*dxCommon);

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize(); 
	
	/// <summary>
	/// ImGuiå—ä»˜é–‹å§‹
	/// <summary>
	void Begin();

	/// <summary>
	/// ImGuiå—ä»˜çµ‚äº†
	/// <summary>
	void End();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();
#endif
private:
	Engine::DirectXCommon* dxCommon_ = nullptr;
	
	Microsoft::WRL::ComPtr<ID3D12Device> device = nullptr;
	
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> srvHeap_ = nullptr;


};


============================================================
File Path: engine/base/Input.cpp
============================================================
#include "Input.h"
#include <cassert>
#pragma comment(lib,"dinput8.lib")
#pragma comment(lib,"dxguid.lib")

Input* Input::instance = nullptr;
Input* Input::GetInstance()
{
	if (instance == nullptr)
	{
		instance = new Input();
	}
	return instance;
}

void Input::DeleteInstance()
{
	if (instance != nullptr)
	{
		delete instance;
		instance = nullptr;
	}
}

void Input::Initialize(WinAPI *winAPI)
{
	//å€Ÿã‚Šã¦ããŸWinAPIã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¨˜éŒ²
	this->winAPI = winAPI;
	//DirectInputã®åˆæœŸåŒ–
	HRESULT result = DirectInput8Create(
		winAPI->GetHInstance(), DIRECTINPUT_VERSION, IID_IDirectInput8,
		(void**)&directInput, nullptr);
	assert(SUCCEEDED(result));
	//ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‡ãƒã‚¤ã‚¹ã®ä½œæˆ
	result = directInput->CreateDevice(GUID_SysKeyboard, &keyboard, NULL);
	assert(SUCCEEDED(result));

	//å…¥åŠ›ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetDataFormat(&c_dfDIKeyboard);
	assert(SUCCEEDED(result));

	//æ’ä»–åˆ¶å¾¡ã®ãƒ¬ãƒ™ãƒ«ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetCooperativeLevel(winAPI->GetHwnd(), DISCL_FOREGROUND | DISCL_NONEXCLUSIVE | DISCL_NOWINKEY);
	assert(SUCCEEDED(result));
}

void Input::Update()
{
	HRESULT result;
	//å‰å›ã®ã‚­ãƒ¼å…¥åŠ›ã‚’ä¿å­˜
	memcpy(keyPre, key, sizeof(key));
	if (TriggerKey(DIK_1)) {
		OutputDebugStringA("Hit_1\n");
	}
	////å…¨ã‚­ãƒ¼ã®å…¥åŠ›çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹
	result = keyboard->Acquire();
	result = keyboard->GetDeviceState(sizeof(key), key);

}
bool Input::RereseKey(BYTE keyNumber)
{
	// å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã§æŠ¼ã•ã‚Œã¦ã„ã¦ã€ä»Šãƒ•ãƒ¬ãƒ¼ãƒ ã§æŠ¼ã•ã‚Œã¦ã„ãªã„å ´åˆ
	return (keyPre[keyNumber] != 0) && (key[keyNumber] == 0);
	return false;
}
bool Input::PushKey(BYTE keyNumber)
{
	//æŒ‡å®šã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ã„ã‚Œã°trueã‚’è¿”ã™
	 // ä»Šãƒ•ãƒ¬ãƒ¼ãƒ ã§ã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹å ´åˆ
	return key[keyNumber] != 0;
}
bool Input::TriggerKey(BYTE keyNumber)
{
	// å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã§æŠ¼ã•ã‚Œã¦ãŠã‚‰ãšã€ä»Šãƒ•ãƒ¬ãƒ¼ãƒ ã§æŠ¼ã•ã‚Œã¦ã„ã‚‹å ´åˆ
	return (keyPre[keyNumber] == 0) && (key[keyNumber] != 0);
}


============================================================
File Path: engine/base/Input.h
============================================================
#pragma once
#define DIRECTINPUT_VERSION		0x0800	//DirectInputã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®š
#include <dinput.h>
#include <stdint.h>
#include <Windows.h>
#include <wrl.h>
#include "WinAPI.h"

/// <summary>
/// å…¥åŠ›ã‚¯ãƒ©ã‚¹
/// </summary>
/// <remarks>
/// DirectInputã‚’ä½¿ç”¨ã—ã¦ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ã‚’ç®¡ç†ã™ã‚‹
/// </remarks>
class Input
{
public:
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	static Input* GetInstance();
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è§£æ”¾
	/// </summary>
	static void DeleteInstance();
private:
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	static Input* instance;
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	Input() = default;
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~Input() = default;
	// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ä»£å…¥æ¼”ç®—å­å‰Šé™¤
	Input(Input&) = delete;
	Input& operator=(Input&) = delete;

public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="winAPI"></param>
	void Initialize(WinAPI*winAPI);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	///ç‰¹å®šã®ã‚­ãƒ¼ãŒè©±ã•ã‚ŒãŸç¬é–“ã‚’åˆ¤å®š
	/// </summary>
	/// <param name="keyNumber"></param>
	bool RereseKey(BYTE keyNumber);

	/// <summary>
	///ã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
	/// </summary>
	/// <param name="keyNumber"></param>
	bool PushKey(BYTE keyNumber);
	/// <summary>
	/// ã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸç¬é–“ã‚’åˆ¤å®š
	/// </summary>
	/// <param name="keyNumber"></param>
	/// <returns></returns>
	bool TriggerKey(BYTE keyNumber);
	template <class T>using ComPtr = Microsoft::WRL::ComPtr<T>;
private:

	ComPtr<IDirectInputDevice8> keyboard;
	ComPtr<IDirectInput8>directInput = nullptr;
	BYTE key[256] = {};
	BYTE keyPre[256] = {};

	//WindowsAPI
	WinAPI* winAPI = nullptr;

	
};



============================================================
File Path: engine/base/Logger.cpp
============================================================
#include "Logger.h"
#include <debugapi.h>
namespace Logger {
	void Logger::Log(const std::string& message) {
		OutputDebugStringA(message.c_str());
	}
}


============================================================
File Path: engine/base/Logger.h
============================================================
#pragma once
#include <string>
#include <Windows.h>
/// <summary>
/// stringãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
/// </summary>
//ãƒ­ã‚°å‡ºåŠ›
namespace Logger {
	/// <summary>
	/// ãƒ­ã‚°å‡ºåŠ›
	/// </summary>
	/// <param name="message"></param>
	void Log(const std::string& message);
}




============================================================
File Path: engine/base/SrvManager.cpp
============================================================
#include "SrvManager.h"

using namespace Engine;

const uint32_t SrvManager::kMaxSRVCount = 512;

void SrvManager::Initialize(DirectXCommon* dxCommon)
{
	this->dxCommon = dxCommon;
	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	descriptorHeap = dxCommon->CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, kMaxSRVCount, true);
	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ï¼‘å€‹åˆ†ã®ã‚µã‚¤ã‚ºã‚’å–å¾—ã—ã¦è¨˜éŒ²
	descriptorSize = dxCommon->GetDevice()->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

}

uint32_t SrvManager::Allocate  ()
{
	// ä¸Šé™ã«é”ã—ã¦ã„ãªã„ã‹ç¢ºèª
	if (kMaxSRVCount<= useIndex) {
		// ä¸Šé™ã«é”ã—ã¦ã„ã‚‹ã®ã§ã‚¨ãƒ©ãƒ¼
		assert(0);
	}
	// returnã™ã‚‹ç•ªå·ã‚’ä¸€æ—¦è¨˜éŒ²
	uint32_t index = useIndex;
	// æ¬¡ã«ä½¿ç”¨ã™ã‚‹ç•ªå·ã‚’æ›´æ–°
	useIndex++;
	// ä¸Šã§è¨˜éŒ²ã—ãŸç•ªå·ã‚’retunr
	return index;
}

void SrvManager::CreateSRVforTexture2D(uint32_t srvIndex, ID3D12Resource* pResource, DXGI_FORMAT Format, UINT MipLevels)
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = Format;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.Texture2D.MipLevels = MipLevels;
	// SRVã‚’ä½œæˆ
	dxCommon->GetDevice()->CreateShaderResourceView(pResource, &srvDesc, GetCPUDescriptorHandle(srvIndex));

}

void SrvManager::CreateSRVforStructuredBuffer(uint32_t srvIndex, ID3D12Resource* pResource, UINT numElements, UINT structureByteStride)
{
	// SRVã®è¨­å®š
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = DXGI_FORMAT_UNKNOWN; // æ§‹é€ åŒ–ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ UNKNOWN
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.Buffer.FirstElement = 0;
	srvDesc.Buffer.NumElements = numElements;
	srvDesc.Buffer.StructureByteStride = structureByteStride;
	srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;

	// SRVã‚’ä½œæˆ
	dxCommon->GetDevice()->CreateShaderResourceView(pResource, &srvDesc, GetCPUDescriptorHandle(srvIndex));
}

void SrvManager::PreDraw()
{
#pragma region SRVç”¨ã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ã‚’æŒ‡å®š
	// æç”»ç”¨ã®DescriptorHeapã®è¨­å®š
	ID3D12DescriptorHeap* descriptorHeaps[] = { descriptorHeap.Get()};
	dxCommon->GetCommandList()->SetDescriptorHeaps(1, descriptorHeaps);
#pragma endregion
}

void SrvManager::SetGraphicsDescriptorTable(UINT RootParameterIndex, uint32_t srvIndex)
{
	dxCommon->GetCommandList()->SetGraphicsRootDescriptorTable(RootParameterIndex, GetGPUDescriptorHandle(srvIndex));
}

bool SrvManager::IsAllocate()
{
	if (kMaxSRVCount > useIndex) {
		return true;
	}
	else {
		return false;
	}
}

D3D12_CPU_DESCRIPTOR_HANDLE SrvManager::GetCPUDescriptorHandle(uint32_t index)
{
	D3D12_CPU_DESCRIPTOR_HANDLE handleCPU = descriptorHeap->GetCPUDescriptorHandleForHeapStart();
	handleCPU.ptr += (descriptorSize * index);
	return handleCPU;
}

D3D12_GPU_DESCRIPTOR_HANDLE SrvManager::GetGPUDescriptorHandle(uint32_t index)
{
	D3D12_GPU_DESCRIPTOR_HANDLE handleGPU = descriptorHeap->GetGPUDescriptorHandleForHeapStart();
	handleGPU.ptr += (descriptorSize * index);
	return handleGPU;
}

Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> SrvManager::GetSRVHeap() const
{
	return descriptorHeap;
}


============================================================
File Path: engine/base/SrvManager.h
============================================================
#pragma once
#include "DirectXCommon.h"
/// <summary>
/// SRVç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
/// <remarks>
/// SRVã®ç”Ÿæˆã€ç®¡ç†ã‚’è¡Œã†
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹
/// </remarks>
class SrvManager
{
public:
	// æœ€å¤§SRVæ•°(æœ€å¤§ãƒ†ã‚¯ã‚¹ãƒãƒ£æšæ•°)
	static const uint32_t kMaxSRVCount;
public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon"></param>
	void Initialize(Engine::DirectXCommon* dxCommon);
	/// <summary>
	/// ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼
	/// </summary>
	/// <returns></returns>
	uint32_t Allocate();
	/// <summary>
	/// SRVç”Ÿæˆ(ãƒ†ã‚¯ã‚¹ãƒãƒ£2Dç”¨)
	/// </summary>
	/// <param name="srvIndex"></param>
	/// <param name="pResource"></param>
	/// <param name="Format"></param>
	/// <param name="MipLevels"></param>
	void CreateSRVforTexture2D(uint32_t srvIndex, ID3D12Resource* pResource, DXGI_FORMAT Format, UINT MipLevels);
	/// <summary>
	/// SRVç”Ÿæˆ(ãƒãƒƒãƒ•ã‚¡ç”¨)
	/// </summary>
	/// <param name="srvIndex"></param>
	/// <param name="pResource"></param>
	/// <param name="numElements"></param>
	/// <param name="structureByteStrode"></param>
	void CreateSRVforStructuredBuffer(uint32_t srvIndex, ID3D12Resource* pResource, UINT numElements, UINT structureByteStrude);
	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	void PreDraw();
	/// <summary>
	/// SRVã‚»ãƒƒãƒˆã‚³ãƒãƒ³ãƒ‰
	/// </summary>
	/// <param name="RootParameterIndex"></param>
	/// <param name="srvIndex"></param>
	void SetGraphicsDescriptorTable(UINT RootParameterIndex, uint32_t srvIndex);
	
	/// <summary>
	/// æœ€å¤§æ•°ã«é”ã—ã¦ã„ã‚‹ã‹
	/// </summary>
	/// <returns></returns>
	bool IsAllocate();
public:// Getter,Setter
	/// <summary>
	/// CPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
	/// </summary>
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(uint32_t index);
	/// <summary>
	/// GPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
	/// </summary>
	D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(uint32_t index);
	/// <summary>
	/// SRVãƒ’ãƒ¼ãƒ—ã®å–å¾—
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> GetSRVHeap()const;
private:
	// çµ¶å¯¾ã«newã—ãªã„
	Engine::DirectXCommon* dxCommon;
	// SRVã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º
	uint32_t descriptorSize;
	// SRVã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> descriptorHeap;
	// æ¬¡ã«ä½¿ç”¨ã™ã‚‹SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	uint32_t useIndex = 0;

};



============================================================
File Path: engine/base/StringUtility.cpp
============================================================
#include "StringUtility.h"
#include <Windows.h>
namespace StringUtility {

	std::wstring StringUtility::ConvertString(const std::string& str)
	{
		if (str.empty()) {
			return std::wstring();
		}

		auto sizeNeeded = MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), NULL, 0);
		if (sizeNeeded == 0) {
			return std::wstring();
		}
		std::wstring result(sizeNeeded, 0);
		MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), &result[0], sizeNeeded);
		return result;
	}

	std::string StringUtility::ConvertString(const std::wstring& str)
	{
		if (str.empty()) {
			return std::string();
		}

		auto sizeNeeded = WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), NULL, 0, NULL, NULL);
		if (sizeNeeded == 0) {
			return std::string();
		}
		std::string result(sizeNeeded, 0);
		WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), result.data(), sizeNeeded, NULL, NULL);
		return result;
	}

}


============================================================
File Path: engine/base/StringUtility.h
============================================================
#pragma once
#include <string>
/// <summary>
/// stringãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
/// </summary>
namespace StringUtility {

	/// <summary>
	/// stringã‚’wstringã«å¤‰æ›ã™ã‚‹
	/// </summary>
	/// <param name="str"></param>
	/// <returns></returns>
	std::wstring ConvertString(const std::string& str);
	/// <summary>
	/// wstringã‚’stringã«å¤‰æ›ã™ã‚‹
	/// </summary>
	/// <param name="str"></param>
	/// <returns></returns>
	std::string ConvertString(const std::wstring& str);
}

============================================================
File Path: engine/base/TextureManager.cpp
============================================================
#include "TextureManager.h"
#include "DirectXCommon.h"
#include "StringUtility.h"
#include "DirectXCommon.h"

using namespace Engine;

TextureManager* TextureManager::instance = nullptr;
// ImGuiã§0ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãŸã‚ï¼‘ã‹ã‚‰é–‹å§‹
uint32_t TextureManager::kSRVIndexTop = 1;
TextureManager* TextureManager::GetInstance()
{

	if (instance == nullptr) {
		instance = new TextureManager();
	}
	return instance;
}

void TextureManager::DeleteInstance()
{
	if (instance != nullptr) {
		delete instance;
		instance = nullptr;
	}
}

const DirectX::TexMetadata& TextureManager::GetMetadata(const std::string& filePath)

{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢
	auto it = textureDates.find(filePath);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
	assert(it != textureDates.end());

	// è¦‹ã¤ã‹ã£ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
	return it->second.metadata;
}


uint32_t TextureManager::GetSrvIndex(const std::string& filePath)
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
	auto it = textureDates.find(filePath);
	if (it == textureDates.end()) {
		// ãªã‹ã£ãŸã‚‰ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
		throw std::runtime_error("Texture not found for filePath: " + filePath);
	}
	return it->second.srvIndex;
}


D3D12_GPU_DESCRIPTOR_HANDLE TextureManager::GetSrvHandleGPU(const std::string& filePath)
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢
	auto it = textureDates.find(filePath);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ä¾‹å¤–ã‚’æŠ•ã’ã‚‹
	if (it == textureDates.end()) {
		throw std::runtime_error("Texture not found for filePath: " + filePath);
	}
	// è¦‹ã¤ã‹ã£ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®GPUãƒãƒ³ãƒ‰ãƒ«ã‚’è¿”ã™
	return it->second.srvHandleGPU;
}

Microsoft::WRL::ComPtr<ID3D12Resource> TextureManager::GetTextureResource(const std::string& filePath)
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢
	auto it = textureDates.find(filePath);
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ä¾‹å¤–ã‚’æŠ•ã’ã‚‹
	if (it == textureDates.end()) {
		throw std::runtime_error("Texture not found for filePath: " + filePath);
	}
	// è¦‹ã¤ã‹ã£ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’è¿”ã™
	return it->second.resource;
}

D3D12_GPU_DESCRIPTOR_HANDLE TextureManager::GetGpuDescriptorHandle(const std::string& filePath) 
{

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢
	auto it = textureDates.find(filePath);
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ä¾‹å¤–ã‚’æŠ•ã’ã‚‹
	if (it == textureDates.end()) {
		throw std::runtime_error("Texture not found for filePath: " + filePath);
	}
	// è¦‹ã¤ã‹ã£ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®GPUãƒãƒ³ãƒ‰ãƒ«ã‚’è¿”ã™
	return it->second.srvHandleGPU;
}




void TextureManager::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager)
{
	this->dxCommon = dxCommon;
	this->srvManager = srvManager;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®æœ€å¤§æšæ•°ã‚’å–å¾—/SRVã®æœ€å¤§æ•°ã‚’å–å¾—
	textureDates.reserve(SrvManager::kMaxSRVCount);
}

void TextureManager::Finalize()
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®ã‚¯ãƒªã‚¢
	textureDates.clear();
}

void TextureManager::LoadTexture(const std::string& filePath)
{
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
	if (textureDates.contains(filePath)) {
		// èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„
		return;
	}

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£æšæ•°ä¸Šé™ã‚’è¶…ãˆã¦ã„ã‚‹å ´åˆ
	assert(srvManager->IsAllocate());

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚“ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§æ‰±ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹
	DirectX::ScratchImage image{};
	std::wstring filePathW = StringUtility::ConvertString(filePath);
	// DDSã‚„WICå½¢å¼ã®ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
	HRESULT hr;
	if (filePathW.ends_with(L".dds")) {
		// .ddsã§çµ‚äº†ã—ã¦ã„ã‚‹å ´åˆèª­ã¿è¾¼ã‚€ã‚ˆã†ã«ã™ã‚‹
		hr = DirectX::LoadFromDDSFile(filePathW.c_str(), DirectX::DDS_FLAGS_NONE, nullptr, image);
	} else {
		hr = DirectX::LoadFromWICFile(filePathW.c_str(), DirectX::WIC_FLAGS_FORCE_SRGB, nullptr, image);
	}

	assert(SUCCEEDED(hr));

	// ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ã®ä½œæˆ
	DirectX::ScratchImage mipImages{};
	// åœ§ç¸®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‹èª¿ã¹ã‚‹
	if (DirectX::IsCompressed(image.GetMetadata().format)) {
		// åœ§ç¸®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã‚ã‚Œã°ãã®ã¾ã¾ä½¿ç”¨ã™ã‚‹ã®ã§move
		mipImages = std::move(image);
	} else {
		hr = DirectX::GenerateMipMaps(image.GetImages(), image.GetImageCount(), image.GetMetadata(), DirectX::TEX_FILTER_SRGB, 0, mipImages);
	}


	assert(SUCCEEDED(hr));

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®è¿½åŠ 
	TextureData textureData;
	textureData.metadata = mipImages.GetMetadata();
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	textureData.resource = dxCommon->CreateTextureResource(textureData.metadata);
	// ä¸­é–“ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	Microsoft::WRL::ComPtr<ID3D12Resource> intermediateResource = dxCommon->UploadTextureData(textureData.resource, mipImages);
	// ã‚³ãƒãƒ³ãƒ‰ã®ã‚­ãƒƒã‚¯ã‚’å¾…ã¤
	dxCommon->WaitCommand();

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®è¦ç´ æ•°ç•ªå·ã‚’SRVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ã™ã‚‹
	uint32_t srvIndex = static_cast<uint32_t>(textureDates.size()) + kSRVIndexTop;

	// SRVç¢ºä¿
	textureData.srvIndex = srvManager->Allocate();
	textureData.srvHandleCPU = srvManager->GetCPUDescriptorHandle(textureData.srvIndex);
	textureData.srvHandleGPU = srvManager->GetGPUDescriptorHandle(textureData.srvIndex);

	// SRVã®è¨­å®š
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = textureData.metadata.format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;

	if (textureData.metadata.IsCubemap()) {
		// textureCubeã§ã¯ã‚ã‚‹ãŒtexture2Dã¨ã‹ã‚ã‚‰ãªã„
		srvDesc.TextureCube.MostDetailedMip = 0;
		srvDesc.TextureCube.MipLevels = UINT_MAX;
		srvDesc.TextureCube.ResourceMinLODClamp = 0.0f;
		srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBE;
	} else {
		srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D; // 2Dãƒ†ã‚¯ã‚¹ãƒãƒ£
		srvDesc.Texture2D.MipLevels = UINT(textureData.metadata.mipLevels);

	}

	// SRVã‚’ä½œæˆ
	dxCommon->GetDevice()->CreateShaderResourceView(textureData.resource.Get(), &srvDesc, textureData.srvHandleCPU);

	// textureDatesã«è¿½åŠ 
	textureDates.emplace(filePath, std::move(textureData));

}

============================================================
File Path: engine/base/TextureManager.h
============================================================
#pragma once
#include <string>
#include <wrl/client.h>
#include <d3d12.h>
#include "DirectXCommon.h"
#include "externals/DirectXTex/DirectXTex.h"
#include "SrvManager.h"
#include <unordered_map>
#include <cstdint>

/// <summary>
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
/// <remarks>
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿ã€è§£æ”¾ã‚’è¡Œã†
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹
/// </remarks>
class srvManager;
class TextureManager
{
	// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®é–‹å§‹ç•ªå·
	static uint32_t kSRVIndexTop;
public:		// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="dxCommon">ãƒ‡ãƒã‚¤ã‚¹ã‚„ã‚³ãƒãƒ³ãƒ‰ç®¡ç†</param>
	/// <param name="srvManager">SRVã®å‰²ã‚Šå½“ã¦ãŠã‚ˆã³ç®¡ç†</param>
	void Initialize(Engine::DirectXCommon* dxCommon, SrvManager* srvManager);
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();
	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®èª­ã¿è¾¼ã¿
	/// <param name ="filePath"ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹>
	/// </summary>
	void LoadTexture(const std::string& filePath);

public:	// Getter,Setter
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	static TextureManager* GetInstance();
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è§£æ”¾
	/// </summary>
	static void DeleteInstance();

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£æƒ…å ±ã®å–å¾—
	/// </summary>
	/// <param name="filePath"></param>
	/// <returns></returns>
	const DirectX::TexMetadata& GetMetadata(const std::string& filePath);
	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç•ªå·ã®å–å¾—
	/// </summary>
	/// <param name="filePath"></param>
	/// <returns></returns>
	uint32_t GetSrvIndex(const std::string& filePath);
	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç•ªå·ã‹ã‚‰GPUãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	/// </summary>
	D3D12_GPU_DESCRIPTOR_HANDLE GetSrvHandleGPU(const std::string& filePath);

	Microsoft::WRL::ComPtr<ID3D12Resource> GetTextureResource(const std::string& filePath);

	D3D12_GPU_DESCRIPTOR_HANDLE GetGpuDescriptorHandle(const std::string& filePath);
	

private: // ãƒ¡ãƒ³ãƒé–¢æ•°/æ§‹é€ ä½“


	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼‘æšåˆ†ã®æƒ…å ±
	struct TextureData
	{
		//std::string filePath;	// ãƒ•ã‚¡ã‚¤ãƒ«å
		DirectX::TexMetadata metadata;						// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®æƒ…å ±(å¹…ã€é«˜ã•)
		Microsoft::WRL::ComPtr<ID3D12Resource> resource;	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹
		uint32_t srvIndex;									// SRVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
		D3D12_CPU_DESCRIPTOR_HANDLE srvHandleCPU;			// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã®CPUãƒãƒ³ãƒ‰ãƒ«
		D3D12_GPU_DESCRIPTOR_HANDLE srvHandleGPU;			// æç”»ã‚³ãƒãƒ³ãƒ‰ã«å¿…è¦ãªGPUãƒãƒ³ãƒ‰ãƒ«
	};

private:	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ 
	static TextureManager* instance;
	TextureManager() = default;
	~TextureManager() = default;
	TextureManager(TextureManager&) = delete;
	TextureManager& operator=(TextureManager&) = delete;

private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	Engine::DirectXCommon* dxCommon = nullptr;

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿
	std::unordered_map<std::string, TextureData> textureDates;	// 
	// SRVãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
	SrvManager* srvManager = nullptr;

};



============================================================
File Path: engine/base/WinAPI.cpp
============================================================
#include "WinAPI.h"
#include <cstdint>
#pragma comment(lib,"winmm.lib")
#ifdef USE_IMGUI
#include "externals/imgui/imgui.h"
#include "externals/imgui/imgui_impl_win32.h"
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwndm, UINT msg, WPARAM wParam, LPARAM lParam);
#endif
LRESULT WinAPI::WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
#ifdef USE_IMGUI
	if (ImGui_ImplWin32_WndProcHandler(hwnd, msg, wparam, lparam)) {
		return true;
	}
#endif
	// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å¿œã˜ã¦ã‚²ãƒ¼ãƒ å›ºæœ‰ã®å‡¦ç†ã‚’è¡Œã†
	switch (msg) {
		// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒç ´æ£„ã•ã‚ŒãŸ
	case WM_DESTROY:
		// OSã«å¯¾ã—ã¦ã‚¢ãƒ—ãƒªã®çµ‚äº†ã‚’ä¼ãˆã‚‹
		PostQuitMessage(0);
		return 0;
	}
	// æ¨™æº–ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†ã‚’è¡Œã†
	return DefWindowProc(hwnd, msg, wparam, lparam); 
}

void WinAPI::Finalize()
{
	CloseWindow(hwnd);
	CoUninitialize();
}

void WinAPI::Initialize()
{
	// ã‚·ã‚¹ãƒ†ãƒ ã‚¿ã‚¤ãƒãƒ¼ã®åˆ†è§£èƒ½ã‚’ä¸Šã’ã‚‹
	timeBeginPeriod(1);
	HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
#pragma region Windowã®ç”Ÿæˆ

	
	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£
	wc.lpfnWndProc = WindowProc;//ä¸Šã®é–¢æ•°ã‚’æ¸¡ã—ã¦ã„ã‚‹
	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹å
	wc.lpszClassName = L"CG2";
	//ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«
	wc.hInstance = GetModuleHandle(nullptr);
	//ã‚«ãƒ¼ã‚½ãƒ«
	wc.hCursor = LoadCursor(nullptr, IDC_ARROW);


	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã‚’ç™»éŒ²
	RegisterClass(&wc);

	
	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã‚’è¡¨ã™æ§‹é€ ä½“ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’å…¥ã‚Œã‚‹
	RECT wrc = { 0,0,WinAPI::kClientWidth,WinAPI::kClientHeight };//RECT ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ«(çŸ©å½¢)
	//ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’ã‚‚ã¨ã«å®Ÿéš›ã®ã‚µã‚¤ã‚ºã«wrcã‚’å¤‰æ›´ã—ã¦ã‚‚ã‚‰ã†
	AdjustWindowRect(&wrc, WS_OVERLAPPEDWINDOW, false);

	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ç”Ÿæˆ
	hwnd = CreateWindow(
		wc.lpszClassName,        //åˆ©ç”¨ã™ã‚‹ã‚¯ãƒ©ã‚¹ãƒ¡ã‚¤ãƒ³
		L"MyEngine",                  //ã‚¿ã‚¤ãƒˆãƒ«ãƒãƒ¼ã®æ–‡å­—
		WS_OVERLAPPEDWINDOW,     //ã‚ˆãè¦‹ã‚‹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¹ã‚¿ã‚¤ãƒ«
		CW_USEDEFAULT,           //è¡¨ç¤ºXåº§æ¨™
		CW_USEDEFAULT,           //è¡¨ç¤ºYåº§æ¨™ 
		wrc.right - wrc.left,    //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¨ªå¹…
		wrc.bottom - wrc.top,    //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ç¸¦å¹…
		nullptr,                 //è¦ªã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
		nullptr,                 //ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ³ãƒ‰ãƒ«
		wc.hInstance,            //ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«
		nullptr                  //ã‚ªãƒ—ã‚·ãƒ§ãƒ³
	);//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºã™ã‚‹
	ShowWindow(hwnd, SW_SHOW);
#pragma endregion
}

bool WinAPI::ProcessMessage()
{
	MSG msg{};
	//Windowã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ¥ã¦ãŸã‚‰æœ€å„ªå…ˆã§å‡¦ç†ã•ã›ã‚‹
	if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	if (msg.message == WM_QUIT) {
		return true;
	}
	return false;
}



============================================================
File Path: engine/base/WinAPI.h
============================================================
#pragma once
#include <Windows.h>
#include <cstdint>
/// <summary>
/// WindowsAPIã®ãƒ©ãƒƒãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹
/// </summary>
class WinAPI
{
public:
	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‹ã‚‰ã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†é–¢æ•°
	/// </summary>
	/// <param name="hwnd">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å—ã‘å–ã£ãŸã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ãƒãƒ³ãƒ‰ãƒ«</param>
	/// <param name="msg">é€ä¿¡ã•ã‚ŒãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ID</param>
	/// <param name="wparam">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ä»˜éšã™ã‚‹è¿½åŠ æƒ…å ± / WPRAM </param>
	/// <param name="lparam">ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«ä»˜éšã™ã‚‹è¿½åŠ æƒ…å ± / LPRAM</param>
	/// <returns>ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†çµæœã€€å‡¦ç†æ¸ˆã¿ãªã‚‰ï¼</returns>
	static LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);
	//å®šæ•°
	//ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã®ã‚µã‚¤ã‚º
	static const int32_t kClientWidth = 1280;
	static const int32_t kClientHeight = 720;

public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();


	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();
	
	
	/// <summary>
	/// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
	/// </summary>
	bool ProcessMessage();

	//getter
	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
	/// </summary>
	HWND GetHwnd() const { return hwnd; }
	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
	/// </summary>
	HINSTANCE GetHInstance()const { return wc.hInstance; }
private:
	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
	HWND hwnd = nullptr;

	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã®è¨­å®š
	WNDCLASS wc{};

};



============================================================
File Path: engine/math/MakeMatrix.cpp
============================================================
#include"MakeMatrix.h"

#include<cmath>
#include <cassert>


Matrix4x4 MakePerspectiveFovMatrix(float fovY, float aspectRatio, float nearClip, float farClip) {
    Matrix4x4 result;
    result.m[0][0] = 1 / aspectRatio * (1 / std::tan(fovY / 2));   result.m[0][1] = 0;                        result.m[0][2] = 0;                                                               result.m[0][3] = 0;
    result.m[1][0] = 0;                                            result.m[1][1] = 1 / std::tan(fovY / 2);   result.m[1][2] = 0;                                                               result.m[1][3] = 0;
    result.m[2][0] = 0;                                            result.m[2][1] = 0;                        result.m[2][2] = farClip / (farClip - nearClip);                                  result.m[2][3] = 1;
    result.m[3][0] = 0;                                            result.m[3][1] = 0;                        result.m[3][2] = (-nearClip * farClip * std::cos(0.0f)) / (farClip - nearClip);   result.m[3][3] = 0;

    return result;
}

Matrix4x4 MakeTranslateMatrix(const Vector3& translate) {
	Matrix4x4 ans;

	ans.m[0][0] = 1;
	ans.m[0][1] = 0;
	ans.m[0][2] = 0;
	ans.m[0][3] = 0;

	ans.m[1][0] = 0;
	ans.m[1][1] = 1;
	ans.m[1][2] = 0;
	ans.m[1][3] = 0;

	ans.m[2][0] = 0;
	ans.m[2][1] = 0;
	ans.m[2][2] = 1;
	ans.m[2][3] = 0;

	ans.m[3][0] = translate.x;
	ans.m[3][1] = translate.y;
	ans.m[3][2] = translate.z;
	ans.m[3][3] = 1;

	return ans;
}

Matrix4x4 MakeScaleMatrix(const Vector3& scale) {
	Matrix4x4 ans;

	ans.m[0][0] = scale.x;
	ans.m[0][1] = 0;
	ans.m[0][2] = 0;
	ans.m[0][3] = 0;

	ans.m[1][0] = 0;
	ans.m[1][1] = scale.y;
	ans.m[1][2] = 0;
	ans.m[1][3] = 0;

	ans.m[2][0] = 0;
	ans.m[2][1] = 0;
	ans.m[2][2] = scale.z;
	ans.m[2][3] = 0;

	ans.m[3][0] = 0;
	ans.m[3][1] = 0;
	ans.m[3][2] = 0;
	ans.m[3][3] = 1;
	return ans;
}



Matrix4x4 MakeRotateXMatrix(float radian) {

	Matrix4x4 ans;
	ans.m[0][0] = 1;
	ans.m[0][1] = 0;
	ans.m[0][2] = 0;
	ans.m[0][3] = 0;

	ans.m[1][0] = 0;
	ans.m[1][1] = std::cos(radian);
	;
	ans.m[1][2] = std::sin(radian);
	;
	ans.m[1][3] = 0;

	ans.m[2][0] = 0;
	ans.m[2][1] = -std::sin(radian);
	;
	ans.m[2][2] = std::cos(radian);
	;
	ans.m[2][3] = 0;

	ans.m[3][0] = 0;
	ans.m[3][1] = 0;
	ans.m[3][2] = 0;
	ans.m[3][3] = 1;

	return ans;
}

Matrix4x4 MakeRotateYMatrix(float radian) {

	Matrix4x4 ans;
	ans.m[0][0] = std::cos(radian);
	ans.m[0][1] = 0;
	ans.m[0][2] = -std::sin(radian);
	ans.m[0][3] = 0;

	ans.m[1][0] = 0;
	ans.m[1][1] = 1;
	ans.m[1][2] = 0;
	ans.m[1][3] = 0;

	ans.m[2][0] = std::sin(radian);
	;
	ans.m[2][1] = 0;
	ans.m[2][2] = std::cos(radian);
	;
	ans.m[2][3] = 0;

	ans.m[3][0] = 0;
	ans.m[3][1] = 0;
	ans.m[3][2] = 0;
	ans.m[3][3] = 1;

	return ans;
}

Matrix4x4 MakeRotateZMatrix(float radian) {
	Matrix4x4 ans;
	ans.m[0][0] = std::cos(radian);
	ans.m[0][1] = std::sin(radian);
	ans.m[0][2] = 0;
	ans.m[0][3] = 0;

	ans.m[1][0] = -std::sin(radian);
	ans.m[1][1] = std::cos(radian);
	ans.m[1][2] = 0;
	ans.m[1][3] = 0;

	ans.m[2][0] = 0;
	ans.m[2][1] = 0;
	ans.m[2][2] = 1;
	ans.m[2][3] = 0;

	ans.m[3][0] = 0;
	ans.m[3][1] = 0;
	ans.m[3][2] = 0;
	ans.m[3][3] = 1;

	return ans;
}


Matrix4x4 Add(const Matrix4x4& mt1, const Matrix4x4& mt2) {

	Matrix4x4 ans;

	ans.m[0][0] = mt1.m[0][0] + mt2.m[0][0];
	ans.m[0][1] = mt1.m[0][1] + mt2.m[0][1];
	ans.m[0][2] = mt1.m[0][2] + mt2.m[0][2];
	ans.m[0][3] = mt1.m[0][3] + mt2.m[0][3];

	ans.m[1][0] = mt1.m[1][0] + mt2.m[1][0];
	ans.m[1][1] = mt1.m[1][1] + mt2.m[1][1];
	ans.m[1][2] = mt1.m[1][2] + mt2.m[1][2];
	ans.m[1][3] = mt1.m[1][3] + mt2.m[1][3];

	ans.m[2][0] = mt1.m[2][0] + mt2.m[2][0];
	ans.m[2][1] = mt1.m[2][1] + mt2.m[2][1];
	ans.m[2][2] = mt1.m[2][2] + mt2.m[2][2];
	ans.m[2][3] = mt1.m[2][3] + mt2.m[2][3];

	ans.m[3][0] = mt1.m[3][0] + mt2.m[3][0];
	ans.m[3][1] = mt1.m[3][1] + mt2.m[3][1];
	ans.m[3][2] = mt1.m[3][2] + mt2.m[3][2];
	ans.m[3][3] = mt1.m[3][3] + mt2.m[3][3];

	return ans;
}

Matrix4x4 Subtract(const Matrix4x4& mt1, const Matrix4x4& mt2) {

	Matrix4x4 ans;

	ans.m[0][0] = mt1.m[0][0] - mt2.m[0][0];
	ans.m[0][1] = mt1.m[0][1] - mt2.m[0][1];
	ans.m[0][2] = mt1.m[0][2] - mt2.m[0][2];
	ans.m[0][3] = mt1.m[0][3] - mt2.m[0][3];

	ans.m[1][0] = mt1.m[1][0] - mt2.m[1][0];
	ans.m[1][1] = mt1.m[1][1] - mt2.m[1][1];
	ans.m[1][2] = mt1.m[1][2] - mt2.m[1][2];
	ans.m[1][3] = mt1.m[1][3] - mt2.m[1][3];

	ans.m[2][0] = mt1.m[2][0] - mt2.m[2][0];
	ans.m[2][1] = mt1.m[2][1] - mt2.m[2][1];
	ans.m[2][2] = mt1.m[2][2] - mt2.m[2][2];
	ans.m[2][3] = mt1.m[2][3] - mt2.m[2][3];

	ans.m[3][0] = mt1.m[3][0] - mt2.m[3][0];
	ans.m[3][1] = mt1.m[3][1] - mt2.m[3][1];
	ans.m[3][2] = mt1.m[3][2] - mt2.m[3][2];
	ans.m[3][3] = mt1.m[3][3] - mt2.m[3][3];

	return ans;
}

Matrix4x4 Multiply(const Matrix4x4& mt1, const Matrix4x4& mt2) {

	Matrix4x4 ans = {};
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			for (int k = 0; k < 4; k++) {

				ans.m[i][j] += mt1.m[i][k] * mt2.m[k][j];
			}
		}
	}
	return ans;
}

//é€†è¡Œåˆ—
Matrix4x4 Inverse(const Matrix4x4& m) {
	float A = m.m[0][0] * m.m[1][1] * m.m[2][2] * m.m[3][3] + m.m[0][0] * m.m[1][2] * m.m[2][3] * m.m[3][1] + m.m[0][0] * m.m[1][3] * m.m[2][1] * m.m[3][2]
		- m.m[0][0] * m.m[1][3] * m.m[2][2] * m.m[3][1] - m.m[0][0] * m.m[1][2] * m.m[2][1] * m.m[3][3] - m.m[0][0] * m.m[1][1] * m.m[2][3] * m.m[3][2]
		- m.m[0][1] * m.m[1][0] * m.m[2][2] * m.m[3][3] - m.m[0][2] * m.m[1][0] * m.m[2][3] * m.m[3][1] - m.m[0][3] * m.m[1][0] * m.m[2][1] * m.m[3][2]
		+ m.m[0][3] * m.m[1][0] * m.m[2][2] * m.m[3][1] + m.m[0][2] * m.m[1][0] * m.m[2][1] * m.m[3][3] + m.m[0][1] * m.m[1][0] * m.m[2][3] * m.m[3][2]
		+ m.m[0][1] * m.m[1][2] * m.m[2][0] * m.m[3][3] + m.m[0][2] * m.m[1][3] * m.m[2][0] * m.m[3][1] + m.m[0][3] * m.m[1][1] * m.m[2][0] * m.m[3][2]
		- m.m[0][3] * m.m[1][2] * m.m[2][0] * m.m[3][1] - m.m[0][2] * m.m[1][1] * m.m[2][0] * m.m[3][3] - m.m[0][1] * m.m[1][3] * m.m[2][0] * m.m[3][2]
		- m.m[0][1] * m.m[1][2] * m.m[2][3] * m.m[3][0] - m.m[0][2] * m.m[1][3] * m.m[2][1] * m.m[3][0] - m.m[0][3] * m.m[1][1] * m.m[2][2] * m.m[3][0]
		+ m.m[0][3] * m.m[1][2] * m.m[2][1] * m.m[3][0] + m.m[0][2] * m.m[1][1] * m.m[2][3] * m.m[3][0] + m.m[0][1] * m.m[1][3] * m.m[2][2] * m.m[3][0];

	Matrix4x4 result = {};
	result.m[0][0] = 1 / A * (m.m[1][1] * m.m[2][2] * m.m[3][3] + m.m[1][2] * m.m[2][3] * m.m[3][1] + m.m[1][3] * m.m[2][1] * m.m[3][2] - m.m[1][3] * m.m[2][2] * m.m[3][1] - m.m[1][2] * m.m[2][1] * m.m[3][3] - m.m[1][1] * m.m[2][3] * m.m[3][2]);
	result.m[0][1] = 1 / A * (-m.m[0][1] * m.m[2][2] * m.m[3][3] - m.m[0][2] * m.m[2][3] * m.m[3][1] - m.m[0][3] * m.m[2][1] * m.m[3][2] + m.m[0][3] * m.m[2][2] * m.m[3][1] + m.m[0][2] * m.m[2][1] * m.m[3][3] + m.m[0][1] * m.m[2][3] * m.m[3][2]);
	result.m[0][2] = 1 / A * (m.m[0][1] * m.m[1][2] * m.m[3][3] + m.m[0][2] * m.m[1][3] * m.m[3][1] + m.m[0][3] * m.m[1][1] * m.m[3][2] - m.m[0][3] * m.m[1][2] * m.m[3][1] - m.m[0][2] * m.m[1][1] * m.m[3][3] - m.m[0][1] * m.m[1][3] * m.m[3][2]);
	result.m[0][3] = 1 / A * (-m.m[0][1] * m.m[1][2] * m.m[2][3] - m.m[0][2] * m.m[1][3] * m.m[2][1] - m.m[0][3] * m.m[1][1] * m.m[2][2] + m.m[0][3] * m.m[1][2] * m.m[2][1] + m.m[0][2] * m.m[1][1] * m.m[2][3] + m.m[0][1] * m.m[1][3] * m.m[2][2]);

	result.m[1][0] = 1 / A * (-m.m[1][0] * m.m[2][2] * m.m[3][3] - m.m[1][2] * m.m[2][3] * m.m[3][0] - m.m[1][3] * m.m[2][0] * m.m[3][2] + m.m[1][3] * m.m[2][2] * m.m[3][0] + m.m[1][2] * m.m[2][0] * m.m[3][3] + m.m[1][0] * m.m[2][3] * m.m[3][2]);
	result.m[1][1] = 1 / A * (m.m[0][0] * m.m[2][2] * m.m[3][3] + m.m[0][2] * m.m[2][3] * m.m[3][0] + m.m[0][3] * m.m[2][0] * m.m[3][2] - m.m[0][3] * m.m[2][2] * m.m[3][0] - m.m[0][2] * m.m[2][0] * m.m[3][3] - m.m[0][0] * m.m[2][3] * m.m[3][2]);
	result.m[1][2] = 1 / A * (-m.m[0][0] * m.m[1][2] * m.m[3][3] - m.m[0][2] * m.m[1][3] * m.m[3][0] - m.m[0][3] * m.m[1][0] * m.m[3][2] + m.m[0][3] * m.m[1][2] * m.m[3][0] + m.m[0][2] * m.m[1][0] * m.m[3][3] + m.m[0][0] * m.m[1][3] * m.m[3][2]);
	result.m[1][3] = 1 / A * (m.m[0][0] * m.m[1][2] * m.m[2][3] + m.m[0][2] * m.m[1][3] * m.m[2][0] + m.m[0][3] * m.m[1][0] * m.m[2][2] - m.m[0][3] * m.m[1][2] * m.m[2][0] - m.m[0][2] * m.m[1][0] * m.m[2][3] - m.m[0][0] * m.m[1][3] * m.m[2][2]);

	result.m[2][0] = 1 / A * (m.m[1][0] * m.m[2][1] * m.m[3][3] + m.m[1][1] * m.m[2][3] * m.m[3][0] + m.m[1][3] * m.m[2][0] * m.m[3][1] - m.m[1][3] * m.m[2][1] * m.m[3][0] - m.m[1][1] * m.m[2][0] * m.m[3][3] - m.m[1][0] * m.m[2][3] * m.m[3][1]);
	result.m[2][1] = 1 / A * (-m.m[0][0] * m.m[2][1] * m.m[3][3] - m.m[0][1] * m.m[2][3] * m.m[3][0] - m.m[0][3] * m.m[2][0] * m.m[3][1] + m.m[0][3] * m.m[2][1] * m.m[3][0] + m.m[0][1] * m.m[2][0] * m.m[3][3] + m.m[0][0] * m.m[2][3] * m.m[3][1]);
	result.m[2][2] = 1 / A * (m.m[0][0] * m.m[1][1] * m.m[3][3] + m.m[0][1] * m.m[1][3] * m.m[3][0] + m.m[0][3] * m.m[1][0] * m.m[3][1] - m.m[0][3] * m.m[1][1] * m.m[3][0] - m.m[0][1] * m.m[1][0] * m.m[3][3] - m.m[0][0] * m.m[1][3] * m.m[3][1]);
	result.m[2][3] = 1 / A * (-m.m[0][0] * m.m[1][1] * m.m[2][3] - m.m[0][1] * m.m[1][3] * m.m[2][0] - m.m[0][3] * m.m[1][0] * m.m[2][1] + m.m[0][3] * m.m[1][1] * m.m[2][0] + m.m[0][1] * m.m[1][0] * m.m[2][3] + m.m[0][0] * m.m[1][3] * m.m[2][1]);

	result.m[3][0] = 1 / A * (-m.m[1][0] * m.m[2][1] * m.m[3][2] - m.m[1][1] * m.m[2][2] * m.m[3][0] - m.m[1][2] * m.m[2][0] * m.m[3][1] + m.m[1][2] * m.m[2][1] * m.m[3][0] + m.m[1][1] * m.m[2][0] * m.m[3][2] + m.m[1][0] * m.m[2][2] * m.m[3][1]);
	result.m[3][1] = 1 / A * (m.m[0][0] * m.m[2][1] * m.m[3][2] + m.m[0][1] * m.m[2][2] * m.m[3][0] + m.m[0][2] * m.m[2][0] * m.m[3][1] - m.m[0][2] * m.m[2][1] * m.m[3][0] - m.m[0][1] * m.m[2][0] * m.m[3][2] - m.m[0][0] * m.m[2][2] * m.m[3][1]);
	result.m[3][2] = 1 / A * (-m.m[0][0] * m.m[1][1] * m.m[3][2] - m.m[0][1] * m.m[1][2] * m.m[3][0] - m.m[0][2] * m.m[1][0] * m.m[3][1] + m.m[0][2] * m.m[1][1] * m.m[3][0] + m.m[0][1] * m.m[1][0] * m.m[3][2] + m.m[0][0] * m.m[1][2] * m.m[3][1]);
	result.m[3][3] = 1 / A * (m.m[0][0] * m.m[1][1] * m.m[2][2] + m.m[0][1] * m.m[1][2] * m.m[2][0] + m.m[0][2] * m.m[1][0] * m.m[2][1] - m.m[0][2] * m.m[1][1] * m.m[2][0] - m.m[0][1] * m.m[1][0] * m.m[2][2] - m.m[0][0] * m.m[1][2] * m.m[2][1]);

	return result;
}

Matrix4x4 Transpose(const Matrix4x4& mt1) {

	Matrix4x4 ans;

	ans.m[0][0] = mt1.m[0][0];
	ans.m[0][1] = mt1.m[1][0];
	ans.m[0][2] = mt1.m[2][0];
	ans.m[0][3] = mt1.m[3][0];

	ans.m[1][0] = mt1.m[0][1];
	ans.m[1][1] = mt1.m[1][1];
	ans.m[1][2] = mt1.m[2][1];
	ans.m[1][3] = mt1.m[3][1];

	ans.m[2][0] = mt1.m[0][2];
	ans.m[2][1] = mt1.m[1][2];
	ans.m[2][2] = mt1.m[2][2];
	ans.m[2][3] = mt1.m[3][2];

	ans.m[3][0] = mt1.m[0][3];
	ans.m[3][1] = mt1.m[1][3];
	ans.m[3][2] = mt1.m[2][3];
	ans.m[3][3] = mt1.m[3][3];

	return ans;
}

Matrix4x4 MakeIdentity4x4() {

	Matrix4x4 ans;

	ans.m[0][0] = 1;
	ans.m[0][1] = 0;
	ans.m[0][2] = 0;
	ans.m[0][3] = 0;

	ans.m[1][0] = 0;
	ans.m[1][1] = 1;
	ans.m[1][2] = 0;
	ans.m[1][3] = 0;

	ans.m[2][0] = 0;
	ans.m[2][1] = 0;
	ans.m[2][2] = 1;
	ans.m[2][3] = 0;

	ans.m[3][0] = 0;
	ans.m[3][1] = 0;
	ans.m[3][2] = 0;
	ans.m[3][3] = 1;

	return ans;
}

Matrix4x4 MakeAffineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate) {
	Matrix4x4 rotateXYZ = Multiply(Multiply(MakeRotateXMatrix(rotate.x), MakeRotateYMatrix(rotate.y)), MakeRotateZMatrix(rotate.z));
	return Multiply(Multiply(MakeScaleMatrix(scale), rotateXYZ), MakeTranslateMatrix(translate));
}

Matrix4x4 MakeOrthographicMatrix(float left, float top, float right, float bottom, float nearClip, float farClip) {
	Matrix4x4 result;
	result.m[0][0] = 2 / right; result.m[0][1] = 0;						result.m[0][2] = 0;						 result.m[0][3] = 0;
	result.m[1][0] = 0;			result.m[1][1] = 2 / (top - bottom);		result.m[1][2] = 0;						 result.m[1][3] = 0;
	result.m[2][0] = 0;			result.m[2][1] = 0;						result.m[2][2] = 1 / (farClip - nearClip); result.m[2][3] = 0;
	result.m[3][0] = (left + right) / (left - right); result.m[3][1] = (top + bottom) / (bottom - top); result.m[3][2] = nearClip / (nearClip - farClip); result.m[3][3] = 1;
	return result;
}

//Quaternion LookAtQuaternion(const Vector3& from, const Vector3& to, const Vector3& up) {
//	// from ã‹ã‚‰ to ã¸ã®æ–¹å‘ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
//	Vector3 forward = Normalize(to - from);
//
//	// right ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—ï¼ˆup ã¨ forward ã®å¤–ç©ï¼‰
//	Vector3 right = Normalize(Cross(up, forward));
//
//	// æ–°ã—ã„ up ãƒ™ã‚¯ãƒˆãƒ«ã‚’è¨ˆç®—
//	Vector3 newUp = Cross(forward, right);
//
//	// LookAt è¡Œåˆ—ã‚’è¨­å®š
//	Matrix4x4 lookAtMatrix;
//	lookAtMatrix.m[0][0] = right.x;
//	lookAtMatrix.m[0][1] = right.y;
//	lookAtMatrix.m[0][2] = right.z;
//	lookAtMatrix.m[0][3] = 0.0f;
//
//	lookAtMatrix.m[1][0] = newUp.x;
//	lookAtMatrix.m[1][1] = newUp.y;
//	lookAtMatrix.m[1][2] = newUp.z;
//	lookAtMatrix.m[1][3] = 0.0f;
//
//	lookAtMatrix.m[2][0] = forward.x;
//	lookAtMatrix.m[2][1] = forward.y;
//	lookAtMatrix.m[2][2] = forward.z;
//	lookAtMatrix.m[2][3] = 0.0f;
//
//	lookAtMatrix.m[3][0] = 0.0f;
//	lookAtMatrix.m[3][1] = 0.0f;
//	lookAtMatrix.m[3][2] = 0.0f;
//	lookAtMatrix.m[3][3] = 1.0f;
//
//	// è¡Œåˆ—ã‚’ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã«å¤‰æ›
//	return MatrixToQuaternion(lookAtMatrix);
//}
//Quaternion Slerp(Quaternion q1, Quaternion q2, float t)
//{
//	// ã‚¯ã‚©ãƒ¼ã‚¿ãƒ‹ã‚ªãƒ³ã®å†…ç©ã‚’è¨ˆç®—
//	float dot = q1.x * q2.x + q1.y * q2.y + q1.z * q2.z + q1.w * q2.w;
//
//	// ãƒ‰ãƒƒãƒˆç©ãŒè² ã®å ´åˆã€é€†ã®æ–¹å‘ã«è£œé–“ã™ã‚‹ãŸã‚ã« q2 ã‚’åè»¢
//	if (dot < 0.0f) {
//		q2.x = -q2.x;
//		q2.y = -q2.y;
//		q2.z = -q2.z;
//		q2.w = -q2.w;
//		dot = -dot;
//	}
//
//	// è£œé–“ä¿‚æ•°ã‚’ä½¿ã£ãŸä¿‚æ•°ã®è¨ˆç®—
//	const float threshold = 0.9995f;
//	if (dot > threshold) {
//		// ãƒ‰ãƒƒãƒˆç©ãŒé–¾å€¤ã‚’è¶…ãˆãŸå ´åˆã€ç·šå½¢è£œé–“ã‚’å®Ÿè¡Œï¼ˆè§’åº¦ãŒå°ã•ã„ãŸã‚ï¼‰
//		Quaternion result = {
//			q1.x + t * (q2.x - q1.x),
//			q1.y + t * (q2.y - q1.y),
//			q1.z + t * (q2.z - q1.z),
//			q1.w + t * (q2.w - q1.w)
//		};
//		return Normalize(result); // çµæœã‚’æ­£è¦åŒ–
//	}
//
//	// è§’åº¦ã®è¨ˆç®—
//	float theta_0 = std::acos(dot);        // Î¸0 = q1 ã¨ q2 é–“ã®è§’åº¦
//	float theta = theta_0 * t;             // Î¸ = t ã«å¯¾å¿œã™ã‚‹è§’åº¦
//
//	// ä¿‚æ•°ã®è¨ˆç®—
//	float sin_theta = std::sin(theta);
//	float sin_theta_0 = std::sin(theta_0);
//
//	float s1 = std::cos(theta) - dot * sin_theta / sin_theta_0;
//	float s2 = sin_theta / sin_theta_0;
//
//	// è£œé–“çµæœã®è¨ˆç®—
//	Quaternion result = {
//		s1 * q1.x + s2 * q2.x,
//		s1 * q1.y + s2 * q2.y,
//		s1 * q1.z + s2 * q2.z,
//		s1 * q1.w + s2 * q2.w
//	};
//	return result;
//}

============================================================
File Path: engine/math/MakeMatrix.h
============================================================
#pragma once
#include <assert.h>
#include <cmath>
#include <stdio.h>
#include"MyMath.h"


Matrix4x4 Add(const Matrix4x4& mt1, const Matrix4x4& mt2);

Matrix4x4 Subtract(const Matrix4x4& mt1, const Matrix4x4& mt2);

Matrix4x4 Multiply(const Matrix4x4& mt1, const Matrix4x4& mt2);

Matrix4x4 Inverse(const Matrix4x4& mt1);

//Matrix4x4 Transpose(const Matrix4x4& mt1);

Matrix4x4 MakeIdentity4x4();
// å›è»¢
Matrix4x4 MakeTranslateMatrix(const Vector3& translate);
// æ‹¡å¤§
Matrix4x4 MakeScaleMatrix(const Vector3& scale);
// åŒæ™‚åº§æ¨™å¤‰æ›

// å›è»¢X 
Matrix4x4 MakeRotateXMatrix(float radian);
// å›è»¢Y
Matrix4x4 MakeRotateYMatrix(float radian);
// å›è»¢Z
Matrix4x4 MakeRotateZMatrix(float radian);

Matrix4x4 MakeAffineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate);


//æ­£å°„å½±è¡Œåˆ—
Matrix4x4 MakeOrthographicMatrix(float left, float top, float right, float bottom, float nearClip, float farClip);

Matrix4x4 MakePerspectiveFovMatrix(float fovY, float aspectRatio, float nearClip, float farClip);
	

============================================================
File Path: engine/math/MyMath.h
============================================================
#pragma once
#include<vector>
#include<cmath>
#include<string>
#pragma region ãƒ™ã‚¯ãƒˆãƒ«
struct Vector2 {
	float x;
	float y;
};
struct Vector3 {
    float x;
    float y;
    float z;

    // åŠ ç®—æ¼”ç®—å­
    Vector3 operator+(const Vector3& other) const {
        return { x + other.x, y + other.y, z + other.z };
    }

    // æ¸›ç®—æ¼”ç®—å­
    Vector3 operator-(const Vector3& other) const {
        return { x - other.x, y - other.y, z - other.z };
    }

    // ã‚¹ã‚«ãƒ©ãƒ¼ä¹—ç®—æ¼”ç®—å­
    Vector3 operator*(float scalar) const {
        return { x * scalar, y * scalar, z * scalar };
    }

    // ã‚¹ã‚«ãƒ©ãƒ¼é™¤ç®—æ¼”ç®—å­
    Vector3 operator/(float scalar) const {
        return { x / scalar, y / scalar, z / scalar };
    }

    // åŠ ç®—ä»£å…¥æ¼”ç®—å­
    Vector3& operator+=(const Vector3& other) {
        x += other.x;
        y += other.y;
        z += other.z;
        return *this;
    }

    // æ¸›ç®—ä»£å…¥æ¼”ç®—å­
    Vector3& operator-=(const Vector3& other) {
        x -= other.x;
        y -= other.y;
        z -= other.z;
        return *this;
    }

    // ã‚¹ã‚«ãƒ©ãƒ¼ä¹—ç®—ä»£å…¥æ¼”ç®—å­
    Vector3& operator*=(float scalar) {
        x *= scalar;
        y *= scalar;
        z *= scalar;
        return *this;
    }

    // ã‚¹ã‚«ãƒ©ãƒ¼é™¤ç®—ä»£å…¥æ¼”ç®—å­
    Vector3& operator/=(float scalar) {
        x /= scalar;
        y /= scalar;
        z /= scalar;
        return *this;
    }

    // ç­‰ä¾¡æ¼”ç®—å­
    bool operator==(const Vector3& other) const {
        return x == other.x && y == other.y && z == other.z;
    }

    // ä¸ç­‰ä¾¡æ¼”ç®—å­
    bool operator!=(const Vector3& other) const {
        return !(*this == other);
    }

    // ãƒãƒ«ãƒ ï¼ˆé•·ã•ï¼‰ã‚’å–å¾—
    float Length() const {
        return std::sqrt(x * x + y * y + z * z);
    }

    // æ­£è¦åŒ–ã—ãŸãƒ™ã‚¯ãƒˆãƒ«ã‚’è¿”ã™ï¼ˆé•·ã•1ã«ã™ã‚‹ï¼‰
    Vector3 Normalized() const {
        float len = Length();
        if (len == 0.0f) {
            return { 0.0f, 0.0f, 0.0f }; // 0é™¤ç®—å›é¿
        }
        return { x / len, y / len, z / len };
    }
};

struct Vector4 {
	float x;
	float y;
	float z;
	float w;
};
#pragma endregion
#pragma region è¡Œåˆ—
struct Matrix3x3 {
	float m[3][3];
};
struct Matrix4x4 {
	float m[4][4];
};
#pragma endregion

struct MaterialData {
	std::string textureFilePath;
	uint32_t textureIndex = 0;
};
struct VertexData {
	Vector4 position;
	Vector2 texcoord;
	Vector3 normal;
};
struct ModelData {
	std::vector<VertexData>vertices;
	MaterialData material;
	std::vector<uint32_t> indices;
};
struct Material {
	Vector4 color;
	int32_t enableLighting;
	float padding[3];
	Matrix4x4 uvTransform;
};
struct TransformationMatrix {
	Matrix4x4 WVP;
	Matrix4x4 World;
};
struct DirectionalLight {
	Vector4 color; //ãƒ©ã‚¤ãƒˆã®è‰²
	Vector3 direction; //ãƒ©ã‚¤ãƒˆã®å‘ã
	float intensity;	//è¼åº¦
};
struct Transform {
	Vector3 scale;
	Vector3 rotate;
	Vector3 translate;
};
struct SpriteData {
	Vector2 pos;
	Vector2 size;
	float rotate;
	Vector4 color;
};
//struct AccelerationField {
//	Vector3 acceleration;
//	AABB area;
//};

struct TextureVertex {
    Vector4 position; 
	Vector2 texcoord;
};

struct CameraForGPU {
    Vector3 worldPosition;
};

#pragma region ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ§‹é€ ä½“
// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ§‹é€ ä½“

struct Particle
{
	Transform transform;
	Vector3 velocity;
	Vector4 color;
	float lifeTime;
	float currentTime;
};
struct ParticleForGPU
{
	Matrix4x4 WVP;
	Matrix4x4 World;
	Vector4 color;
};
struct EffectInstance
{
    Transform transform;     // ä½ç½®ãƒ»å›è»¢ãƒ»ã‚¹ã‚±ãƒ¼ãƒ«
    Vector4 color;           // è‰²ã‚„é€æ˜åº¦ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ç”¨ï¼‰
    float lifeTime;          // å…¨ä½“ã®å¯¿å‘½
    float currentTime;       // çµŒéæ™‚é–“
    bool isActive = true;    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–
};


enum BlendMode {
    //!< ãƒ–ãƒ¬ãƒ³ãƒ‰ç„¡ã—
    kBlendModeNone,
    //!< é€šå¸¸Î±ãƒ–ãƒ¬ãƒ³ãƒ‰ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ src * srcA + Dest * ( 1 - srcA )
    kBelendModeNormal,
    //!< åŠ ç®— src * srcA + Dest * 1;
    kBlendModeAdd,
    //!< æ¸›ç®— Dest * 1 - src * srcA 
    kBlendModeSubtract,
    //!< ä¹—ç®— src * 0 + Dest * src
    kBlendModeMultiply,
    //!< ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ src * ( 1 - Dest )+ Dest * 1
    kBlendModeScreen,
    //!< åˆ©ç”¨ã—ã¦ã¯ã„ã‘ãªã„
    kCountOfBlendMode,
};

#pragma endregion

============================================================
File Path: main.cpp
============================================================
// ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œå‡ºãƒã‚§ãƒƒã‚¯
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
#include "Game/Scene//MyGame.h"
//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚ºã‚¢ãƒ—ãƒªã§ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ(mainé–¢æ•°)
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int) {

#ifdef _DEBUG
	// ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã®ã¨ããƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œå‡ºã‚’æœ‰åŠ¹ã«ã™ã‚‹
	// ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œå‡º
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

	// ãƒªãƒ¼ã‚¯ç•ªå·ã‚’æŒ‡å®šã—ã¦ãƒ–ãƒ¬ãƒ¼ã‚¯ã‚’ç™ºç”Ÿã•ã›ã‚‹
	//_CrtSetBreakAlloc();

	D3DResourceLeakChecker leakChecker;
#endif
	{
		MyGame game;
		game.Run();
	}

	return 0;
}

