### ğŸŒ³ Codebase File Tree (Excluding ignored directories)

â”œâ”€â”€ CG2_DirectX.vcxproj
â”œâ”€â”€ CG2_DirectX.vcxproj.filters
â”œâ”€â”€ Game/
â””â”€â”€ â”œâ”€â”€ Application/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BackGround.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ BackGround.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Block/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Block.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Block.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ BlockType.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Enemy/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyBase.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyBase.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyFactory.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyFactory.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EnemyType.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FlyingEnemy.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ FlyingEnemy.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ NormalEnemy.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ NormalEnemy.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Map/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CsvLoader.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CsvLoader.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Map.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Map.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelList.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelList.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player/
â””â”€â”€ â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Player.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ â””â”€â”€ Player.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StageType.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ StageType.h
â””â”€â”€ â”œâ”€â”€ Camera/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Camera.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Camera.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CameraController.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ CameraController.h
â””â”€â”€ â”œâ”€â”€ Collision/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collider.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Collider.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ CollisionManager.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ CollisionManager.h
â””â”€â”€ â”œâ”€â”€ Loader/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ LevelLoader.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ LevelLoader.h
â””â”€â”€ â”œâ”€â”€ Particle/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EffectEmitter.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EffectEmitter.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EffectManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ EffectManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleEmitter.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleEmitter.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ParticleManager.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ ParticleManager.h
â””â”€â”€ â””â”€â”€ Scene/
â””â”€â”€     â”œâ”€â”€ GamePlayScene.cpp
â””â”€â”€     â”œâ”€â”€ GamePlayScene.h
â””â”€â”€     â”œâ”€â”€ MyGame.cpp
â””â”€â”€     â”œâ”€â”€ MyGame.h
â””â”€â”€     â”œâ”€â”€ SceneSelectGraph/
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ StageSelectGraph.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ StageSelectGraph.h
â””â”€â”€     â”œâ”€â”€ SceneTransition/
â””â”€â”€     â””â”€â”€ â”œâ”€â”€ SceneTransition.cpp
â””â”€â”€     â””â”€â”€ â””â”€â”€ SceneTransition.h
â””â”€â”€     â”œâ”€â”€ StageClearScene.cpp
â””â”€â”€     â”œâ”€â”€ StageClearScene.h
â””â”€â”€     â”œâ”€â”€ StageSelectScene.cpp
â””â”€â”€     â”œâ”€â”€ StageSelectScene.h
â””â”€â”€     â”œâ”€â”€ TitleScene.cpp
â””â”€â”€     â””â”€â”€ TitleScene.h
â”œâ”€â”€ InsideScene/
â””â”€â”€ â”œâ”€â”€ AbstractSceneFactory.cpp
â””â”€â”€ â”œâ”€â”€ AbstractSceneFactory.h
â””â”€â”€ â”œâ”€â”€ BaseScene.cpp
â””â”€â”€ â”œâ”€â”€ BaseScene.h
â””â”€â”€ â”œâ”€â”€ Framework.cpp
â””â”€â”€ â”œâ”€â”€ Framework.h
â””â”€â”€ â”œâ”€â”€ SceneFactory.cpp
â””â”€â”€ â”œâ”€â”€ SceneFactory.h
â””â”€â”€ â”œâ”€â”€ SceneManager.cpp
â””â”€â”€ â””â”€â”€ SceneManager.h
â”œâ”€â”€ Lib/
â”œâ”€â”€ engine/
â””â”€â”€ â”œâ”€â”€ 2d/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RenderTexture.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ RenderTexture.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Sprite.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SpriteCommon.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ SpriteCommon.h
â””â”€â”€ â”œâ”€â”€ 3d/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Model.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelCommon.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelCommon.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ModelManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3D.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3D.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3DCommon.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Object3DCommon.h
â””â”€â”€ â””â”€â”€ â””â”€â”€ SkyBox/
â””â”€â”€ â””â”€â”€     â”œâ”€â”€ SkyBox.cpp
â””â”€â”€ â””â”€â”€     â””â”€â”€ SkyBox.h
â””â”€â”€ â”œâ”€â”€ Audio/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Audio.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ Audio.h
â””â”€â”€ â”œâ”€â”€ base/
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ D3DResourceLeakChecker.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ D3DResourceLeakChecker.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DirectXCommon.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ DirectXCommon.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ImGuiManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ ImGuiManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Input.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Input.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Logger.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ Logger.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SrvManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ SrvManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StringUtility.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ StringUtility.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TextureManager.cpp
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ TextureManager.h
â””â”€â”€ â””â”€â”€ â”œâ”€â”€ WinAPI.cpp
â””â”€â”€ â””â”€â”€ â””â”€â”€ WinAPI.h
â””â”€â”€ â””â”€â”€ math/
â””â”€â”€     â”œâ”€â”€ MakeMatrix.cpp
â””â”€â”€     â”œâ”€â”€ MakeMatrix.h
â””â”€â”€     â””â”€â”€ MyMath.h
â””â”€â”€ main.cpp
================================================================================


============================================================
File Path: CG2_DirectX.vcxproj
============================================================
ï»¿<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup Label="ProjectConfigurations">
    <ProjectConfiguration Include="Debug|x64">
      <Configuration>Debug</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
    <ProjectConfiguration Include="Release|x64">
      <Configuration>Release</Configuration>
      <Platform>x64</Platform>
    </ProjectConfiguration>
  </ItemGroup>
  <PropertyGroup Label="Globals">
    <VCProjectVersion>17.0</VCProjectVersion>
    <Keyword>Win32Proj</Keyword>
    <ProjectGuid>{ea3995fc-4f43-4035-9f99-2e0e860d9b4a}</ProjectGuid>
    <RootNamespace>CG2DirectX</RootNamespace>
    <WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.Default.props" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>true</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'" Label="Configuration">
    <ConfigurationType>Application</ConfigurationType>
    <UseDebugLibraries>false</UseDebugLibraries>
    <PlatformToolset>v143</PlatformToolset>
    <WholeProgramOptimization>true</WholeProgramOptimization>
    <CharacterSet>Unicode</CharacterSet>
  </PropertyGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.props" />
  <ImportGroup Label="ExtensionSettings">
  </ImportGroup>
  <ImportGroup Label="Shared">
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <ImportGroup Label="PropertySheets" Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <Import Project="$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props" Condition="exists('$(UserRootDir)\Microsoft.Cpp.$(Platform).user.props')" Label="LocalAppDataPlatform" />
  </ImportGroup>
  <PropertyGroup Label="UserMacros" />
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <LibraryPath>$(ProjectDir)Lib;$(LibraryPath)</LibraryPath>
    <IntDir>$(SolutionDir)..\generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)..\generated\outputs\$(Configuration)\</OutDir>
    <IncludePath>$(SolutionDir)imgui;$(SolutionDir)DirectXTex;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <PropertyGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <LibraryPath>$(ProjectDir)Lib;$(LibraryPath)</LibraryPath>
    <IntDir>$(SolutionDir)..\generated\obj\$(ProjectName)\$(Configuration)\</IntDir>
    <OutDir>$(SolutionDir)..\generated\outputs\$(Configuration)\</OutDir>
    <IncludePath>$(SolutionDir)imgui;$(SolutionDir)DirectXTex;$(IncludePath)</IncludePath>
  </PropertyGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>_DEBUG;_WINDOWS;USE_IMGUI;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreadedDebug</RuntimeLibrary>
      <TreatWarningAsError>true</TreatWarningAsError>
      <AdditionalIncludeDirectories>C:\Users\k023g\Desktop\GE3\engine\math;$(ProjectDir)engine\2d;$(ProjectDir)engine\3d;$(ProjectDir)engine\audio;$(ProjectDir)engine\base;$(ProjectDir)engine\math;$(ProjectDir)engine\scene;$(ProjectDir)imgui;$(ProjectDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalOptions>/ignore:4049 /ignore:4098 %(AdditionalOptions)</AdditionalOptions>
      <TreatLinkerWarningAsErrors>true</TreatLinkerWarningAsErrors>
      <AdditionalLibraryDirectories>$(SolutionDir)..\generated\outputs\$(Configuration)\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>imgui.lib;%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>copy /y "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxcompiler.dll" "$(TargetDir)dxcompiler.dll" &amp;&amp; copy /y "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxil.dll" "$(TargetDir)dxil.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemDefinitionGroup Condition="'$(Configuration)|$(Platform)'=='Release|x64'">
    <ClCompile>
      <WarningLevel>Level3</WarningLevel>
      <FunctionLevelLinking>true</FunctionLevelLinking>
      <IntrinsicFunctions>true</IntrinsicFunctions>
      <SDLCheck>true</SDLCheck>
      <PreprocessorDefinitions>NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>
      <ConformanceMode>true</ConformanceMode>
      <LanguageStandard>stdcpp20</LanguageStandard>
      <AdditionalOptions>/utf-8 %(AdditionalOptions)</AdditionalOptions>
      <MultiProcessorCompilation>true</MultiProcessorCompilation>
      <RuntimeLibrary>MultiThreaded</RuntimeLibrary>
      <AdditionalIncludeDirectories>C:\Users\k023g\Desktop\GE3\engine\math;$(ProjectDir)engine\2d;$(ProjectDir)engine\3d;$(ProjectDir)engine\audio;$(ProjectDir)engine\base;$(ProjectDir)engine\math;$(ProjectDir)engine\scene;$(ProjectDir)imgui;$(ProjectDir);%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>
    </ClCompile>
    <Link>
      <SubSystem>Windows</SubSystem>
      <EnableCOMDATFolding>true</EnableCOMDATFolding>
      <OptimizeReferences>true</OptimizeReferences>
      <GenerateDebugInformation>true</GenerateDebugInformation>
      <AdditionalLibraryDirectories>$(SolutionDir)..\generated\outputs\$(Configuration)\;%(AdditionalLibraryDirectories)</AdditionalLibraryDirectories>
      <AdditionalDependencies>%(AdditionalDependencies)</AdditionalDependencies>
    </Link>
    <PostBuildEvent>
      <Command>copy /y "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxcompiler.dll" "$(TargetDir)dxcompiler.dll" &amp;&amp; copy /y "$(WindowsSdkDir)bin\$(TargetPlatformVersion)\x64\dxil.dll" "$(TargetDir)dxil.dll"</Command>
    </PostBuildEvent>
  </ItemDefinitionGroup>
  <ItemGroup>
    <ClCompile Include="Game\Camera\CameraController.cpp" />
    <ClCompile Include="Game\Application\BackGround.cpp" />
    <ClCompile Include="Game\Collision\CollisionManager.cpp" />
    <ClCompile Include="Game\Application\Enemy\FlyingEnemy.cpp" />
    <ClCompile Include="Game\Application\Enemy\EnemyBase.cpp" />
    <ClCompile Include="Game\Application\Enemy\EnemyFactory.cpp" />
    <ClCompile Include="Game\Collision\Collider.cpp" />
    <ClCompile Include="Game\Application\Map\CsvLoader.cpp" />
    <ClCompile Include="Game\Application\Block\Block.cpp" />
    <ClCompile Include="Game\Application\ModelList.cpp" />
    <ClCompile Include="Game\Particle\EffectEmitter.cpp" />
    <ClCompile Include="Game\Particle\EffectManager.cpp" />
    <ClCompile Include="InsideScene\AbstractSceneFactory.cpp" />
    <ClCompile Include="engine\Audio\Audio.cpp" />
    <ClCompile Include="InsideScene\BaseScene.cpp" />
    <ClCompile Include="Game\Camera\Camera.cpp" />
    <ClCompile Include="engine\base\D3DResourceLeakChecker.cpp" />
    <ClCompile Include="engine\base\DirectXCommon.cpp" />
    <ClCompile Include="engine\base\Input.cpp" />
    <ClCompile Include="engine\base\Logger.cpp" />
    <ClCompile Include="InsideScene\Framework.cpp" />
    <ClCompile Include="Game\Scene\GamePlayScene.cpp" />
    <ClCompile Include="engine\base\ImGuiManager.cpp" />
    <ClCompile Include="Game\Loader\LevelLoader.cpp" />
    <ClCompile Include="main.cpp" />
    <ClCompile Include="engine\math\MakeMatrix.cpp" />
    <ClCompile Include="engine\3d\Model.cpp" />
    <ClCompile Include="engine\3d\ModelCommon.cpp" />
    <ClCompile Include="engine\3d\ModelManager.cpp" />
    <ClCompile Include="engine\3d\Object3D.cpp" />
    <ClCompile Include="engine\3d\Object3DCommon.cpp" />
    <ClCompile Include="engine\2d\Sprite.cpp" />
    <ClCompile Include="engine\2d\SpriteCommon.cpp" />
    <ClCompile Include="engine\base\StringUtility.cpp" />
    <ClCompile Include="engine\base\TextureManager.cpp" />
    <ClCompile Include="engine\base\WinAPI.cpp" />
    <ClCompile Include="Game\Scene\MyGame.cpp" />
    <ClCompile Include="Game\Particle\ParticleEmitter.cpp" />
    <ClCompile Include="Game\Particle\ParticleManager.cpp" />
    <ClCompile Include="InsideScene\SceneFactory.cpp" />
    <ClCompile Include="InsideScene\SceneManager.cpp" />
    <ClCompile Include="engine\base\SrvManager.cpp" />
    <ClCompile Include="Game\Scene\TitleScene.cpp" />
    <ClCompile Include="Game\Application\StageType.cpp" />
    <ClCompile Include="Game\Application\Enemy\NormalEnemy.cpp" />
    <ClCompile Include="engine\3d\SkyBox\SkyBox.cpp" />
    <ClCompile Include="engine\2d\RenderTexture.cpp" />
    <ClCompile Include="Game\Scene\SceneTransition\SceneTransition.cpp" />
    <ClCompile Include="Game\Application\Player\Player.cpp" />
    <ClCompile Include="Game\Application\Map\Map.cpp" />
    <ClCompile Include="Game\Scene\StageClearScene.cpp" />
    <ClCompile Include="Game\Scene\StageSelectScene.cpp" />
    <ClCompile Include="Game\Scene\SceneSelectGraph\StageSelectGraph.cpp" />
  </ItemGroup>
  <ItemGroup>
    <ClInclude Include="Game\Application\Enemy\EnemyType.h" />
    <ClInclude Include="Game\Camera\CameraController.h" />
    <ClInclude Include="Game\Application\BackGround.h" />
    <ClInclude Include="Game\Collision\CollisionManager.h" />
    <ClInclude Include="Game\Application\Enemy\FlyingEnemy.h" />
    <ClInclude Include="Game\Application\Enemy\EnemyBase.h" />
    <ClInclude Include="Game\Application\Enemy\EnemyFactory.h" />
    <ClInclude Include="Game\Collision\Collider.h" />
    <ClInclude Include="Game\Application\Block\BlockType.h" />
    <ClInclude Include="Game\Application\Map\CsvLoader.h" />
    <ClInclude Include="Game\Application\Block\Block.h" />
    <ClInclude Include="Game\Application\ModelList.h" />
    <ClInclude Include="Game\Particle\EffectEmitter.h" />
    <ClInclude Include="Game\Particle\EffectManager.h" />
    <ClInclude Include="InsideScene\AbstractSceneFactory.h" />
    <ClInclude Include="engine\Audio\Audio.h" />
    <ClInclude Include="InsideScene\BaseScene.h" />
    <ClInclude Include="Game\Camera\Camera.h" />
    <ClInclude Include="engine\base\D3DResourceLeakChecker.h" />
    <ClInclude Include="engine\base\DirectXCommon.h" />
    <ClInclude Include="engine\base\Input.h" />
    <ClInclude Include="engine\base\Logger.h" />
    <ClInclude Include="engine\math\MakeMatrix.h" />
    <ClInclude Include="engine\math\MyMath.h" />
    <ClInclude Include="engine\3d\Model.h" />
    <ClInclude Include="engine\3d\ModelCommon.h" />
    <ClInclude Include="engine\3d\ModelManager.h" />
    <ClInclude Include="engine\3d\Object3D.h" />
    <ClInclude Include="engine\3d\Object3DCommon.h" />
    <ClInclude Include="engine\2d\Sprite.h" />
    <ClInclude Include="engine\2d\SpriteCommon.h" />
    <ClInclude Include="engine\base\StringUtility.h" />
    <ClInclude Include="engine\base\TextureManager.h" />
    <ClInclude Include="engine\base\WinAPI.h" />
    <ClInclude Include="InsideScene\Framework.h" />
    <ClInclude Include="Game\Scene\GamePlayScene.h" />
    <ClInclude Include="engine\base\ImGuiManager.h" />
    <ClInclude Include="Game\Scene\MyGame.h" />
    <ClInclude Include="Game\Particle\ParticleEmitter.h" />
    <ClInclude Include="Game\Particle\ParticleManager.h" />
    <ClInclude Include="InsideScene\SceneFactory.h" />
    <ClInclude Include="InsideScene\SceneManager.h" />
    <ClInclude Include="engine\base\SrvManager.h" />
    <ClInclude Include="Game\Scene\TitleScene.h" />
    <ClInclude Include="Game\Application\StageType.h" />
    <ClInclude Include="Game\Application\Enemy\NormalEnemy.h" />
    <ClInclude Include="Game\Loader\LevelLoader.h" />
    <ClInclude Include="engine\3d\SkyBox\SkyBox.h" />
    <ClInclude Include="engine\2d\RenderTexture.h" />
    <ClInclude Include="Game\Scene\SceneTransition\SceneTransition.h" />
    <ClInclude Include="Game\Application\Player\Player.h" />
    <ClInclude Include="Game\Application\Map\Map.h" />
    <ClInclude Include="Game\Scene\StageClearScene.h" />
    <ClInclude Include="Game\Scene\StageSelectScene.h" />
    <ClInclude Include="Game\Scene\SceneSelectGraph\StageSelectGraph.h" />
  </ItemGroup>
  <ItemGroup>
    <Text Include="externals\imgui\LICENSE.txt" />
  </ItemGroup>
  <ItemGroup>
    <ProjectReference Include="externals\DirectXTex\DirectXTex_Desktop_2022_Win10.vcxproj">
      <Project>{371b9fa9-4c90-4ac6-a123-aced756d6c77}</Project>
    </ProjectReference>
  </ItemGroup>
  <ItemGroup>
    <FxCompile Include="resources\shaders\Object3d.PS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
    <FxCompile Include="resources\shaders\Object3d.VS.hlsl">
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Debug|x64'">true</ExcludedFromBuild>
      <ExcludedFromBuild Condition="'$(Configuration)|$(Platform)'=='Release|x64'">true</ExcludedFromBuild>
    </FxCompile>
  </ItemGroup>
  <Import Project="$(VCTargetsPath)\Microsoft.Cpp.targets" />
  <ImportGroup Label="ExtensionTargets">
  </ImportGroup>
</Project>

============================================================
File Path: CG2_DirectX.vcxproj.filters
============================================================
<?xml version="1.0" encoding="utf-8"?>
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <ItemGroup>
    <FxCompile Include="resources\shaders\Object3d.VS.hlsl">
      <Filter>Shader</Filter>
    </FxCompile>
    <FxCompile Include="resources\shaders\Object3d.PS.hlsl">
      <Filter>Shader</Filter>
    </FxCompile>
  </ItemGroup>
  <ItemGroup>
    <!-- çµ±åˆã•ã‚ŒãŸClCompileã€‚é‡è¤‡æ’é™¤ãƒ»Filterä¿æŒ -->
    <!-- masterãƒ–ãƒ©ãƒ³ãƒã‹ã‚‰è¿½åŠ ã•ã‚ŒãŸåˆ† -->
    <ClCompile Include="main.cpp" />
    <ClCompile Include="InsideScene\AbstractSceneFactory.cpp">
      <Filter>InsideScene</Filter>
    </ClCompile>
    <ClCompile Include="InsideScene\BaseScene.cpp">
      <Filter>InsideScene</Filter>
    </ClCompile>
    <ClCompile Include="engine\Audio\Audio.cpp">
      <Filter>engine\Audio</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Block\Block.cpp">
      <Filter>Game\Application\Block</Filter>
    </ClCompile>
    <ClCompile Include="Game\Camera\Camera.cpp">
      <Filter>Game\Camera</Filter>
    </ClCompile>
    <ClCompile Include="Game\Collision\Collider.cpp">
      <Filter>Game\Collision</Filter>
    </ClCompile>
    <ClCompile Include="Game\Collision\CollisionManager.cpp">
      <Filter>Game\Collision</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Map\CsvLoader.cpp">
      <Filter>Game\Loader</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\D3DResourceLeakChecker.cpp">
      <Filter>engine\bace</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\DirectXCommon.cpp">
      <Filter>engine\bace</Filter>
    </ClCompile>
    <ClCompile Include="Game\Particle\EffectEmitter.cpp">
      <Filter>Game\Particle</Filter>
    </ClCompile>
    <ClCompile Include="Game\Particle\EffectManager.cpp">
      <Filter>Game\Particle</Filter>
    </ClCompile>
    <ClCompile Include="Game\Particle\ParticleEmitter.cpp">
      <Filter>Game\Particle</Filter>
    </ClCompile>
    <ClCompile Include="Game\Particle\ParticleManager.cpp">
      <Filter>Game\Particle</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Enemy\EnemyBase.cpp">
      <Filter>Game\Application\Enemy</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Enemy\EnemyFactory.cpp">
      <Filter>Game\Application\Enemy</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Enemy\FlyingEnemy.cpp">
      <Filter>Game\Application\Enemy</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\Enemy\NormalEnemy.cpp">
      <Filter>Game\Application\Enemy</Filter>
    </ClCompile>
    <ClCompile Include="InsideScene\Framework.cpp">
      <Filter>InsideScene</Filter>
    </ClCompile>
    <ClCompile Include="InsideScene\SceneManager.cpp">
      <Filter>InsideScene</Filter>
    </ClCompile>
    <ClCompile Include="InsideScene\SceneFactory.cpp">
      <Filter>InsideScene</Filter>
    </ClCompile>
    <ClCompile Include="Game\Scene\GamePlayScene.cpp">
      <Filter>Game\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Game\Scene\MyGame.cpp">
      <Filter>Game\Scene</Filter>
    </ClCompile>
    <ClCompile Include="Game\Scene\TitleScene.cpp">
      <Filter>Game\Scene</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\ImGuiManager.cpp">
      <Filter>engine\bace</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\Input.cpp">
      <Filter>engine\bace</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\Logger.cpp">
      <Filter>engine\bace</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\SrvManager.cpp">
      <Filter>engine\bace</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\StringUtility.cpp">
      <Filter>engine\bace</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\TextureManager.cpp">
      <Filter>engine\bace</Filter>
    </ClCompile>
    <ClCompile Include="engine\base\WinAPI.cpp">
      <Filter>engine\bace</Filter>
    </ClCompile>
    <ClCompile Include="Game\Loader\LevelLoader.cpp">
      <Filter>Game\Application\Loader</Filter>
    </ClCompile>
    <ClCompile Include="engine\math\MakeMatrix.cpp">
      <Filter>engine\math</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Object3DCommon.cpp">
      <Filter>engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Model.cpp">
      <Filter>engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\ModelCommon.cpp">
      <Filter>engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\ModelManager.cpp">
      <Filter>engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\Object3D.cpp">
      <Filter>engine\3d</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\ModelList.cpp">
      <Filter>Game</Filter>
    </ClCompile>
    <ClCompile Include="engine\2d\RenderTexture.cpp">
      <Filter>engine\2d</Filter>
    </ClCompile>
    <ClCompile Include="engine\2d\Sprite.cpp">
      <Filter>engine\2d</Filter>
    </ClCompile>
    <ClCompile Include="engine\2d\SpriteCommon.cpp">
      <Filter>engine\2d</Filter>
    </ClCompile>
    <ClCompile Include="engine\3d\SkyBox\SkyBox.cpp">
      <Filter>engine\3d\SkyBox</Filter>
    </ClCompile>
    <ClCompile Include="Game\Application\StageType.cpp">
      <Filter>Game\Application\Map</Filter>
    </ClCompile>
    <ClCompile Include="Game\Scene\SceneTransition\SceneTransition.cpp" />
    <ClCompile Include="Game\Application\BackGround.cpp" />
    <ClCompile Include="Game\Application\Player\Player.cpp" />
    <ClCompile Include="Game\Application\Map\Map.cpp" />
    <ClCompile Include="Game\Camera\CameraController.cpp" />
    <ClCompile Include="Game\Scene\StageClearScene.cpp" />
    <ClCompile Include="Game\Scene\StageSelectScene.cpp" />
    <ClCompile Include="Game\Scene\SceneSelectGraph\StageSelectGraph.cpp" />
  </ItemGroup>
  <!-- ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã®ItemGroupã‚‚åŒæ§˜ã«çµ±åˆã™ã‚‹å¿…è¦ã‚ã‚Šï¼ˆé•·ã„ãŸã‚ã“ã“ã§ã¯çœç•¥ï¼‰ -->
  <ItemGroup>
    <ClInclude Include="InsideScene\AbstractSceneFactory.h">
      <Filter>InsideScene</Filter>
    </ClInclude>
    <ClInclude Include="InsideScene\BaseScene.h">
      <Filter>InsideScene</Filter>
    </ClInclude>
    <ClInclude Include="engine\Audio\Audio.h">
      <Filter>engine\Audio</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Block\Block.h">
      <Filter>Game\Application\Block</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Block\BlockType.h">
      <Filter>Game\Application\Block</Filter>
    </ClInclude>
    <ClInclude Include="Game\Camera\Camera.h">
      <Filter>Game\Camera</Filter>
    </ClInclude>
    <ClInclude Include="Game\Collision\Collider.h">
      <Filter>Game\Collision</Filter>
    </ClInclude>
    <ClInclude Include="Game\Collision\CollisionManager.h">
      <Filter>Game\Collision</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Map\CsvLoader.h">
      <Filter>Game\Loader</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\D3DResourceLeakChecker.h">
      <Filter>engine\bace</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\DirectXCommon.h">
      <Filter>engine\bace</Filter>
    </ClInclude>
    <ClInclude Include="Game\Particle\EffectEmitter.h">
      <Filter>Game\Particle</Filter>
    </ClInclude>
    <ClInclude Include="Game\Particle\EffectManager.h">
      <Filter>Game\Particle</Filter>
    </ClInclude>
    <ClInclude Include="Game\Particle\ParticleEmitter.h">
      <Filter>Game\Particle</Filter>
    </ClInclude>
    <ClInclude Include="Game\Particle\ParticleManager.h">
      <Filter>Game\Particle</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Enemy\EnemyBase.h">
      <Filter>Game\Application\Enemy</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Enemy\EnemyFactory.h">
      <Filter>Game\Application\Enemy</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Enemy\FlyingEnemy.h">
      <Filter>Game\Application\Enemy</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\Enemy\NormalEnemy.h">
      <Filter>Game\Application\Enemy</Filter>
    </ClInclude>
    <ClInclude Include="InsideScene\Framework.h">
      <Filter>InsideScene</Filter>
    </ClInclude>
    <ClInclude Include="InsideScene\SceneManager.h">
      <Filter>InsideScene</Filter>
    </ClInclude>
    <ClInclude Include="InsideScene\SceneFactory.h">
      <Filter>InsideScene</Filter>
    </ClInclude>
    <ClInclude Include="Game\Scene\GamePlayScene.h">
      <Filter>Game\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Game\Scene\MyGame.h">
      <Filter>Game\Scene</Filter>
    </ClInclude>
    <ClInclude Include="Game\Scene\TitleScene.h">
      <Filter>Game\Scene</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\ImGuiManager.h">
      <Filter>engine\bace</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\Input.h">
      <Filter>engine\bace</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\Logger.h">
      <Filter>engine\bace</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\SrvManager.h">
      <Filter>engine\bace</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\StringUtility.h">
      <Filter>engine\bace</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\TextureManager.h">
      <Filter>engine\bace</Filter>
    </ClInclude>
    <ClInclude Include="engine\base\WinAPI.h">
      <Filter>engine\bace</Filter>
    </ClInclude>
    <ClInclude Include="Game\Loader\LevelLoader.h">
      <Filter>Game\Application\Loader</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\MakeMatrix.h">
      <Filter>engine\math</Filter>
    </ClInclude>
    <ClInclude Include="engine\math\MyMath.h">
      <Filter>engine\math</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Model.h">
      <Filter>engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\ModelCommon.h">
      <Filter>engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\ModelManager.h">
      <Filter>engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Object3DCommon.h">
      <Filter>engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\Object3D.h">
      <Filter>engine\3d</Filter>
    </ClInclude>
    <ClInclude Include="engine\2d\RenderTexture.h">
      <Filter>engine\2d</Filter>
    </ClInclude>
    <ClInclude Include="engine\2d\Sprite.h">
      <Filter>engine\2d</Filter>
    </ClInclude>
    <ClInclude Include="engine\2d\SpriteCommon.h">
      <Filter>engine\2d</Filter>
    </ClInclude>
    <ClInclude Include="engine\3d\SkyBox\SkyBox.h">
      <Filter>engine\3d\SkyBox</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\StageType.h">
      <Filter>Game\Application\Map</Filter>
    </ClInclude>
    <ClInclude Include="Game\Application\ModelList.h">
      <Filter>Game</Filter>
    </ClInclude>
    <ClInclude Include="Game\Scene\SceneTransition\SceneTransition.h" />
    <ClInclude Include="Game\Application\BackGround.h" />
    <ClInclude Include="Game\Application\Player\Player.h" />
    <ClInclude Include="Game\Application\Map\Map.h" />
    <ClInclude Include="Game\Camera\CameraController.h" />
    <ClInclude Include="Game\Application\Enemy\EnemyType.h" />
    <ClInclude Include="Game\Scene\StageClearScene.h" />
    <ClInclude Include="Game\Scene\StageSelectScene.h" />
    <ClInclude Include="Game\Scene\SceneSelectGraph\StageSelectGraph.h" />
  </ItemGroup>
  <ItemGroup>
    <Filter Include="engine">
      <UniqueIdentifier>{ee17d952-0bf6-4acb-a07a-097567b033f2}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\2d">
      <UniqueIdentifier>{e6dec0f4-c1ba-4564-b7f8-43a4702b7709}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\3d">
      <UniqueIdentifier>{3d6b7474-81f6-49dd-acae-417a23b1d4ae}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\Audio">
      <UniqueIdentifier>{71dd5415-3c4e-4bb0-b3f9-1bffe38d396b}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\bace">
      <UniqueIdentifier>{0790bce2-65e2-41da-bfa7-48956890b70c}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\math">
      <UniqueIdentifier>{8c514b5d-934d-48fe-adfb-7259d210c0a6}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game">
      <UniqueIdentifier>{248199f7-9718-4f0f-a4fc-d29fbcb161cd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application">
      <UniqueIdentifier>{2b6d880a-23c0-407b-bfe4-d3e390002643}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Camera">
      <UniqueIdentifier>{a511e52b-bcbb-4b6c-9164-4d31d4b5270b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Collision">
      <UniqueIdentifier>{434365a8-cfd3-4303-9644-1d8cc1e7eefd}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Loader">
      <UniqueIdentifier>{b43b2173-3150-4925-a8f5-73e7c339636f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Particle">
      <UniqueIdentifier>{712eb409-80f7-4d34-b7d2-020031345795}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Scene">
      <UniqueIdentifier>{c6eecef6-e7d8-4050-a866-f31dd4a028a8}</UniqueIdentifier>
    </Filter>
    <Filter Include="InsideScene">
      <UniqueIdentifier>{90e59181-f685-48db-808d-73212c0b33ea}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application\Enemy">
      <UniqueIdentifier>{431302d6-9528-409f-a6cc-c4076693d624}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application\Block">
      <UniqueIdentifier>{9f952b4e-216f-4d0e-9d9b-e0526d0f7dd8}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application\Player">
      <UniqueIdentifier>{a5f28842-bbb1-4ea9-9cb7-621672d64d7f}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application\Loader">
      <UniqueIdentifier>{956e0651-fb05-4ab0-bbd3-e6c26087402f}</UniqueIdentifier>
    </Filter>
    <Filter Include="engine\3d\SkyBox">
      <UniqueIdentifier>{6d5cf266-090d-47f2-8455-e452b0e5657b}</UniqueIdentifier>
    </Filter>
    <Filter Include="Game\Application\Map">
      <UniqueIdentifier>{5250f676-f79a-456a-bd60-fd967b81f381}</UniqueIdentifier>
    </Filter>
    <Filter Include="Shader">
      <UniqueIdentifier>{588ada5e-8e2c-43c1-8997-4bcf269d6a66}</UniqueIdentifier>
    </Filter>
  </ItemGroup>
  <ItemGroup>
    <Text Include="externals\imgui\LICENSE.txt">
      <Filter>Game\Application</Filter>
    </Text>
  </ItemGroup>
</Project>

============================================================
File Path: Game/Application/BackGround.cpp
============================================================
#include "BackGround.h"
#ifdef USE_IMGUI
#include "engine/base/ImGuiManager.h"
#endif
void BackGround::Initialize()
{
	titleBackGround3 = std::make_unique<Object3D>();
	titleBackGround3->Initialize();
	titleBackGround3->SetModel("Back3Reverse.obj");
	titleBackGround3Transform = {
		{ 30.0f,50.0f,1.0f },
		{ 0.0f,0.0f,0.0f },
		{ 7.5f,-4.0f,200.0f }
	};
	titleBackGround3->SetTransform(titleBackGround3Transform);

	// å³ã«ç¹‹ã’ã‚‹
	titleBackGround3_2 = std::make_unique<Object3D>();
	titleBackGround3_2->Initialize();
	titleBackGround3_2->SetModel("Back3.obj");
	titleBackGround3_2Transform = {
		{ 30.0f,50.0f,1.0f },
		{ 0.0f,0.0f,0.0f },
		{ 170.0f,-4.0f,200.0f }
	};
	titleBackGround3_2->SetTransform(titleBackGround3_2Transform);




	titleBackGround2 = std::make_unique<Object3D>();
	titleBackGround2->Initialize();
	titleBackGround2->SetModel("back2.obj");
	titleBackGround2Transform = {
		{ 30.0f,60.0f,1.0f },
		{ 0.0f,0.0f,0.0f },
		{ 7.5f,-4.0f,150.0f }
	};

	titleBackGround2->SetTransform(titleBackGround2Transform);

	titleBackGround2_2 = std::make_unique<Object3D>();
	titleBackGround2_2->Initialize();
	titleBackGround2_2->SetModel("Back2Reverse.obj");
	titleBackGround2_2Transform = {
		{ 30.0f,60.0f,1.0f },
		{ 0.0f,0.0f,0.0f },
		{ 180.0f,-4.0f,150.0f }
	};
	titleBackGround2_2->SetTransform(titleBackGround2_2Transform);
	titleBackGround2_3 = std::make_unique<Object3D>();
	titleBackGround2_3->Initialize();
	titleBackGround2_3->SetModel("back2.obj");
	titleBackGround2_3Transform = {
		{ 30.0f,60.0f,1.0f },
		{ 0.0f,-0.0f,0.0f },
		{ 350.0f,-4.0f,150.0f }
	};
	titleBackGround2_3->SetTransform(titleBackGround2_3Transform);



	titleBackGround1 = std::make_unique<Object3D>();
	titleBackGround1->Initialize();
	titleBackGround1->SetModel("back1.obj");
	titleBackGround1Transform = {
		{ 1.0f,20.0f,10.0f },
		{ 0.0f,-1.5f,0.0f },
		{ 7.5f,-2.0f,50.0f }
	};
	titleBackGround1->SetTransform(titleBackGround1Transform);

	titleBackGround1_2 = std::make_unique<Object3D>();
	titleBackGround1_2->Initialize();
	titleBackGround1_2->SetModel("back1.obj");
	titleBackGround1_2Transform = {
		{ 1.0f,20.0f,10.0f },
		{ 0.0f,1.5f,0.0f },
		{ 65,-2.0f,50.0f }
	};
	titleBackGround1_2->SetTransform(titleBackGround1_2Transform);
	titleBackGround1_3 = std::make_unique<Object3D>();
	titleBackGround1_3->Initialize();
	titleBackGround1_3->SetModel("back1.obj");
	titleBackGround1_3Transform = {
		{ 1.0f,20.0f,10.0f },
		{ 0.0f,-1.5f,0.0f },
		{ 120,-2.0f,50.0f }
	};
	titleBackGround1_3->SetTransform(titleBackGround1_3Transform);

	titleBackGround1_4 = std::make_unique<Object3D>();
	titleBackGround1_4->Initialize();
	titleBackGround1_4->SetModel("back1.obj");
	titleBackGround1_4Transform = {
		{ 1.0f,20.0f,10.0f },
		{ 0.0f,1.5f,0.0f },
		{ 178,-2.0f,50.0f }
	};
	titleBackGround1_4->SetTransform(titleBackGround1_4Transform);

	skyBack = std::make_unique<Object3D>();
	skyBack->Initialize();
	skyBack->SetModel("BackSky.obj");
	skyBackTransform = {
		{ 400.0f,100.0f,1.0f },
		{ 0.0f,0.0f, 0.0f },
		{ 7.5f,0.0f,250.0f }
	};
	skyBack->SetTransform(skyBackTransform);

	// è¶³å ´ã€€åœŸ
	soil = std::make_unique<Object3D>();
	soil->Initialize();
	soil->SetModel("soil.obj");
	soilTransform = {
		{ 7.0f,1.0f,1.0f },
		{ 0.0f,0.0f,0.0f },
		{ 0.0f,-8.6f,20.0f }
	};
	soil->SetTransform(soilTransform);
}


void BackGround::Update()
{
	skyBack->Update();

	// èƒŒæ™¯
	// å°‘ã—ã¥ã¤å·¦ã«æµã™ æ›´æ–°
	

	titleBackGround3->Update();
	titleBackGround3_2->Update();
	// 2
	//titleBackGround2Transform.translate.x -= 0.05f;
	//titleBackGround2_2Transform.translate.x -= 0.05f;
	//titleBackGround2_3Transform.translate.x -= 0.05f;
	//titleBackGround2->SetTransform(titleBackGround2Transform);
	//titleBackGround2_2->SetTransform(titleBackGround2_2Transform);
	//titleBackGround2_3->SetTransform(titleBackGround2_3Transform);
	titleBackGround2->Update();
	titleBackGround2_2->Update();
	titleBackGround2_3->Update();
	// 1

	titleBackGround1->Update();
	titleBackGround1_2->Update();
	titleBackGround1_3->Update();
	titleBackGround1_4->Update();
	soil->Update();

	DrawImgui();
}


void BackGround::Draw()
{
	skyBack->Draw();
	titleBackGround3->Draw();
	titleBackGround3_2->Draw();
	titleBackGround2->Draw();
	titleBackGround2_2->Draw();
	titleBackGround2_3->Draw();
	titleBackGround1->Draw();
	titleBackGround1_2->Draw();
	titleBackGround1_3->Draw();
	titleBackGround1_4->Draw();
	soil->Draw();
}

void BackGround::DrawImgui()
{
	// ImGuiã§å„èƒŒæ™¯ã®ä½ç½®èª¿æ•´

#ifdef USE_IMGUI

	// è¨­å®šã¨ã—ã¦ä¿å­˜
	ImGui::Begin("BackGround Transform");
	// èƒŒæ™¯3 srt
	Transform backGround3Transform = titleBackGround3->GetTransform();
	ImGui::DragFloat3("titleBackGround3 Scale", &backGround3Transform.scale.x, 0.1f);
	ImGui::DragFloat3("titleBackGround3 Rotate", &backGround3Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("titleBackGround3 Translate", &backGround3Transform.translate.x, 0.1f);
	titleBackGround3->SetTransform(backGround3Transform);


	ImGui::DragFloat3("titleBackGround3_2 Translate", &titleBackGround3_2Transform.translate.x, 0.1f);
	ImGui::DragFloat3("titleBackGround3_2 Rotate", &titleBackGround3_2Transform.rotate.x, 0.1f);
	titleBackGround3_2->SetTransform(titleBackGround3_2Transform);
	ImGui::DragFloat3("titleBackGround2 Translate", &titleBackGround2Transform.translate.x, 0.1f);
	titleBackGround2->SetTransform(titleBackGround2Transform);


	// ã‚¹ã‚«ã‚¤ãƒãƒƒã‚¯ã€€
	ImGui::DragFloat3("SkyBack Translate", &skyBackTransform.translate.x, 0.1f);
	skyBack->SetTransform(skyBackTransform);
	// rotate
	ImGui::DragFloat3("SkyBack Rotate", &skyBackTransform.rotate.x, 0.1f);
	skyBack->SetTransform(skyBackTransform);
	// scale
	ImGui::DragFloat3("SkyBack Scale", &skyBackTransform.scale.x, 0.1f);
	skyBack->SetTransform(skyBackTransform);
	ImGui::End();
	


#endif


}


============================================================
File Path: Game/Application/BackGround.h
============================================================
#pragma once
#include "engine/3d/Object3D.h"
#include "engine/math/MyMath.h"
#include <memory>
class BackGround
{
public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

	void DrawImgui();
private:
	std::unique_ptr<Object3D> titleBackGround3;
	Transform titleBackGround3Transform;

	std::unique_ptr<Object3D> titleBackGround3_2;
	Transform titleBackGround3_2Transform;



	std::unique_ptr<Object3D> titleBackGround2;
	Transform titleBackGround2Transform;

	std::unique_ptr<Object3D> titleBackGround2_2;
	Transform titleBackGround2_2Transform;

	std::unique_ptr<Object3D> titleBackGround2_3;
	Transform titleBackGround2_3Transform;

	std::unique_ptr<Object3D> titleBackGround1;
	Transform titleBackGround1Transform;

	std::unique_ptr<Object3D> titleBackGround1_2;
	Transform titleBackGround1_2Transform;

	std::unique_ptr<Object3D> titleBackGround1_3;
	Transform titleBackGround1_3Transform;

	std::unique_ptr<Object3D> titleBackGround1_4;
	Transform titleBackGround1_4Transform;


	std::unique_ptr<Object3D> skyBack;
	Transform skyBackTransform;

	// è¶³å ´ã€€åœŸ
	std::unique_ptr<Object3D> soil;
	Transform soilTransform;
};



============================================================
File Path: Game/Application/Block/Block.cpp
============================================================
#include "Block.h"
#include "engine/3d/ModelManager.h"

void Block::OnCollision(Collider* other)
{

}


void Block::Initialize(BlockType blockType, Vector3 position) {

	/// ãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–
	this->blockType = blockType;
	blockModel = std::make_unique<Object3D>();
	blockModel->Initialize();
	transform = {
		// Scale
		{1.0f, 1.0f, 1.0f},
		// Rotate
		{0.0f, 0.0f, 0.0f},
		// Translate
		position
	};


	switch (this->blockType) {
	case BlockType::Air:
		break;
	case BlockType::GrassBlock:
		blockModel->SetModel("Grass.obj");
		break;
	case BlockType::SoilBlock:
		blockModel->SetModel("soil.obj");
		break;
	case BlockType::breakBlock:
		blockModel->SetModel("BreakBlock.obj");
		break;
	case BlockType::moveBlock:
		blockModel->SetModel("moveBlock.obj");
		break;
	case BlockType::sandBlock:
		blockModel->SetModel("sand.obj");
		break;
	case BlockType::kGoalUp:
		blockModel->SetModel("GoalUp.obj");
		break;
	case BlockType::kGoalDown:
		blockModel->SetModel("GoalDown.obj");
		break;
	case BlockType::Unbreakable:
		blockModel->SetModel("Unbreakable.obj");
		break;
	default:
		blockModel->SetModel("null.obj");
		break;
	}
	blockModel->SetTransform(transform);


}



void Block::Update() {
	if (blockType == BlockType::Air || !isAlive_) return;
	// ç§»å‹•ãƒ–ãƒ­ãƒƒã‚¯ã®å‡¦ç†
	if (blockType == BlockType::moveBlock) {
		if (moveRight_) {
			moveTime_ += moveSpeed_;
			if (moveTime_ > 1.0f) {
				moveTime_ = 1.0f;
				moveRight_ = false; // å³ç«¯ã«åˆ°é”ã—ãŸã‚‰å·¦ã¸
			}
		} else {
			moveTime_ -= moveSpeed_;
			if (moveTime_ < 0.0f) {
				moveTime_ = 0.0f;
				moveRight_ = true; // å·¦ç«¯ã«åˆ°é”ã—ãŸã‚‰å³ã¸
			}
		}

		// ---- ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é–¢æ•°ï¼ˆeaseInOutSineï¼‰ ----
		// 0ï½1 â†’ 0ï½1ã¸æ»‘ã‚‰ã‹ã«è£œé–“
		float eased = 0.5f - 0.5f * cosf(moveTime_ * 3.14159f);

		// -range ï½ +range ã®ç¯„å›²ã§å¾€å¾©
		transform.translate.x = (eased * 2.0f - 1.0f) * moveRange_;

		// ãƒ¢ãƒ‡ãƒ«ã«åæ˜ 
		blockModel->SetTransform(transform);
	}
	blockModel->Update();
}

void Block::Draw() {
	// ãƒ–ãƒ­ãƒƒã‚¯ã®æç”» / æç”»å¯¾è±¡ãŒç„¡ã„å ´åˆã¨å£Šã‚Œã¦ã„ã‚‹å ´åˆã¯æç”»ã—ãªã„
	if (blockType == BlockType::Air || !isAlive_) return;
	blockModel->Draw();
}

Block* Block::CreateBlock(BlockType blockType, Vector3 position)
{
	// ãƒ–ãƒ­ãƒƒã‚¯ã®ç”Ÿæˆ
	Block* newBlock = new Block();
	// åˆæœŸåŒ–
	newBlock->Initialize(blockType, position);
	// ç”Ÿæˆã—ãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿”ã™
	return newBlock;
}


============================================================
File Path: Game/Application/Block/Block.h
============================================================
#pragma once
#include "engine/3d/Object3D.h"
#include "BlockType.h"
#include "Game/Collision/Collider.h"
#include <memory>
class Block : public Collider
{
public: // åˆ¤å®š
	///
	///
	/// 
	void OnCollision(Collider* other) override;

	/// <summary>
	/// AABBã‚’å–å¾—
	/// </summary>
	/// <returns>AABB</returns>
	AABB GetAABB() const override {
		const Vector3 half = transform.scale * 0.5f; // â† ã“ã“ã‚’ *0.5f ã«
		return { transform.translate - half, transform.translate + half };
	}

	/// <summary>
	/// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®ç¨®é¡ã‚’å–å¾—
	/// </summary>
	Type GetType() const override { return Type::Static; }

public:
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize(BlockType blockType, Vector3 position);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®ç”Ÿæˆ
	/// </summary>
	static Block* CreateBlock(BlockType blockType, Vector3 position);

public:	// Setter / Getter
	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®SRTã‚’å–å¾—
	/// </summary>
	/// <returns>ãƒ–ãƒ­ãƒƒã‚¯ã®SRT</returns>
	const Transform& GetTransform() const { return transform; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®ç¨®é¡ã‚’å–å¾—
	/// </summary>
	/// <returns>ãƒ–ãƒ­ãƒƒã‚¯ã®ç¨®é¡</returns>
	BlockType GetBlockType() const { return blockType; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®Scaleã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	void SetScale(const Vector3& scale) { transform.scale = scale; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®Rotateã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	void SetRotate(const Vector3& rotate) { transform.rotate = rotate; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®Positionã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	void SetTranslate(const Vector3& position) { transform.translate = position; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®SRTã‚’ã‚»ãƒƒãƒˆ
	/// </summary>
	void SetTransform(const Transform& transform) { this->transform = transform; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ãŒå£Šã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹
	/// </summary>
	bool GetAliveBlock() const { return isAlive_; }

	/// <summary>
	/// ãƒ–ãƒ­ãƒƒã‚¯ã‚’å£Šã™
	/// </summary>
	void SetBroken() { isAlive_ = false; }


private:

	/// ãƒ–ãƒ­ãƒƒã‚¯ãƒ¢ãƒ‡ãƒ«
	std::unique_ptr<Object3D> blockModel;
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®ä½ç½®
	Transform transform;
	/// è¡¨ç¤ºã™ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã®ç¨®é¡
	BlockType blockType;
	/// ãƒ–ãƒ­ãƒƒã‚¯ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼
	AABB aabb;

	// ç§»å‹•ãƒ–ãƒ­ãƒƒã‚¯ç”¨å¤‰æ•°
	float moveRange_ = 3.0f;     // ç§»å‹•ç¯„å›²
	float moveSpeed_ = 0.01f;    // åŸºæœ¬é€Ÿåº¦
	float moveTime_ = 0.0f;      // æ™‚é–“ã‚«ã‚¦ãƒ³ã‚¿
	bool moveRight_ = true;      // ç¾åœ¨ã®ç§»å‹•æ–¹å‘ï¼ˆtrue:å³ / false:å·¦ï¼‰

	// ãƒ–ãƒ­ãƒƒã‚¯ãŒå£Šã‚Œã¦ã„ã‚‹ã‹ã©ã†ã‹
	bool isAlive_ = true;    

};



============================================================
File Path: Game/Application/Block/BlockType.h
============================================================
#pragma once

enum class BlockType
{
	Air = 0,
	GrassBlock = 1,
	SoilBlock = 2,
	kGoalUp = 3,
	kGoalDown = 4,
	breakBlock = 5,
	moveBlock = 6,
	sandBlock = 7,
	Unbreakable = 8,
	// ç¯„å›²æ¤œç´¢ã®æœ€çµ‚å€¤
	/// æ¤œç´¢ã‚’è¡Œã†éš›ã«Countã‚’æŒ‡å®šã™ã‚‹ã“ã¨ã§ç¯„å›²æ¤œç´¢ã‚’å¯èƒ½ã«ã§ãã‚‹
	Count,	
};




// æ–°ã—ã„ãƒ–ãƒ­ãƒƒã‚¯ã‚’è¿½åŠ ã™ã‚‹ã¨ãã¯ã€ä¸‹ã®ãƒªã‚¹ãƒˆã‚’ä¸Šã‹ã‚‰é †ã«ãƒã‚§ãƒƒã‚¯ã™ã‚Œã°OKã§ã™ã€‚
//
// BlockType ã«è¿½åŠ 
//
// enum class BlockType ã« Count ã®å‰ã§è¿½åŠ 
//
//	æ—¢å­˜ã®æ•°å€¤ã¯å¤‰ãˆãªã„
//
//	ImGui è¡¨ç¤ºåã‚’è¿½åŠ 
//
//	blockTypeNames[] ã« "NewBlockName" ã‚’è¿½åŠ 
//
//	ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ enum ã®å€¤ãŒå¯¾å¿œã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèª
//
//	è‰²ãƒ†ãƒ¼ãƒ–ãƒ«ã«è¿½åŠ 
//
//	GetBlockColorByType(BlockType) ã® switch ã« case ã‚’è¿½åŠ 
//
//	ã‚°ãƒªãƒƒãƒ‰ãƒ»ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã®è‰²ã¯ã“ã“ã‚’ä½¿ã†ã‚ˆã†ã«çµ±ä¸€ã—ã¦ãŠã
//
//	ãƒãƒƒãƒ—ç”Ÿæˆ / è¦‹ãŸç›®
//
//	GenerateMapBlock() ãªã©ã®ãƒ–ãƒ­ãƒƒã‚¯ç”Ÿæˆå‡¦ç†ã® switch ã« case ã‚’è¿½åŠ 
//
//	æŒ™å‹• / å½“ãŸã‚Šåˆ¤å®šï¼ˆå¿…è¦ãªã‚‰ï¼‰
//
//	ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚„ã‚®ãƒŸãƒƒã‚¯ã®åˆ¤å®šã§ switch (blockType) ç­‰ã« case ã‚’è¿½åŠ 
//
//	CSVã®äº’æ›æ€§ãƒã‚§ãƒƒã‚¯
//
//	æ—¢å­˜ã® CSV ã‚’èª­ã¿è¾¼ã‚“ã§æƒ³å®šé€šã‚Šã®ãƒãƒƒãƒ—ã‹ç¢ºèª
//
//	ãŠã‹ã—ã‹ã£ãŸã‚‰ enum ã®é †ç•ªã‚„å€¤ã‚’ã„ã˜ã£ã¦ã„ãªã„ã‹ç¢ºèª

============================================================
File Path: Game/Application/Enemy/EnemyBase.cpp
============================================================
#include "EnemyBase.h"




============================================================
File Path: Game/Application/Enemy/EnemyBase.h
============================================================
#pragma once
#include "engine/math/MyMath.h"
#include "engine/3d/Object3D.h"
#include "Game/Collision/Collider.h"
struct Stats {
	/// åº§æ¨™
	Transform transform;
	/// ç”Ÿå­˜ãƒ•ãƒ©ã‚°
	bool isAlive = true;
	/// é€Ÿåº¦
	Vector3 velocity;
	/// ä½“åŠ›
	uint32_t health;
	/// æ”»æ’ƒåŠ›
	int32_t attackPower;
};

class EnemyBase : public Collider
{

public:
	/// <summary>
	/// Enemy ã‚¯ãƒ©ã‚¹ã®ä»®æƒ³ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã€‚æ´¾ç”Ÿã‚¯ãƒ©ã‚¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒæ­£ã—ãç ´æ£„ã•ã‚Œã‚‹ã“ã¨ã‚’ä¿è¨¼
	/// </summary>
	virtual ~EnemyBase() = default;

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®åˆæœŸåŒ–
	/// </summary>
	virtual void Initialize() = 0;

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®æ›´æ–°å‡¦ç†
	/// </summary>
	virtual void Update() = 0;

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®æç”»å‡¦ç†
	/// </summary>
	virtual void Draw() = 0;

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®å‹•ä½œå‡¦ç†
	/// </summary>
	virtual void Move() = 0;

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®æ”»æ’ƒå‡¦ç†
	/// </summary>
	virtual void Action() = 0;

	/// Collider ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®å®Ÿè£…
	Type GetType()const override { return Type::Enemy; }

	/// AABBã®å–å¾—
	AABB GetAABB() const override {
		const auto& t = stats.transform;
		return { t.translate - t.scale * 0.5f,
				t.translate + t.scale * 0.5f };
	}

	void OnCollision(Collider* other) override {
		// è¡çªæ™‚ã®å‡¦ç†ã‚’å®Ÿè£…
		if (other->GetType() == Type::Player) {
			if (stats.health <= 0) {
				stats.isAlive = false; // ã‚¨ãƒãƒŸãƒ¼ãŒæ­»äº¡
			}
		}
	}

	/// ã‚¨ãƒãƒŸãƒ¼ã®ç”Ÿå­˜ãƒ•ãƒ©ã‚°è¨­å®š/å–å¾—
	bool IsAlive() const { return stats.isAlive; }


	/// ã‚¨ãƒãƒŸãƒ¼ã®ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ è¨­å®š/å–å¾—
	virtual void SetTransform(const Transform& transform) { stats.transform = transform; }
	virtual Transform GetTransform() const { return stats.transform; }
	/// ã‚¨ãƒãƒŸãƒ¼ã®SRTè¨­å®š/å–å¾—
	virtual void SetScale(const Vector3& scale) { stats.transform.scale = scale; }
	virtual Vector3 GetScale() const { return stats.transform.scale; }
	virtual void SetRotate(const Vector3& rotate) { stats.transform.rotate = rotate; }
	virtual Vector3 GetRotate() const { return stats.transform.rotate; }
	virtual void SetTranslate(const Vector3& translate) { stats.transform.translate = translate; }
	virtual Vector3 GetTranslate() const { return stats.transform.translate; }

protected:
	/// ã‚¨ãƒãƒŸãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	Stats stats;
	/// ã‚¨ãƒãƒŸãƒ¼ã®3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3D> model;
};



============================================================
File Path: Game/Application/Enemy/EnemyFactory.cpp
============================================================
#include "EnemyFactory.h"
#include <Logger.h>

std::unique_ptr<EnemyBase> EnemyFactory::CreateEnemy(const std::string& type)
{
	if(type == "NormalEnemy")
	{
		auto enemy = std::make_unique<NormalEnemy>();
		return enemy;
	}
	else if(type == "FlyingEnemy")
	{
		auto enemy = std::make_unique<FlyingEnemy>();
		return enemy;
	}
	Logger::Log("\nEnemy generation failed\nNo matching data found\n		or\nSpelling error\n\n");
	return nullptr; // å¯¾å¿œã™ã‚‹ã‚¨ãƒãƒŸãƒ¼ãŒãªã„å ´åˆã¯nullptrã‚’è¿”ã™
}


============================================================
File Path: Game/Application/Enemy/EnemyFactory.h
============================================================
#pragma once
#include <memory>

/// ã‚¨ãƒãƒŸãƒ¼å…¨ã¦ã®ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã‚¯ãƒ©ã‚¹
#include "EnemyBase.h"
#include "NormalEnemy.h"
#include "FlyingEnemy.h"
class EnemyFactory
{
public:
	/// <summary>
	///  ã‚¨ãƒãƒŸãƒ¼ã‚’ç”Ÿæˆã™ã‚‹ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰
	/// </summary>
	/// <param name="type"></param>
	/// <returns></returns>
	static std::unique_ptr<EnemyBase> CreateEnemy(const std::string& type);

};



============================================================
File Path: Game/Application/Enemy/EnemyType.h
============================================================
#pragma once


enum class EnemyType {

	None = 0,
	NormalEnemy = 1,
	FlyingEnemy = 2,
};

============================================================
File Path: Game/Application/Enemy/FlyingEnemy.cpp
============================================================
#include "FlyingEnemy.h"

void FlyingEnemy::Initialize()
{
	/// @ä»®ã‚¹ã‚¿ãƒƒãƒ„
	stats = {
		// scale
		{{1.0f, 1.0f, 1.0f},
		// Rotate
		{0.0f, 0.0f, 0.0f},
		// Translate
		//{5.0f, -3.0f, 0.0f},
		},
		// ç”Ÿå­˜ãƒ•ãƒ©ã‚°
		true,
		// é€Ÿåº¦
		{0.1f, 0.1f, 0.0f},
		// ä½“åŠ›
		1,
		// æ”»æ’ƒåŠ›
		1
	};
	
	timer = 0.0f;
	

	/// Object3Dã®åˆæœŸåŒ–
	model = std::make_unique<Object3D>();
	model->Initialize();
	/// ãƒ¢ãƒ‡ãƒ«ã®è¨­å®š
	model->SetModel("Tentativeenemy.obj");
	/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®è¨­å®š
	model->SetTransform(stats.transform);

	baseY = stats.transform.translate.y;
}


void FlyingEnemy::Update()
{
	if (stats.isAlive) {
		/// æŒ™å‹•å‡¦ç†
		Move();
		/// æ”»æ’ƒå‡¦ç†
		Action();
		/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®åæ˜ 
		model->SetTransform(stats.transform);
		/// ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
		model->Update();
	}
}

void FlyingEnemy::Draw()
{
	if (stats.isAlive) {
		/// ãƒ¢ãƒ‡ãƒ«ã®æç”»
		model->Draw();
	}
}

void FlyingEnemy::Move()
{
	/// ä¸Šä¸‹ç§»å‹•é‡
	const float amplitude = 3.0f;   
	const float frequency = 0.01f;  

	timer += frequency; 
	float offsetY = std::sin(timer * 2.0f * 3.14159265f) * amplitude;

	stats.transform.translate.y = baseY + offsetY;

	model->SetTransform(stats.transform);
	
}

void FlyingEnemy::Action()
{
	
}



============================================================
File Path: Game/Application/Enemy/FlyingEnemy.h
============================================================
#pragma once
#include "EnemyBase.h"
/// åŸºåº•ã‚¯ãƒ©ã‚¹<BaseEnemy>ã‚’ç¶™æ‰¿
class FlyingEnemy :
    public EnemyBase
{
    public:
    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize() override;
    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update() override;
    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    void Draw() override;
    /// <summary>
    /// å‹•ä½œå‡¦ç†
    /// </summary>
    void Move() override;
    /// <summary>
    /// æ”»æ’ƒå‡¦ç†
    /// </summary>
	void Action() override;


private:
    /// å…ƒã®é«˜ã•ï¼ˆåˆæœŸä½ç½®Yï¼‰
    float baseY;         
    float timer = 0.0f;


    


};



============================================================
File Path: Game/Application/Enemy/NormalEnemy.cpp
============================================================
#include "NormalEnemy.h"

void NormalEnemy::Initialize()
{
	/// @ä»®ã‚¹ã‚¿ãƒƒãƒ„
	stats = {
		// scale
		{{1.0f, 1.0f, 1.0f},
		// Rotate
		{0.0f, 0.0f, 0.0f},
		// Translate
		{4.0f, -3.0f, 20.0f}
		},
		// ç”Ÿå­˜ãƒ•ãƒ©ã‚°
		true,
		// é€Ÿåº¦
		{0.1f, 0.1f, 0.0f},
		// ä½“åŠ›
		1,
		// æ”»æ’ƒåŠ›
		1
	};

	/// Object3Dã®åˆæœŸåŒ–
	model = std::make_unique<Object3D>();
	model->Initialize();
	/// ãƒ¢ãƒ‡ãƒ«ã®è¨­å®š
	model->SetModel("Tentativeenemy.obj");
	/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®è¨­å®š
	model->SetTransform(stats.transform);
}

void NormalEnemy::Update()
{
	if (stats.isAlive) {
		/// æŒ™å‹•å‡¦ç†
		Move();
		/// æ”»æ’ƒå‡¦ç†
		Action();
		/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®åæ˜ 
		model->SetTransform(stats.transform);
		/// ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
		model->Update();
	}
	
}

void NormalEnemy::Draw()
{
	if (stats.isAlive) {
		/// ãƒ¢ãƒ‡ãƒ«ã®æç”»
		model->Draw();
	}
}

void NormalEnemy::Move()
{
}

void NormalEnemy::Action()
{
}


============================================================
File Path: Game/Application/Enemy/NormalEnemy.h
============================================================
#pragma once
#include "EnemyBase.h"
/// åŸºåº•ã‚¯ãƒ©ã‚¹<Bas8eEnemy>ã‚’ç¶™æ‰¿
class NormalEnemy :
	public EnemyBase
{
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize() override;
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update() override;
	/// <summary>
	///  æç”»å‡¦ç†
	/// </summary>
	void Draw() override;
	/// <summary>
	/// å‹•ä½œå‡¦ç†
	/// </summary>
	void Move() override;
	/// <summary>
	/// æ”»æ’ƒå‡¦ç†
	/// </summary>
	void Action() override;



};



============================================================
File Path: Game/Application/Map/CsvLoader.cpp
============================================================
#include "CsvLoader.h"
#include "Game/Application/Block/Block.h"

const std::string CsvLoader::frontFilePath = "resources/MapData/";
const std::string CsvLoader::extensionCsv_ = ".csv";



std::vector<std::vector<int>> CsvLoader::LoadMapInt(const std::string& filePath)
{
	// èª­ã¿è¾¼ã‚“ã ã‚‚ã®ã‚’æ ¼ç´ã™ã‚‹å¤‰æ•°
	std::vector<std::vector<int>> mapData;
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	std::ifstream file(frontFilePath+filePath);

	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸå ´åˆã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
	if (!file.is_open()) {
		throw std::runtime_error("CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ã¾ã›ã‚“: " + filePath);
	}
	// 1è¡Œãšã¤èª­ã¿è¾¼ã‚€
	std::string line;
	while (std::getline(file, line)) {
		std::vector<int> row;
		std::stringstream ss(line);
		std::string value;

		while (std::getline(ss, value, ',')) {

			// æ–‡å­—åˆ—ã‚’æ•´æ•°ã«å¤‰æ›
			row.push_back(std::stoi(value));

		}
		mapData.push_back(row);
	}
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã‚‹
	file.close();
	// èª­ã¿è¾¼ã‚“ã ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
	return mapData;

}

std::vector<std::vector<BlockType>> CsvLoader::LoadMapBlockType(const std::string& filePath)
{
	// èª­ã¿è¾¼ã‚“ã ç‰©ã‚’æ ¼ç´ã™ã‚‹å¤‰æ•°	
	std::vector<std::vector<BlockType>> mapData;
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	std::ifstream file(frontFilePath + filePath + extensionCsv_);
	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸå ´åˆã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
	if (!file.is_open()) {
		throw std::runtime_error("CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ã¾ã›ã‚“: " + filePath);
	}
	// 1è¡Œãšã¤èª­ã¿è¾¼ã‚€
	std::string line;
	// å„è¡Œã‚’ã‚«ãƒ³ãƒã§åŒºåˆ‡ã£ã¦å‡¦ç†
	while (std::getline(file, line)) {
		std::vector<BlockType> row;
		std::stringstream ss(line);
		std::string value;
		// ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸå„å€¤ã‚’å‡¦ç†
		while (std::getline(ss, value, ',')) {
			// æ–‡å­—åˆ—ã‚’intã«å¤‰æ›ã—ã€ãã‚Œã‚’BlockTypeã¸å¤‰æ›
			int intVal = std::stoi(value);
			BlockType type = static_cast<BlockType>(intVal);
			row.push_back(type);
		}
		// è¡Œã‚’mapDataã«è¿½åŠ 
		mapData.push_back(row);
	}

	file.close();
	return mapData;
}

std::vector<std::vector<EnemyType>> CsvLoader::LoadMapEnemyType(const std::string& filePath)
{
	// èª­ã¿è¾¼ã‚“ã ç‰©ã‚’æ ¼ç´ã™ã‚‹å¤‰æ•°	
	std::vector<std::vector<EnemyType>> enemyData;
	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	std::ifstream file(frontFilePath + filePath + extensionCsv_);
	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸå ´åˆã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
	if (!file.is_open()) {
		throw std::runtime_error("CSVãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ã¾ã›ã‚“: " + filePath);
	}
	// 1è¡Œãšã¤èª­ã¿è¾¼ã‚€
	std::string line;
	// å„è¡Œã‚’ã‚«ãƒ³ãƒã§åŒºåˆ‡ã£ã¦å‡¦ç†
	while (std::getline(file, line)) {
		std::vector<EnemyType> row;
		std::stringstream ss(line);
		std::string value;
		// ã‚«ãƒ³ãƒã§åŒºåˆ‡ã‚‰ã‚ŒãŸå„å€¤ã‚’å‡¦ç†
		while (std::getline(ss, value, ',')) {
			// æ–‡å­—åˆ—ã‚’intã«å¤‰æ›ã—ã€ãã‚Œã‚’BlockTypeã¸å¤‰æ›
			int intVal = std::stoi(value);
			EnemyType type = static_cast<EnemyType>(intVal);
			row.push_back(type);
		}
		// è¡Œã‚’enemyDataã«è¿½åŠ 
		enemyData.push_back(row);
	}

	file.close();
	return enemyData;
}

void CsvLoader::SaveMapBlockType(
	const std::string& filePath,
	const std::vector<std::vector<BlockType>>& mapData)
{
	// frontFilePath ã‚’ä½¿ã£ã¦ã„ã‚‹ãªã‚‰èª­ã¿è¾¼ã¿ã¨åŒã˜ã‚ˆã†ã«
	std::string filePathFull = frontFilePath + filePath;
	std::ofstream file(filePathFull);

	if (!file.is_open()) {
		throw std::runtime_error("CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãè¾¼ã¿ç”¨ã«é–‹ã‘ã¾ã›ã‚“: " + filePath);
	}
	// è¡Œã”ã¨ã«ãƒ«ãƒ¼ãƒ—
	const uint32_t height = static_cast<uint32_t>(mapData.size());
	for (uint32_t y = 0; y < height; ++y) {
		const uint32_t width = static_cast<uint32_t>(mapData[y].size());
		for (uint32_t x = 0; x < width; ++x) {
			int val = static_cast<int>(mapData[y][x]);
			file << val;
			if (x < width - 1) {
				file << ",";        // ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š
			}
		}
		file << "\n";               // è¡Œã”ã¨ã«æ”¹è¡Œ
	}
}

void CsvLoader::SaveMapEnemyType(
	const std::string& filePath, 
	const std::vector<std::vector<EnemyType>>& enemyData)
{

	// frontFilePath ã‚’ä½¿ã£ã¦ã„ã‚‹ãªã‚‰èª­ã¿è¾¼ã¿ã¨åŒã˜ã‚ˆã†ã«
	std::string filePathFull = frontFilePath + filePath;
	std::ofstream file(filePathFull);
	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸå ´åˆã®ã‚¨ãƒ©ãƒ¼ãƒã‚§ãƒƒã‚¯
	if (!file.is_open()) {
		throw std::runtime_error("CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›¸ãè¾¼ã¿ç”¨ã«é–‹ã‘ã¾ã›ã‚“: " + filePath);
	}
	// è¡Œã”ã¨ã«ãƒ«ãƒ¼ãƒ—
	const uint32_t height = static_cast<uint32_t>(enemyData.size());
	for (uint32_t y = 0; y < height; ++y) {
		const uint32_t width = static_cast<uint32_t>(enemyData[y].size());
		for (uint32_t x = 0; x < width; ++x) {
			int val = static_cast<int>(enemyData[y][x]);
			file << val;
			if (x < width - 1) {
				file << ",";        // ã‚«ãƒ³ãƒåŒºåˆ‡ã‚Š
			}
		}
		file << "\n";               // è¡Œã”ã¨ã«æ”¹è¡Œ
	}

}



============================================================
File Path: Game/Application/Map/CsvLoader.h
============================================================
#pragma once
#include <string>
#include <vector>
#include <fstream>
#include <sstream>
#include "Game/Application/Block/BlockType.h"
#include "Game/Application/Enemy/EnemyType.h"

class CsvLoader
{
public:
	CsvLoader() = default;
	~CsvLoader() = default;
	/// <summary>
	/// csvãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="filePath"></param>
	/// <returns></returns>
	std::vector<std::vector<int>> LoadMapInt(const std::string& filePath);
	std::vector<std::vector<BlockType>> LoadMapBlockType(const std::string& filePath);

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	/// </summary>
	std::vector<std::vector<EnemyType>> LoadMapEnemyType(const std::string& filePath);

	/// <summary>
	/// ç¾åœ¨ã®ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®ä¿å­˜
	/// </summary>
	static void SaveMapBlockType(const std::string& filePath,
		const std::vector<std::vector<BlockType>>& mapData);

	static void SaveMapEnemyType(const std::string& filePath,
		const std::vector<std::vector<EnemyType>>& enemyData);
private:
	static const std::string frontFilePath;
	static const std::string extensionCsv_;

};



============================================================
File Path: Game/Application/Map/Map.cpp
============================================================
#include "Map.h"
#ifdef USE_IMGUI
#include "engine/base/ImGuiManager.h"
#endif
#include "Game/Particle/ParticleManager.h"

#ifdef USE_IMGUI
// ãƒ–ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸè‰²ã‚’å–å¾—ã™ã‚‹ãƒ˜ãƒ«ãƒ‘ãƒ¼é–¢æ•°
ImVec4 GetBlockColorByType(BlockType blockType) {
	switch (blockType) {
	case BlockType::Air:         return ImVec4(0.2f, 0.2f, 0.2f, 1.0f);
	case BlockType::GrassBlock: return ImVec4(0.4f, 0.4f, 0.8f, 1.0f);
	case BlockType::SoilBlock:   return ImVec4(0.8f, 0.4f, 0.4f, 1.0f);
	case BlockType::kGoalUp:     return ImVec4(0.4f, 0.8f, 0.4f, 1.0f);
	case BlockType::kGoalDown:   return ImVec4(0.4f, 0.8f, 0.8f, 1.0f);
	case BlockType::breakBlock:  return ImVec4(0.8f, 0.8f, 0.4f, 1.0f);
	case BlockType::moveBlock:   return ImVec4(0.8f, 0.4f, 0.8f, 1.0f);
	case BlockType::sandBlock:   return ImVec4(0.7f, 0.6f, 0.3f, 1.0f);
	case BlockType::Unbreakable: return ImVec4(0.3f, 0.3f, 0.3f, 1.0f);
	default:                     return ImVec4(0.5f, 0.5f, 0.5f, 1.0f);
	}
}
#endif

void Map::Initialize(const char* filePath)
{
	// ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	mapChipData_.mapData.resize(kMapHeight, std::vector<BlockType>(kMapWidth, BlockType::Air));

	// ãƒãƒƒãƒ—ç•ªå·ã®ä¿å­˜
	mapNumber_ = filePath;

	// ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	LoadMapData(filePath);

	// ãƒãƒƒãƒ—ãƒ–ãƒ­ãƒƒã‚¯ã®ç”Ÿæˆ
	GenerareMapBlock();

	// ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®å¤‰æ›´æ¤œçŸ¥
	previousMapData_ = mapChipData_;

	ParticleManager::GetInstance()->CreateParticleGroup(
        "BreakParticle", "resources/BackSky.png");
	breakParticleEmitter_ = std::make_unique<ParticleEmitter>();
	breakParticleEmitter_->SetParticleName("BreakParticle");
	breakParticleEmitter_->SetScale({ 0.2f, 0.2f, 0.2f });
    
}


void Map::Update()
{
    //breakParticleEmitter_->Update();
    // ãƒãƒƒãƒ—ã®æ›´æ–°
    for (std::vector <Block*>& row : blockArray_) {
        for (Block* block : row) {
            if (!block) {
                continue;
            }
            block->Update();
        }
    }
	
#ifdef USE_IMGUI
    //  ã“ã“ã‹ã‚‰ ImGui éƒ¨åˆ†ã‚’ã€Œ1ã¤ã®ã‚¿ãƒ–ä»˜ãã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã€ã«çµ±åˆ

    // 1ã¤ã®ã‚¿ãƒ–ã«ã¾ã¨ã‚ã‚‹
    ImGui::Begin("Map Tools"); 

    if (ImGui::BeginTabBar("MapTabs"))
    {
        // ã‚¿ãƒ–1: Map Info
        if (ImGui::BeginTabItem("Info"))
        {
            ImGui::Text("Map Width: %d", GetWidth());
            ImGui::Text("Map Height: %d", GetHeight());
            ImGui::EndTabItem();
        }

        
        // ã‚¿ãƒ–2: Block Editor 
        if (ImGui::BeginTabItem("Block Editor"))
        {
            // â‘  ä¸€ç•ªä¸Šã«ã€Œä¿å­˜ / ãƒ­ãƒ¼ãƒ‰ã¾ã‚ã‚Šã€ã®UI
            static char mapFileName[256] = ".csv"; 
            static std::string mapFileMessage;

            ImGui::Text("Map CSV File:");
            ImGui::SameLine();
            ImGui::InputText("##MapFile", mapFileName, IM_ARRAYSIZE(mapFileName));

            // --- ä¿å­˜ãƒœã‚¿ãƒ³ ---
            if (ImGui::Button("Save Map CSV")) {
                try {
                    CsvLoader::SaveMapBlockType(mapFileName, mapChipData_.mapData);
                    mapFileMessage = std::string("Saved: ") + mapFileName;
                }
                catch (const std::exception& e) {
                    mapFileMessage = std::string("Save Failed: ") + e.what();
                }
            }

            ImGui::SameLine();

            // --- ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ ---
            if (ImGui::Button("Load Map CSV")) {
                try {
                    // "1_1.csv" â†’ "1_1" ã«å¤‰æ›ã—ã¦ã€ã‚²ãƒ¼ãƒ æœ¬ç·¨ã¨åŒã˜å½¢å¼ã§èª­ã‚€
                    std::string baseName = mapFileName;
                    size_t dotPos = baseName.rfind('.');
                    if (dotPos != std::string::npos) {
                        baseName = baseName.substr(0, dotPos);
                    }

                    // ãƒãƒƒãƒ—ï¼†ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å†èª­ã¿è¾¼ã¿
                    LoadMapData(baseName.c_str());

                    // ãƒãƒƒãƒ—ãƒ–ãƒ­ãƒƒã‚¯ã‚‚ä½œã‚Šç›´ã™
                    GenerareMapBlock();

                    mapFileMessage = std::string("Loaded: ") + mapFileName;
                }
                catch (const std::exception& e) {
                    mapFileMessage = std::string("Load Failed: ") + e.what();
                }
            }

            // ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
            if (!mapFileMessage.empty()) {
                ImGui::SameLine();
                ImGui::Text("%s", mapFileMessage.c_str());
            }

            ImGui::Separator();

            // â‘¡ ã“ã“ã‹ã‚‰ä¸‹ã¯ã€Œç·¨é›†UIã€ã¨ã€Œã‚°ãƒªãƒƒãƒ‰è¡¨ç¤ºã€

            // ãƒ–ãƒ­ãƒƒã‚¯ã‚¿ã‚¤ãƒ—é¸æŠç”¨ã®ã‚³ãƒ³ãƒœ
            static int currentTypeInt = 0;
            const char* blockTypeNames[] = {
                "Air",
                "GrassBlock",
                "SoilBlock",
                "GoalUp",
                "GoalDown",
                "BreakBlock",
                "MoveBlock",
                "SandBlock",
				"Unbreakable",
            };

            ImGui::Text("Paint Type:");
            ImGui::SameLine();
            ImGui::Combo("##PaintType",
                &currentTypeInt,
                blockTypeNames,
                IM_ARRAYSIZE(blockTypeNames));

            ImGui::Separator();
            ImGui::Text("Map Grid");

            ImGui::BeginChild("MapGrid", ImVec2(0, 260), true, ImGuiWindowFlags_HorizontalScrollbar);

            const float cellSize = 20.0f;
            uint32_t mapHeight = GetHeight();
            uint32_t mapWidth = GetWidth();

            for (uint32_t y = 0; y < mapHeight; ++y) {
                for (uint32_t x = 0; x < mapWidth; ++x) {

                    BlockType& cell = mapChipData_.mapData[y][x];

                    ImGui::PushID(static_cast<int>(y * mapWidth + x));

                    ImVec4 color = GetBlockColorByType(cell);
                    ImGui::PushStyleColor(ImGuiCol_Button, color);
                    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, color);
                    ImGui::PushStyleColor(ImGuiCol_ButtonActive, color);

                    std::string label = std::to_string(static_cast<int>(cell));

                    // ãƒœã‚¿ãƒ³ã¯è¦‹ãŸç›®ç”¨ã¨ã—ã¦æŠ¼ã™ã ã‘
                    ImGui::Button(label.c_str(), ImVec2(cellSize, cellSize));

                    // ã‚¨ãƒãƒŸãƒ¼ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã¨åŒã˜ãƒ‰ãƒ©ãƒƒã‚°å¡—ã‚Š
                    if (ImGui::IsItemHovered() && ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
                        cell = static_cast<BlockType>(currentTypeInt);
                        isMapDataChanged_ = true;
                    }

                    ImGui::PopStyleColor(3);
                    ImGui::PopID();

                    if (x < mapWidth - 1) {
                        ImGui::SameLine();
                    }
                }
            }

            ImGui::EndChild();


            

            ImGui::EndTabItem();
        }


        // ã‚¿ãƒ–3: Enemy Layer
        if (ImGui::BeginTabItem("Enemy Layer"))
        {
            // ã‚¨ãƒãƒŸãƒ¼ã‚¿ã‚¤ãƒ—ä¸€è¦§
            static int currentEnemyTypeInt = 0;
            const char* enemyTypeNames[] = {
                "None",
                "NormalEnemy",
                "FlyingEnemy",
            };

            ImGui::Text("Paint Enemy Type:");
            ImGui::SameLine();
            ImGui::Combo("##EnemyType",
                &currentEnemyTypeInt,
                enemyTypeNames,
                IM_ARRAYSIZE(enemyTypeNames));

            // ãƒ•ã‚¡ã‚¤ãƒ«åå…¥åŠ›ï¼‹ã‚»ãƒ¼ãƒ–/ãƒ­ãƒ¼ãƒ‰
            static char enemyFileName[256] = "stage01_EnemyLayer.csv";
            ImGui::InputText("EnemyLayer File", enemyFileName, IM_ARRAYSIZE(enemyFileName));

            static std::string enemyLayerMessage;

            // ã‚»ãƒ¼ãƒ–ãƒœã‚¿ãƒ³
            if (ImGui::Button("Save Enemy CSV")) {
                try {
                    CsvLoader::SaveMapEnemyType(enemyFileName, enemyLayerData_.enemyData);
                    enemyLayerMessage = std::string("Saved: ") + enemyFileName;
                }
                catch (const std::exception& e) {
                    enemyLayerMessage = std::string("Save Failed: ") + e.what();
                }
            }

            ImGui::SameLine();

            // ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³
            if (ImGui::Button("Load Enemy CSV")) {
                try {
                    // æ‹¡å¼µå­ .csv ã‚’å¤–ã—ã¦ Load ç”¨ã®ãƒ™ãƒ¼ã‚¹åã‚’ä½œã‚‹
                    std::string baseName = enemyFileName;
                    size_t dotPos = baseName.rfind('.');
                    if (dotPos != std::string::npos) {
                        baseName = baseName.substr(0, dotPos);
                    }

                    CsvLoader loader;
                    // LoadMapEnemyType ã¯ frontFilePath + baseName + ".csv" ã‚’èª­ã‚€
                    enemyLayerData_.enemyData = loader.LoadMapEnemyType(baseName);

                    // æ•µãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ›´æ–°ã•ã‚ŒãŸã“ã¨ã‚’è¨˜éŒ²
                    enemyLayerDirty_ = true;

                    enemyLayerMessage = std::string("Loaded: ") + enemyFileName;
                }
                catch (const std::exception& e) {
                    enemyLayerMessage = std::string("Load Failed: ") + e.what();
                }
            }

            if (!enemyLayerMessage.empty()) {
                ImGui::Text("%s", enemyLayerMessage.c_str());
            }

            // ã‚¨ãƒãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã®å‚ç…§
            auto& enemyLayer = enemyLayerData_.enemyData;

            // ã‚°ãƒªãƒƒãƒ‰æç”»å‰ã«ç©ºãƒã‚§ãƒƒã‚¯
            if (enemyLayer.empty() || enemyLayer[0].empty()) {
                ImGui::Text("Enemy layer is empty or not loaded.");
            } else {
                uint32_t enemyLayerHeight = static_cast<uint32_t>(enemyLayer.size());
                uint32_t enemyLayerWidth = static_cast<uint32_t>(enemyLayer[0].size());

                const float cellSize = 20.0f;

                // ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚°ãƒªãƒƒãƒ‰è¡¨ç¤º
                ImGui::BeginChild("EnemyLayerGrid", ImVec2(0, 260), true, ImGuiWindowFlags_HorizontalScrollbar);

                for (uint32_t y = 0; y < enemyLayerHeight; ++y) {
                    for (uint32_t x = 0; x < enemyLayerWidth; ++x) {

                        EnemyType& cell = enemyLayer[y][x];
                        uint32_t cellInt = static_cast<uint32_t>(cell);

                        ImGui::PushID(static_cast<int>(y * enemyLayerWidth + x));

                        ImVec4 color;
                        switch (cell) {
                        case EnemyType::NormalEnemy: color = ImVec4(0.2f, 0.8f, 0.2f, 1.0f); break;
                        case EnemyType::FlyingEnemy: color = ImVec4(0.2f, 0.4f, 1.0f, 1.0f); break;
                        default:                     color = ImVec4(0.4f, 0.4f, 0.4f, 1.0f); break;
                        }

                        ImGui::PushStyleColor(ImGuiCol_Button, color);
                        ImGui::PushStyleColor(ImGuiCol_ButtonHovered, color);
                        ImGui::PushStyleColor(ImGuiCol_ButtonActive, color);

                        std::string label = std::to_string(cellInt);
                        ImGui::Button(label.c_str(), ImVec2(cellSize, cellSize));

                        // å·¦ãƒ‰ãƒ©ãƒƒã‚°ä¸­ã«ã‚«ãƒ¼ã‚½ãƒ«ãŒä¹—ã£ã¦ã„ãŸã‚‰å¡—ã‚‹
                        if (ImGui::IsItemHovered() && ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
                            cell = static_cast<EnemyType>(currentEnemyTypeInt);
                        }

                        ImGui::PopStyleColor(3);
                        ImGui::PopID();

                        if (x < enemyLayerWidth - 1) {
                            ImGui::SameLine();
                        }
                    }
                }

                ImGui::EndChild();
            }

            ImGui::EndTabItem();
        }
		// ã‚¿ãƒ–4: Map Preview
        if (ImGui::BeginTabItem("Map Preview"))
        {
            ImGui::Text("Map Preview (Read-Only)");
            ImGui::BeginChild("MapPreview", ImVec2(0, 400), true, ImGuiWindowFlags_HorizontalScrollbar);
            const float cellSize = 20.0f;
            uint32_t mapHeight = GetHeight();
            uint32_t mapWidth = GetWidth();
            for (uint32_t y = 0; y < mapHeight; ++y) {
                for (uint32_t x = 0; x < mapWidth; ++x) {
                    BlockType cell = mapChipData_.mapData[y][x];
                    ImGui::PushID(static_cast<int>(y * mapWidth + x));
                    ImVec4 color = GetBlockColorByType(cell);
                    ImGui::PushStyleColor(ImGuiCol_Button, color);
                    ImGui::PushStyleColor(ImGuiCol_ButtonHovered, color);
                    ImGui::PushStyleColor(ImGuiCol_ButtonActive, color);
                    std::string label = std::to_string(static_cast<int>(cell));
                    // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ç”¨ãƒœã‚¿ãƒ³ï¼ˆæŠ¼ã›ãªã„ï¼‰
                    ImGui::Button(label.c_str(), ImVec2(cellSize, cellSize));
                    ImGui::PopStyleColor(3);
                    ImGui::PopID();
                    if (x < mapWidth - 1) {
                        ImGui::SameLine();
                    }
                }
            }
            ImGui::EndChild();
            ImGui::EndTabItem();
		}

        ImGui::EndTabBar();
    }

    ImGui::End(); // "Map Tools"

    // â–²â–²â–² ImGui çµ±åˆã“ã“ã¾ã§ â–²â–²â–²

#endif // USE_IMGUI
    // æœ«å°¾ã«è¿½åŠ ï¼šæ­»ã‚“ã ãƒ–ãƒ­ãƒƒã‚¯ã ã‘å›å
    for (auto& row : blockArray_) {
        for (Block*& block : row) {
            if (block && !block->GetAliveBlock()) {
                delete block;
                block = nullptr;
            }
        }
    }

}



void Map::Draw()
{
	// ãƒãƒƒãƒ—ã®æç”»
	for (std::vector <Block*>& row : blockArray_) {
		for (Block* block : row) {
			if (!block) {
				continue;
			}
			block->Draw();
		}
	}
	
}

void Map::Finalize()
{
	// ãƒãƒƒãƒ—ãƒ–ãƒ­ãƒƒã‚¯ã®è§£æ”¾
	for (std::vector <Block*>& row : blockArray_) {
		for (Block* block : row) {
			if (block) {
				delete block;
				block = nullptr;
			}
		}
	}
}

void Map::GenerareMapBlock()
{
	const uint32_t h = GetHeight();
	const uint32_t w = GetWidth();

	// æ—¢å­˜ã®ãƒ–ãƒ­ãƒƒã‚¯ã‚’è§£æ”¾
	for (auto& row : blockArray_) {
		for (Block*& block : row) {
			if (block) {
				delete block;
				block = nullptr;
			}
		}
	}
	// ãƒã‚¤ãƒ³ã‚¿ã‚’è§£æ”¾ã—ãŸã®ã§é…åˆ—è‡ªä½“ã‚‚ã‚¯ãƒªã‚¢
	blockArray_.clear();

	// æ–°ã—ã„ã‚µã‚¤ã‚ºã§é…åˆ—ã‚’ä½œã‚Šç›´ã™
	blockArray_.assign(h, std::vector<Block*>(w, nullptr));

	// ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰ãƒ–ãƒ­ãƒƒã‚¯ã‚’ç”Ÿæˆ
	for (uint32_t y = 0; y < h; ++y) {
		for (uint32_t x = 0; x < w; ++x) {
			const BlockType type = mapChipData_.mapData[y][x];
			if (type == BlockType::Air) {
				continue;
			}
			// ãƒ–ãƒ­ãƒƒã‚¯ã®ç”Ÿæˆ
			Vector3 pos = GetMapChipPositionByIndex(x, y);
			pos.x += blockOffset_;
			pos.y -= blockOffset_;
			blockArray_[y][x] = Block::CreateBlock(type, pos);
		}
	}
}

void Map::GenerateEnemyLayer()
{
	const uint32_t h = GetHeight();
	const uint32_t w = GetWidth();

	// ã‚¨ãƒãƒŸãƒ¼ãƒ‡ãƒ¼ã‚¿ã‹ã‚‰æ•µã‚’ç”Ÿæˆ
	for (uint32_t y = 0; y < h; y++) {
		for(uint32_t x = 0; x < w; x++) {
			const EnemyType type = enemyLayerData_.enemyData[y][x];
			if (type == EnemyType::None) {
				continue;
			}
			// æ•µã®ç”Ÿæˆ
			Vector3 pos = GetMapChipPositionByIndex(x, y);
			pos.x += blockOffset_;
			pos.y -= blockOffset_;
		}
	}
}


void Map::LoadMapData(const char* filePath)
{
	// CSVãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€
	CsvLoader csvLoader;
	mapChipData_.mapData = csvLoader.LoadMapBlockType(filePath);

	std::string enemyLayerFilePath = filePath + std::string("_EnemyLayer");
	// æ•µãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	enemyLayerData_.enemyData = csvLoader.LoadMapEnemyType(enemyLayerFilePath);


}





IndexSet Map::GetMapChipIndexSetByPosition(const Vector3& position)
{
	IndexSet indexSet{};

	// åº§æ¨™ã‹ã‚‰ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
	float x = std::floor(position.x / kBlockWidth);
	float y = std::floor((GetHeight() - 1) - (position.y / kBlockHeight));

	// åº§æ¨™ãŒãƒãƒƒãƒ—å¤–ã®å ´åˆã¯æœ€å¤§å€¤ã‚’è¿”ã™
	int ix = static_cast<int>(x);
	int iy = static_cast<int>(y);

	// ãƒãƒƒãƒ—å¤–ãƒã‚§ãƒƒã‚¯ / ãƒãƒƒãƒ—å¤–ãªã‚‰ç¯„å›²å¤–ã‚’ç¤ºã™ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™
	if (ix < 0 || ix >= static_cast<int>(GetWidth()) ||
		iy < 0 || iy >= static_cast<int>(GetHeight())) {
		indexSet.xIndex = GetWidth();
		indexSet.yIndex = GetHeight();
		return indexSet;
	}
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’ã‚»ãƒƒãƒˆ
	indexSet.xIndex = static_cast<uint32_t>(ix);
	indexSet.yIndex = static_cast<uint32_t>(iy);

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¿”ã™
	return indexSet;
}

BlockType Map::GetMapChipTypeByIndex(uint32_t xIndex, uint32_t yIndex)
{
	// ãƒãƒƒãƒ—å¤–ãƒã‚§ãƒƒã‚¯
	uint32_t w = GetWidth();
	uint32_t h = GetHeight();
	// ãƒãƒƒãƒ—å¤–ãªã‚‰Airã‚’è¿”ã™
	if (xIndex >= w || yIndex >= h) {
		return BlockType::Air;
	}
	// æŒ‡å®šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡ã‚’è¿”ã™
	return mapChipData_.mapData[yIndex][xIndex];
}


Rect Map::GetRectByIndex(uint32_t xIndex, uint32_t yIndex)
{
	Vector3 center = GetMapChipPositionByIndex(xIndex, yIndex);
	Rect rect{};
	rect.left = center.x - (kBlockWidth / 2);
	rect.right = center.x + (kBlockWidth / 2);
	rect.bottom = center.y - (kBlockHeight / 2);
	rect.top = center.y + (kBlockHeight / 2);
	return rect;
}

Vector3 Map::GetMapChipPositionByIndex(uint32_t xIndex, uint32_t yIndex)
{
	const uint32_t h = GetHeight();
	return Vector3(kBlockWidth * xIndex,
		kBlockHeight * (h - 1 - yIndex),
		0.0f);
}

void Map::BreakBlock(uint32_t xIndex, uint32_t yIndex)
{
	// ãƒãƒƒãƒ—å¤–ãƒã‚§ãƒƒã‚¯
    if (yIndex >= mapChipData_.mapData.size() ||
        xIndex >= mapChipData_.mapData[yIndex].size()) {
        return;
    }
	// ç ´å£Šå¯èƒ½ãƒ–ãƒ­ãƒƒã‚¯ã‹ãƒã‚§ãƒƒã‚¯
    if (mapChipData_.mapData[yIndex][xIndex] != BlockType::breakBlock) {
        return;
    }

    // è©²å½“ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãæ›ãˆ / Airã«å¤‰æ›´
    
    isMapDataChanged_ = true;

    // å®Ÿä½“ï¼ˆæç”»/æ›´æ–°ï¼‰ã‚’ãã®å ´ã§æ¶ˆã™ï¼ˆMapå…¨å†ç”Ÿæˆã—ãªã„ï¼‰
    if (yIndex < blockArray_.size() && xIndex < blockArray_[yIndex].size()) {
        if (blockArray_[yIndex][xIndex]) {
            // ç”Ÿå­˜ãƒ•ãƒ©ã‚°æ–¹å¼ï¼ˆæ¼”å‡ºã‚’æŒŸã‚€ãªã‚‰ Kill ã®ã¿ã«ã—ã¦ã‚‚OKï¼‰
            blockArray_[yIndex][xIndex]->SetBroken();

			Vector3 breakPos = GetMapChipPositionByIndex(xIndex, yIndex);
            // ç ´å£Šæ™‚ã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç™ºç”Ÿ
           
			breakParticleEmitter_->SetTranslate(breakPos);

			// è©²å½“ã®BreakBlockã‚’Airã«å¤‰æ›´
            mapChipData_.mapData[yIndex][xIndex] = BlockType::Air;
        }
    }
}



============================================================
File Path: Game/Application/Map/Map.h
============================================================
#pragma once
#include <vector>
#include "MyMath.h"
#include "Game/Application/Block/Block.h"
#include "Game/Application/Block/BlockType.h"
#include "Game/Application/Enemy/EnemyType.h"
#include "Game/Particle/ParticleEmitter.h"
#include <cstdint>
#include <string>
#include "Game/Application/Map/CsvLoader.h"
/// ãƒãƒƒãƒ—ã‚¯ãƒ©ã‚¹

/// ãƒãƒƒãƒ—ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
struct MapChipData {
	std::vector<std::vector<BlockType>> mapData;
};
struct EnemyLayerData {
	std::vector<std::vector<EnemyType>> enemyData;
};

/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹æ§‹é€ ä½“
struct IndexSet {
	uint32_t xIndex;
	uint32_t yIndex;
};

/// çŸ©å½¢æ§‹é€ ä½“
struct Rect {
	float left;
	float right;
	float bottom;
	float top;
};

class Map
{
public:
	// ï¼‘ãƒ–ãƒ­ãƒƒã‚¯ã®å¤§ãã•
	static inline const float kBlockWidth = 1.0f;
	static inline const float kBlockHeight = 1.0f;
	//ãƒãƒƒãƒ—ã®å¤§ãã•
	// æ¨ª
	static inline const uint32_t kMapWidth = 100;
	// é«˜ã•
	static inline const uint32_t kMapHeight = 20;

	// å¯å¤‰ã‚µã‚¤ã‚ºã®ãƒãƒƒãƒ—ã®å¤§ãã•
	uint32_t GetWidth()const {
		if (mapChipData_.mapData.empty()) { return 0; }
		return (uint32_t)mapChipData_.mapData[0].size();
	}
	uint32_t GetHeight()const {
		return (uint32_t)mapChipData_.mapData.size();
	}
public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize(const char* filePath);

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();

	/// <summary>
	/// ãƒãƒƒãƒ—ãƒ–ãƒ­ãƒƒã‚¯ç”Ÿæˆ
	/// </summary>
	void GenerareMapBlock();

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”Ÿæˆ
	/// </summary>
	void GenerateEnemyLayer();

	/// <summary>
	/// ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	/// </summary>
	void LoadMapData(const char* filePath);


public:	// Setter / Getter
	/// <summary>
	/// åº§æ¨™ã‹ã‚‰ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
	/// </summary>
	/// <param name="position">å–å¾—ã—ãŸã„ãƒãƒƒãƒ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åº§æ¨™</param>
	IndexSet GetMapChipIndexSetByPosition(const Vector3& position);

	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡ã‚’å–å¾—
	/// </summary>
	/// <param name="xIndex/yIndex">å–å¾—ã—ãŸã„ãƒãƒƒãƒ—ã®åº§æ¨™ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	/// <returns>æŒ‡å®šã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡</returns>
	BlockType GetMapChipTypeByIndex(uint32_t xIndex, uint32_t yIndex);


	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰çŸ©å½¢æƒ…å ±ã‚’å–å¾—
	/// </summary>
	/// <param name="xIndex/yIndex">ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åº§æ¨™</param>
	/// <returns>æŒ‡å®šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åº§æ¨™ã®ãƒ–ãƒ­ãƒƒã‚¯ã®çŸ©å½¢æƒ…å ±</returns>
	Rect GetRectByIndex(uint32_t xIndex, uint32_t yIndex);

	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ä¸­å¿ƒåº§æ¨™ã‚’å–å¾—
	/// </summary>
	/// <param name="xIndex/yIndex">ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åº§æ¨™</param>
	/// <returns>æŒ‡å®šã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹åº§æ¨™ã®ãƒ–ãƒ­ãƒƒã‚¯ã®ä¸­å¿ƒåº§æ¨™</returns>
	Vector3 GetMapChipPositionByIndex(uint32_t xIndex, uint32_t yIndex);

	/// <summary>
	/// ãƒãƒƒãƒ—ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	/// </summary>
	const EnemyLayerData& GetEnemyLayerData() const { return enemyLayerData_; }

	/// <summary>
	/// ç·¨é›†ç”¨ãƒãƒƒãƒ—ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	/// </summary>
	EnemyLayerData& GetEnemyLayerData() { return enemyLayerData_; }

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼å¤‰æ›´æ¤œçŸ¥ãƒ•ãƒ©ã‚°ã‚’æ¶ˆè²»
	/// </summary>
	/// <returns></returns>
	bool ConsumeEnemyLayerDirtyFlag() {
		bool result = enemyLayerDirty_;
		enemyLayerDirty_ = false;
		return result;
	}

	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡ã‚’è¨­å®š
	/// </summary>
	/// <param name="xIndex/yIndex">è¨­å®šã—ãŸã„ãƒãƒƒãƒ—ã®åº§æ¨™ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹</param>
	/// <param name="type">è¨­å®šã™ã‚‹ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡</param>
	void SetMapChipTypeByIndex(uint32_t xIndex, uint32_t yIndex, BlockType type) {
		if (yIndex < mapChipData_.mapData.size() && xIndex < mapChipData_.mapData[yIndex].size()) {
			mapChipData_.mapData[yIndex][xIndex] = type;
			isMapDataChanged_ = true;
		}
	}

	/// <summary>
	/// ç ´å£Šå¯èƒ½ãƒ–ãƒ­ãƒƒã‚¯ã‚’å£Šã™
	/// </summary>
	/// <param name="xIndex">å½“ãŸã£ãŸå£Šã›ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã®æ¨ªIndexã®ç•ªå·</param>
	/// <param name="yIndex">å½“ãŸã£ãŸå£Šã›ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã®ç¸¦Indexã®ç•ªå·</param>
	void BreakBlock(uint32_t xIndex, uint32_t yIndex);

private:
	// ãƒãƒƒãƒ—ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿
	MapChipData mapChipData_;
	// ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿
	EnemyLayerData enemyLayerData_;

	// å¤‰æ›´æ¤œçŸ¥
	bool isMapDataChanged_ = false;
	MapChipData previousMapData_;

	// ãƒãƒƒãƒ—ãƒ–ãƒ­ãƒƒã‚¯ã®é…åˆ—
	std::vector<std::vector<Block*>> blockArray_;

	// å¯å¤‰ã‚µã‚¤ã‚ºã®ãƒãƒƒãƒ—ã®å¤§ãã•
	uint32_t width_ = 0;
	uint32_t height_ = 0;

	// ãƒ–ãƒ­ãƒƒã‚¯ã‚’å°‘ã—ãšã‚‰ã™
	float blockOffset_ = 0.5f;

	// ãƒãƒƒãƒ—ç•ªå·
	std::string mapNumber_;

	// ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼å¤‰æ›´æ¤œçŸ¥ãƒ•ãƒ©ã‚°
	bool enemyLayerDirty_ = false;


	// ç ´å£Šå¯èƒ½ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨
	std::unique_ptr<ParticleEmitter> breakParticleEmitter_;

};


============================================================
File Path: Game/Application/ModelList.cpp
============================================================
#include "ModelList.h"
#include "ModelManager.h"
void ModelList::LoadAllModel()
{
	/// LoadModelList
	ModelManager::GetInstance()->LoadModel("cubeR.obj");
	ModelManager::GetInstance()->LoadModel("Cube.obj");


	/// TitleScene
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	ModelManager::GetInstance()->LoadModel("Player.obj");
	// ãƒ¬ã‚¤ãƒ³ãƒœãƒ¼ãƒ—ãƒ¬ãƒ¼ãƒ³
	ModelManager::GetInstance()->LoadModel("RainbowPlane.obj");
	// ã‚¿ã‚¤ãƒˆãƒ«ãƒ­ã‚´
	ModelManager::GetInstance()->LoadModel("title.obj");
	// ã‚¿ã‚¤ãƒˆãƒ«èƒŒæ™¯
	ModelManager::GetInstance()->LoadModel("Back3.obj");
	ModelManager::GetInstance()->LoadModel("Back3Reverse.obj");
	ModelManager::GetInstance()->LoadModel("back2.obj");
	ModelManager::GetInstance()->LoadModel("Back2Reverse.obj");
	ModelManager::GetInstance()->LoadModel("back1.obj");
	ModelManager::GetInstance()->LoadModel("BackSky.obj");
	ModelManager::GetInstance()->LoadModel("soil.obj");

	/// StageSelectScene
	ModelManager::GetInstance()->LoadModel("SelectBaseGround.obj");

	/// GamePlayScene
	ModelManager::GetInstance()->LoadModel("Grass.obj");
	ModelManager::GetInstance()->LoadModel("SceneChange.obj");
	ModelManager::GetInstance()->LoadModel("nullBlock.obj");
	ModelManager::GetInstance()->LoadModel("XYZLabel.obj");
	ModelManager::GetInstance()->LoadModel("BreakBlock.obj");
	ModelManager::GetInstance()->LoadModel("moveBlock.obj");
	ModelManager::GetInstance()->LoadModel("sand.obj");
	ModelManager::GetInstance()->LoadModel("Unbreakable.obj");

	ModelManager::GetInstance()->LoadModel("GoalUp.obj");
	ModelManager::GetInstance()->LoadModel("GoalDown.obj");

	ModelManager::GetInstance()->LoadModel("Tentativeenemy.obj");
}


============================================================
File Path: Game/Application/ModelList.h
============================================================
#pragma once
class ModelList
{

public:
	void LoadAllModel();
};



============================================================
File Path: Game/Application/Player/Player.cpp
============================================================
#include "Player.h"
#include <algorithm>
#include "Input.h"
#ifdef USE_IMGUI
#include "engine/base/ImGuiManager.h"
#endif


Collider::Type Player::GetType() const
{
	// åˆ¤å®šã‚¿ã‚¤ãƒ—ãŒãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã§ã‚ã‚‹ã“ã¨ã‚’è¿”ã™
	return Collider::Type::Player;
}

AABB Player::GetAABB() const
{
	AABB aabb{};

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸­å¿ƒ
	Vector3 pos = playerModel_->GetTranslate();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å¹…ã¨é«˜ã•ã‚’å–å¾—
	float halfWidth = status_.kWidth / 2.0f;
	float halfHeight = status_.kHeight / 2.0f;

	// å¥¥è¡Œã¯æ°—ã«ã—ãªã„
	float halfDepth = 0.5f;

	// AABBã®æœ€å°åº§æ¨™ã¨æœ€å¤§åº§æ¨™ã‚’è¨­å®š
	aabb.min = { pos.x - halfWidth, pos.y - halfHeight, pos.z - halfDepth };
	aabb.max = { pos.x + halfWidth, pos.y + halfHeight, pos.z + halfDepth };

	// AABBã‚’è¿”ã™
	return aabb;
}

void Player::OnCollision(Collider* other)
{
	// è¡çªç›¸æ‰‹ãŒå­˜åœ¨ã—ãªã‹ã£ãŸã‚‰å‡¦ç†ã—ãªã„
	if (!other)return;

	switch (other->GetType())
	{
		// æ•µã«è¡çªã—ãŸã‚‰
	case Collider::Type::Enemy:
		//  
		if (isEnemyHit_) {
			// ã™ã§ã«å½“ãŸã£ã¦ã„ã‚‹ãªã‚‰ä½•ã‚‚ã—ãªã„ / ç„¡æ•µæ™‚é–“
			break;
		}
		// ã‚¨ãƒãƒŸãƒ¼è¡çªå‡¦ç†
		EnemyCollision();
		break;
	default:
		// ç‰¹ã«ä½•ã‚‚ã—ãªã„
		break;
	}
}

void Player::EnemyCollision()
{
	// ç‚¹æ»…ã‚¹ã‚¿ãƒ¼ãƒˆã®åˆæœŸåŒ–ã®ã¿
	isEnemyHit_ = true;
	flashingFrameCount_ = 0;
	isVisible_ = true;
}

void Player::FlashingUpdate()
{
	// ã‚¨ãƒãƒŸãƒ¼ã«ãƒ’ãƒƒãƒˆã—ã¦ã„ãŸã‚‰ç‚¹æ»…å‡¦ç† / ç„¡æ•µæ™‚é–“
	if (isEnemyHit_) {
		// ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ãƒˆæ›´æ–°
		flashingFrameCount_++;
		// ç‚¹æ»…å‡¦ç†
		if (flashingFrameCount_ <= maxFlashingFlame_) {
			// ä¸€å®šé–“éš”ã§è¡¨ç¤ºãƒ»éè¡¨ç¤ºã‚’åˆ‡ã‚Šæ›¿ãˆ
			if (flashingFrameCount_ % flashingIntervalFrame_ == 1) {
				isVisible_ = !isVisible_;
			}
		} else {
			// çµ‚äº†å‡¦ç†
			isEnemyHit_ = false;
			isVisible_ = true;
			flashingFrameCount_ = 0;
		}
	}
}

void Player::PlayerTurn()
{
	switch (direction_)
	{
	case Direction::kRight:

		// å³å‘ã
		targetYaw_ = 0.0f;

		break;
	case Direction::kLeft:
		// å·¦å‘ã
		targetYaw_ = 3.5f;

		break;

	default:
		break;
	}

	// ç¾åœ¨ã®å›è»¢ã‚’å–å¾—
	Vector3 currentRotate = playerModel_->GetRotate();
	// è£œé–“ä¿‚æ•°ã®è¨ˆç®—
	float t = 1.0f - std::pow(0.5f, static_cast<float>(1.0f) / (status_.kTurnTime * 60.0f));
	// ãƒ¨ãƒ¼è§’ã®è£œé–“
	currentRotate.y += (targetYaw_ - currentRotate.y) * t;
	// å›è»¢ã®è¨­å®š
	playerModel_->SetRotate(currentRotate);

}



void Player::Initialize(Vector3 position)
{
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ‡ãƒ«ã®ç”Ÿæˆã¨åˆæœŸåŒ–
	playerModel_ = std::make_unique<Object3D>();
	playerModel_->Initialize();
	playerModel_->SetTranslate(position);
	playerModel_->SetModel("Player.obj");
	// æ­»ã¬é«˜ã•ã®è¨­å®š
	SetDeathHeight(-1.0f);
}


void Player::Update()
{
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æŒ™å‹•æ›´æ–°
	UpdateBehavior();
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢
	PlayerTurn();
	// ã‚¨ãƒãƒŸãƒ¼ã«ãƒ’ãƒƒãƒˆã—ãŸã‚‰
	FlashingUpdate();

#ifdef USE_IMGUI
	ImGui();
#endif 
	// ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
	playerModel_->Update();
}



void Player::Draw()
{
	// ãƒ¢ãƒ‡ãƒ«ã®æç”»
	if (isVisible_) {
		playerModel_->Draw();
	}
}

void Player::UpdateBehavior()
{
	// ãƒãƒƒãƒ—ãŒã‚»ãƒƒãƒˆã•ã‚Œã¦ã„ãªã‹ã£ãŸã‚‰å‡¦ç†ã—ãªã„
	if (!map_)return;

	// æ­»äº¡ã—ã¦ã„ãŸã‚‰ãƒªã‚»ãƒƒãƒˆå‡¦ç†
	if (isDead_) {
		DebugPlayerReset();
		return;
	}

	// ç§»å‹•å‡¦ç†
	Move();
	// ã‚¸ãƒ£ãƒ³ãƒ—å‡¦ç†
	Jump();
	// å½“ãŸã‚Šåˆ¤å®šå‡¦ç†
	CollisionMapInfo collisionInfo;
	// åœ°é¢ã«ã„ãªã‹ã£ãŸã‚‰ãƒªã‚»ãƒƒãƒˆ
	if (playerModel_->GetTranslate().y < deathHeight_ && !onGround_)
	{
		// æ­»äº¡ãƒ•ãƒ©ã‚°
		isDead_ = true;
	}
	// ç§»å‹•é‡ã®åæ˜ 
	collisionInfo.move = velocity_;
	// ãƒãƒƒãƒ—è¡çªãƒã‚§ãƒƒã‚¯
	MapCollision(collisionInfo);
	// å¤©äº•è¡çªå‡¦ç†
	CellingCollisionMove(collisionInfo);
	// åºŠè¡çªå‡¦ç†
	LandingCollisionMove(collisionInfo);
	// å£è¡çªå‡¦ç†
	WallCollisionMove(collisionInfo);
	// é€Ÿåº¦åæ˜ 
	PlayerCollisionMove(collisionInfo);
}


void Player::Move()
{

	if (!controlEnabled_) {
		// èµ°ã‚Šç¶šã‘é˜²æ­¢ï¼ˆã‚­ãƒ¼æŠ¼ã—ã£ã±ãªã—è§£é™¤ç›´å¾Œã®äº‹æ•…å¯¾ç­–ï¼‰
		velocity_.x *= (1.0f - status_.kAttenuation);

		// ãƒ€ãƒƒã‚·ãƒ¥çŠ¶æ…‹ã‚‚è§£é™¤
		isDash_ = false;
		dashDirection_ = 0;
		rightTapTimer_ = 0;
		leftTapTimer_ = 0;

		return;
	}


	auto* input = Input::GetInstance();

	// ------------------------
	// å…¥åŠ›çŠ¶æ…‹
	// ------------------------
	const bool rightHold = input->PushKey(DIK_D);
	const bool leftHold = input->PushKey(DIK_A);

	const bool rightTrig = input->TriggerKey(DIK_D);
	const bool leftTrig = input->TriggerKey(DIK_A);

	// ------------------------
	// ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—ç”¨ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
	// ------------------------
	if (rightTapTimer_ > 0) { --rightTapTimer_; }
	if (leftTapTimer_ > 0) { --leftTapTimer_; }

	// å³ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®š
	if (rightTrig) {
		// ä¸€å®šæ™‚é–“å†…ã«2å›ç›®ãŒæ¥ãŸã‚‰ãƒ€ãƒƒã‚·ãƒ¥é–‹å§‹
		if (rightTapTimer_ > 0) {
			isDash_ = true;
			dashDirection_ = +1;
		}
		// ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
		rightTapTimer_ = status_.kDashDoubleTapFrame;
		// åå¯¾å´ã¯ãƒªã‚»ãƒƒãƒˆ
		leftTapTimer_ = 0;
	}

	// å·¦ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®š
	if (leftTrig) {
		if (leftTapTimer_ > 0) {
			isDash_ = true;
			dashDirection_ = -1;
		}
		leftTapTimer_ = status_.kDashDoubleTapFrame;
		rightTapTimer_ = 0;
	}

	// ------------------------
	// ãƒ€ãƒƒã‚·ãƒ¥ç¶™ç¶šï¼è§£é™¤åˆ¤å®š
	// ------------------------
	const bool movingRight = rightHold && !leftHold;
	const bool movingLeft = leftHold && !rightHold;

	// å…¥åŠ›ãŒæ­¢ã¾ã£ãŸã‚‰ãƒ€ãƒƒã‚·ãƒ¥è§£é™¤
	if (!movingRight && !movingLeft) {
		isDash_ = false;
		dashDirection_ = 0;
	} else if (isDash_) {
		// é€†æ–¹å‘ã«å…¥åŠ›ã—ãŸã‚‰ãƒ€ãƒƒã‚·ãƒ¥è§£é™¤
		if ((dashDirection_ == +1 && movingLeft) ||
			(dashDirection_ == -1 && movingRight)) {
			isDash_ = false;
			dashDirection_ = 0;
		}
	}

	// ------------------------
	// å®Ÿéš›ã®é€Ÿåº¦æ›´æ–°
	// ------------------------
	Vector3 acceleration{};

	const bool dashActiveRight = isDash_ && (dashDirection_ == +1) && movingRight;
	const bool dashActiveLeft = isDash_ && (dashDirection_ == -1) && movingLeft;
	const bool dashActive = dashActiveRight || dashActiveLeft;

	// ãƒ€ãƒƒã‚·ãƒ¥ä¸­ã ã‘å°‘ã—é€Ÿãã™ã‚‹
	float dashScale = dashActive ? status_.kDashSpeedScale : 1.0f;
	float maxSpeed = status_.kMaxSpeed * dashScale;

	// æ¨ªæ–¹å‘é€Ÿåº¦æ›´æ–°
	if (movingRight) {
		// å·¦ã«å‹•ã„ã¦ã„ãŸå ´åˆã¯å°‘ã—æ¸›é€Ÿ
		if (velocity_.x < 0.0f) {
			velocity_.x *= (1.0f - status_.kAttenuation);
		}
		acceleration.x += status_.kAcceleration * dashScale;

		// æŠ¼ã•ã‚ŒãŸæ–¹å‘ã«ãƒ‡ã‚£ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‘ã‘ã‚‹
		direction_ = Direction::kRight;
	} else if (movingLeft) {
		if (velocity_.x > 0.0f) {
			velocity_.x *= (1.0f - status_.kAttenuation);
		}
		acceleration.x -= status_.kAcceleration * dashScale;

		// æŠ¼ã•ã‚ŒãŸæ–¹å‘ã«ãƒ‡ã‚£ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’å‘ã‘ã‚‹
		direction_ = Direction::kLeft;
	} else {
		// å…¥åŠ›ãŒãªã„ã¨ãã¯æ¸›é€Ÿã®ã¿ï¼ˆãƒ€ãƒƒã‚·ãƒ¥å€ç‡ã¯ã‹ã‘ãªã„ï¼‰
		velocity_.x *= (1.0f - status_.kAttenuation);
	}

	// åŠ é€Ÿåº¦åæ˜ 
	velocity_.x += acceleration.x;

	// é€Ÿåº¦ã«å¿œã˜ã¦å›è»¢
	Vector3 rotate = playerModel_->GetRotate();
	rotate -= {0.0f, 0.0f, velocity_.x};
	// å›è»¢ãŒè¦å®šå€¤ã§ã‚ã‚‹playerTurnAround_ãŒ6.3fã«ãªã£ãŸã‚‰å›è»¢ã®å€¤ã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹
	if (-playerTurnAround_ >= rotate.z && movingRight ||
		playerTurnAround_ <= rotate.z && movingLeft) {
		rotate.z = 0.0f;
	}
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å›è»¢
	playerModel_->SetRotate(rotate);

	// æœ€å¤§é€Ÿåº¦ã‚’ãƒ€ãƒƒã‚·ãƒ¥çŠ¶æ…‹ã«å¿œã˜ã¦å¤‰ãˆã‚‹
	velocity_.x = std::clamp(velocity_.x, -maxSpeed, maxSpeed);
}


void Player::Jump()
{
	// æ“ä½œãƒ­ãƒƒã‚¯ä¸­ï¼šã‚¸ãƒ£ãƒ³ãƒ—å…¥åŠ›ã¯ç„¡è¦–
	if (!controlEnabled_) {
		// é‡åŠ›ã ã‘ã¯é€šå¸¸é€šã‚Šæ›ã‘ã‚‹ï¼ˆç©ºä¸­ã§åœæ­¢ã—ãªã„ã‚ˆã†ã«ï¼‰
		if (!onGround_) {
			velocity_.y += -status_.kGravity;
			velocity_.y = (std::max)(velocity_.y, -status_.kMaxFallSpeed);
		}
		return;
	}

	// åœ°é¢ã«ã„ã‚‹å ´åˆ
	if (onGround_) {
		// ã‚¸ãƒ£ãƒ³ãƒ—ã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸã‚‰
		if (Input::GetInstance()->PushKey(DIK_SPACE)) {
			// ã‚¸ãƒ£ãƒ³ãƒ—å‡¦ç†
			velocity_.y = status_.kJumpPower;
		}
	} else {
		// é‡åŠ›é©å¿œå‡¦ç†
		velocity_.y += -status_.kGravity;
		velocity_.y = (std::max)(velocity_.y, -status_.kMaxFallSpeed);
	}

}



void Player::MapCollision(CollisionMapInfo& collisionInfo)
{
	CollisionMapInfoDirection(
		collisionInfo,
		CollisionType::kRight,
		{ kRightTop,kRightBottom },
		Vector3(status_.kEpsilon, 0.0f, 0.0f),
		[](const CollisionMapInfo& info) {
			return info.move.x > 0.0f;
		});

	CollisionMapInfoDirection(
		collisionInfo,
		CollisionType::kLeft,
		{ kLeftTop,kLeftBottom },
		Vector3(-status_.kEpsilon, 0.0f, 0.0f),
		[](const CollisionMapInfo& info) {
			return info.move.x < 0.0f;
		});

	CollisionMapInfoDirection(
		collisionInfo,
		CollisionType::kTop,
		{ kRightTop,kLeftTop },
		Vector3(0.0f, 0.0f, 0.0f),
		[](const CollisionMapInfo& info) {
			return info.move.y > 0.0f;
		});

	CollisionMapInfoDirection(
		collisionInfo,
		CollisionType::kBottom,
		{ kRightBottom,kLeftBottom },
		Vector3(0.0f, -status_.kEpsilon, 0.0f),
		[](const CollisionMapInfo& info) {
			return info.move.y < 0.0f;
		});
}

void Player::CellingCollisionMove(CollisionMapInfo& collisionInfo)
{
	// å¤©äº•ã«è¡çªã—ã¦ã„ã‚‹ã‹ã©ã†ã‹
	if (collisionInfo.celling) {
		// å¤©äº•ã«è¡çªã—ãŸã‚‰ç§»å‹•é‡ã‚’èª¿æ•´
		velocity_.y = 0.0f;

		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®é ­ã«å½“ãŸã£ãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’èª¿ã¹ã‚‹
		Vector3 position = playerModel_->GetTranslate();

		// é ­ã®2ç‚¹ã®ä½ç½®ã‚’è¨ˆç®—
		std::array<Vector3, 2> topCorners = {
			CornerPosition(position,kLeftTop),
			CornerPosition(position,kRightTop)
		};
		// å„ã‚³ãƒ¼ãƒŠãƒ¼ã®æ–°ã—ã„ä½ç½®ã§å½“ãŸã£ãŸãƒ–ãƒ­ãƒƒã‚¯ã‚’èª¿ã¹ã‚‹
		for (const auto& cornerPosition : topCorners) {
			IndexSet indexSet = map_->GetMapChipIndexSetByPosition(cornerPosition);
			BlockType blockType = map_->GetMapChipTypeByIndex(indexSet.xIndex, indexSet.yIndex - 1);

			// Break Blockã ã£ãŸå ´åˆç ´å£Šã™ã‚‹ 
			if (IsHitBlockBreakableTable(blockType)) {
				// ãƒ–ãƒ­ãƒƒã‚¯ç ´å£Š
				map_->BreakBlock(indexSet.xIndex, indexSet.yIndex - 1);
			}
		}

	}
}

void Player::LandingCollisionMove(CollisionMapInfo& collisionInfo)
{
	// åºŠã«è¡çªã—ã¦ã„ã‚‹ã‹ã©ã†ã‹
	if (onGround_) {
		if (velocity_.y > 0.0f) {
			// ä¸Šæ˜‡ã—ã¦ã„ã‚‹å ´åˆã¯åºŠã«è¡çªã—ãªã„
			onGround_ = false;
		} else {
			// ç§»å‹•å¾Œã®éåº¦ã®è¨ˆç®—
			std::array<Vector3, kNumCorners> newPositions;
			for (uint32_t i = 0; i < newPositions.size(); i++) {
				// å„ã‚³ãƒ¼ãƒŠãƒ¼ã®æ–°ã—ã„ä½ç½®ã‚’è¨ˆç®—
				Vector3 position = playerModel_->GetTranslate();
				// ç§»å‹•é‡ã‚’åŠ ç®—
				position += collisionInfo.move;
				// ã‚³ãƒ¼ãƒŠãƒ¼ä½ç½®ã‚’å–å¾—
				newPositions[i] = CornerPosition(position, static_cast<Corner>(i));
			}
			// å„ã‚³ãƒ¼ãƒŠãƒ¼ã®æ–°ã—ã„ä½ç½®ã§å½“ãŸã‚Šåˆ¤å®šã‚’ç¢ºèª
			BlockType blockType;
			// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç›´ä¸‹ã®åˆ¤å®š
			bool hit = false;

			// å·¦ç‚¹ã®åˆ¤å®š
			IndexSet indexSet;
			// è‡ªæ©Ÿã®å·¦ä¸‹ãŒãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ä½•ç•ªç›®ã«ã‚ã‚‹ã®ã‹
			indexSet = map_->GetMapChipIndexSetByPosition(newPositions[kLeftBottom] + Vector3(0.0f, -status_.kEpsilon, 0.0f));
			// å–å¾—ã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ãã®ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡ã‚’å–å¾—
			blockType = map_->GetMapChipTypeByIndex(indexSet.xIndex, indexSet.yIndex);
			// å–å¾—ã—ãŸãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡ãŒåˆ¤å®šã‚’å–ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ãªã®ã‹åˆ¤åˆ¥
			if (IsHitBlockTable(blockType)) {
				hit = true;
			}
			// ã‚´ãƒ¼ãƒ«ãƒ–ãƒ­ãƒƒã‚¯ã®åˆ¤å®š
			if (IsHitGoalBlockTable(blockType)) {
				isGoal_ = true;
			}


			// å³ç‚¹ã®åˆ¤å®š
			// è‡ªæ©Ÿã®å³ä¸‹ãŒãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ä½•ç•ªç›®ã«ã‚ã‚‹ã®ã‹
			indexSet = map_->GetMapChipIndexSetByPosition(newPositions[kRightBottom] + Vector3(0.0f, -status_.kEpsilon, 0.0f));
			// å–å¾—ã—ãŸã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‹ã‚‰ãã®ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡ã‚’å–å¾—
			blockType = map_->GetMapChipTypeByIndex(indexSet.xIndex, indexSet.yIndex);
			// å–å¾—ã—ãŸãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡ãŒåˆ¤å®šã‚’å–ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ãªã®ã‹åˆ¤åˆ¥
			if (IsHitBlockTable(blockType)) {
				hit = true;
			}
			// ã‚´ãƒ¼ãƒ«ãƒ–ãƒ­ãƒƒã‚¯ã®åˆ¤å®š
			if (IsHitGoalBlockTable(blockType)) {
				isGoal_ = true;
			}

			// ã©ã¡ã‚‰ã®ç‚¹ã‚‚å½“ãŸã£ã¦ã„ãªã‹ã£ãŸã‚‰åºŠã«è¡çªã—ã¦ã„ãªã„ã¨ã™ã‚‹
			if (!hit) {
				onGround_ = false;
			}
		}
	} else {
		if (collisionInfo.landing) {
			// åºŠã«è¡çªã—ãŸã‚‰ç§»å‹•é‡ã‚’èª¿æ•´
			velocity_.y = 0.0f;
			onGround_ = true;
		}
	}

}

void Player::WallCollisionMove(CollisionMapInfo& collisionInfo)
{
	if (collisionInfo.hitWall) {
		// å£ã«è¡çªã—ãŸã‚‰ç§»å‹•é‡ã‚’èª¿æ•´
		velocity_.x *= (1.0f - status_.kEpsilon);
	}
}

void Player::PlayerCollisionMove(const CollisionMapInfo& info)
{
	// ç§»å‹•é‡ã‚’åæ˜ 
	// åˆ¤å®šã‚’å–ã£ãŸå¾Œã®ç§»å‹•é‡ã‚’å–å¾—
	Vector3 position = playerModel_->GetTranslate();
	// ç§»å‹•é‡ã‚’åŠ ç®—
	position += info.move;
	// ä½ç½®ã‚’è¨­å®š
	playerModel_->SetTranslate(position);
}

void Player::CollisionMapInfoDirection(CollisionMapInfo& collisionInfo, CollisionType type, const std::array<Corner, 2>& checkCorners, const Vector3& offset, std::function<bool(const CollisionMapInfo&)> mooveCondition)
{
	// ç§»å‹•é‡ãŒ0ãªã‚‰å‡¦ç†ã—ãªã„
	if (!mooveCondition(collisionInfo))return;
	// ç¾åœ¨ã®ä½ç½®ã«ç§»å‹•é‡ã‚’åŠ ç®—ã—ãŸä½ç½®ã‚’å–å¾—
	Vector3 position = playerModel_->GetTranslate() + collisionInfo.move;

	// ï¼’ã¤ã®ã‚³ãƒ¼ãƒŠãƒ¼ä½ç½®ã®å½“ãŸã‚Šåˆ¤å®šã‚’å–å¾—
	std::array<Vector3, 2> points = {
		CornerPosition(position, checkCorners[0]) + offset,
		CornerPosition(position, checkCorners[1]) + offset
	};
	// å½“ãŸã‚Šåˆ¤å®šãŒã‚ã£ãŸã‹
	if (CheckCollisionPoints(points, static_cast<CollisionType>(type), collisionInfo)) {
		// å¿…è¦ã§ã‚ã‚Œã°ImGuiè¡¨ç¤ºã™ã‚‹
		switch (type) {
		case CollisionType::kTop:

			break;
		case CollisionType::kBottom:
			//Logger::Log("hit floor");
			break;
		case CollisionType::kRight:
			//Logger::Log("hit right");
			break;
		case CollisionType::kLeft:
			//Logger::Log("hit left");
			break;
		}
	}
}

Vector3 Player::CornerPosition(const Vector3& center, Corner corner)
{
	Vector3 offsetTable[kNumCorners] = {
		{+status_.kWidth / 2.0f, -status_.kHeight / 2.0f, 0.0f},// å³ä¸‹
		{-status_.kWidth / 2.0f, -status_.kHeight / 2.0f, 0.0f},// å·¦ä¸‹
		{+status_.kWidth / 2.0f, +status_.kHeight / 2.0f, 0.0f},// å³ä¸Š
		{-status_.kWidth / 2.0f, +status_.kHeight / 2.0f, 0.0f},// å·¦ä¸Š
	};
	return center + offsetTable[static_cast<uint32_t>(corner)];
}

bool Player::CheckCollisionPoints(const std::array<Vector3, 2>& posList, CollisionType type, CollisionMapInfo& collisionInfo)
{
	// å½“ãŸã‚Šåˆ¤å®šãƒ•ãƒ©ã‚°
	bool isHit = false;

	for (const auto& pos : posList) {
		// åˆ¤å®šã‚’è¡Œã†ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
		IndexSet index = map_->GetMapChipIndexSetByPosition(pos);
		// ãƒãƒƒãƒ—ãƒãƒƒãƒ—ã®ç¨®é¡ã‚’å–å¾—
		BlockType chip = map_->GetMapChipTypeByIndex(index.xIndex, index.yIndex);

		if (IsHitBlockTable(chip)) {
			isHit = true;
		} else if (IsHitGoalBlockTable(chip)) {
			// ã‚´ãƒ¼ãƒ«å‡¦ç†
			isGoal_ = true;
		}
	}
	// è¡çªã—ã¦ã„ãŸã‚‰ç§»å‹•é‡ã‚’èª¿æ•´
	if (isHit) {
		// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨ä½ç½®ã‚’å–å¾—
		Vector3 position = playerModel_->GetTranslate();
		IndexSet index = map_->GetMapChipIndexSetByPosition(position);

		Rect rect = map_->GetRectByIndex(index.xIndex, index.yIndex);
		// ç§»å‹•é‡ã‚’èª¿æ•´
		switch (type)
		{
		case CollisionType::kTop:
			collisionInfo.celling = true;
			collisionInfo.move.y = (std::max)(0.0f, rect.bottom - position.y - (status_.kHeight / 2.0f + status_.kEpsilon));
			break;
		case CollisionType::kBottom:
			collisionInfo.landing = true;
			collisionInfo.move.y = (std::min)(0.0f, rect.top - position.y + (status_.kHeight / 2.0f + status_.kEpsilon));
			break;
		case CollisionType::kRight:
			collisionInfo.hitWall = true;
			collisionInfo.move.x = (std::max)(0.0f, rect.left - position.x - (status_.kWidth / 2.0f + status_.kEpsilon));
			break;
		case CollisionType::kLeft:
			collisionInfo.hitWall = true;
			collisionInfo.move.x = (std::min)(0.0f, rect.right - position.x + (status_.kWidth / 2.0f + status_.kEpsilon));
			break;
		}
	}
	return isHit;
}

bool Player::IsHitBlockTable(BlockType type)
{
	// åˆ¤å®šã‚’å–ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã®ç¨®é¡ã‹ã©ã†ã‹
	switch (type)
	{
	case BlockType::GrassBlock:
	case BlockType::SoilBlock:
	case BlockType::breakBlock:
	case BlockType::Unbreakable:
		return true;

	default:
		return false;
	}
}

bool Player::IsHitGoalBlockTable(BlockType type)
{
	switch (type) {
	case BlockType::kGoalUp:
	case BlockType::kGoalDown:
		return true;
	default:
		return false;
	}
}

bool Player::IsHitBlockBreakableTable(BlockType type)
{
	switch (type) {
	case BlockType::breakBlock:
		return true;
	default:
		return false;
	}
}

void Player::DebugPlayerReset()
{
	// ãƒ‡ãƒãƒƒã‚°ç”¨ã«ãƒªã‚»ãƒƒãƒˆ
	velocity_ = {};
	playerModel_->SetTranslate({ 1.5f,1.5f,0.0f });
	playerModel_->SetRotate({ 0.0f,0.0f,0.0f });
	isDead_ = false;
	onGround_ = true;
}


void Player::Finalize()
{

}

void Player::ImGui()
{
#ifdef USE_IMGUI
	ImGui::Begin("Player Status");

	if (ImGui::BeginTabBar("Player Status Tab"))
	{
		// ã‚¿ãƒ–ï¼‘ï¼šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼è¨­å®š
		if (ImGui::BeginTabItem("Parameters"))
		{
			ImGui::Text("=== Player Parameters ===");
			ImGui::SliderFloat("Acceleration", &status_.kAcceleration, 0.01f, 0.2f);
			ImGui::SliderFloat("Attenuation", &status_.kAttenuation, 0.0f, 0.5f);
			ImGui::SliderFloat("Max Speed", &status_.kMaxSpeed, 0.05f, 0.5f);
			ImGui::SliderFloat("Dash Speed Scale", &status_.kDashSpeedScale, 1.0f, 5.0f);
			ImGui::SliderFloat("Gravity", &status_.kGravity, 0.01f, 0.2f);
			ImGui::SliderFloat("Max Fall Speed", &status_.kMaxFallSpeed, 0.1f, 2.0f);
			ImGui::SliderFloat("Jump Power", &status_.kJumpPower, 0.1f, 1.0f);
			ImGui::EndTabItem();
		}

		// ã‚¿ãƒ–ï¼’ï¼šæ•µè¡çªãƒ»ç‚¹æ»…é–¢é€£
		if (ImGui::BeginTabItem("Hit Enemy")) {
			// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç”¨ãƒ‡ãƒãƒƒã‚°ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦


			ImGui::Text("=== Enemy Collision / Flashing ===");

			// æ•µãƒ’ãƒƒãƒˆãƒ•ãƒ©ã‚°
			ImGui::Checkbox("isEnemyHit_", &isEnemyHit_);

			// ä»Šã®è¡¨ç¤ºçŠ¶æ…‹
			ImGui::Checkbox("isVisible_", &isVisible_);

			// ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ã‚¿
			ImGui::Text("flashingFrameCount_: %d", flashingFrameCount_);

			// æœ€å¤§ç‚¹æ»…ãƒ•ãƒ¬ãƒ¼ãƒ 
			{
				int tmp = static_cast<int>(maxFlashingFlame_);
				ImGui::DragInt("maxFlashingFlame_", &tmp, 1, 0, 600);
				maxFlashingFlame_ = static_cast<uint32_t>(tmp);
			}

			// ç‚¹æ»…é–“éš”ãƒ•ãƒ¬ãƒ¼ãƒ 
			{
				int tmp = static_cast<int>(flashingIntervalFrame_);
				ImGui::DragInt("flashingIntervalFrame_", &tmp, 1, 1, 120);
				flashingIntervalFrame_ = static_cast<uint32_t>(tmp);
			}

			// ä½™ã‚Šã®ç¢ºèªï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
			if (flashingIntervalFrame_ > 0) {
				int mod = flashingFrameCount_ % flashingIntervalFrame_;
				ImGui::Text("flashingFrameCount_ %% flashingIntervalFrame_ = %d", mod);
			}

			// ç‚¹æ»…ä¸­ã‹ã©ã†ã‹ã®åˆ¤å®šè¡¨ç¤º
			bool isFlashing = (flashingFrameCount_ <= maxFlashingFlame_);
			ImGui::Text("isFlashing: %s", isFlashing ? "true" : "false");

			ImGui::EndTabItem();
		}



		// ã‚¿ãƒ–ï¼“ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±è¡¨ç¤º
		if (ImGui::BeginTabItem("Player Info"))
		{
			ImGui::Text("=== Player Info ===");
			Vector3 pos = playerModel_->GetTranslate();
			Vector3 rotate = playerModel_->GetRotate();
			ImGui::Text("Position: (%.2f, %.2f, %.2f)", pos.x, pos.y, pos.z);
			ImGui::Text("Velocity: (%.2f, %.2f, %.2f)", velocity_.x, velocity_.y, velocity_.z);
			ImGui::Text("Rotate: (%.2f, %.2f, %.2f)", rotate.x, rotate.y, rotate.z);
			ImGui::Text("On Ground: %s", onGround_ ? "Yes" : "No");
			ImGui::Text("Is Dead: %s", isDead_ ? "Yes" : "No");
			ImGui::Text("Is Goal: %s", isGoal_ ? "Yes" : "No");
			ImGui::Text("Direction: %s",
				(direction_ == Direction::kRight) ? "Right" : "Left");
			ImGui::EndTabItem();
		}
		ImGui::EndTabBar();

	}

	ImGui::End();


#endif
}

============================================================
File Path: Game/Application/Player/Player.h
============================================================
#pragma once
#include "engine/math/MyMath.h"
#include <memory>
#include "engine/3d/Object3D.h"
#include "Game/Application/Map/Map.h"
#include "Game/Collision/Collider.h"
/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¯ãƒ©ã‚¹

/// <summary>
/// å‘ã
/// </summary>
enum class Direction {
	kRight,
	kLeft
};

/// <summary>
/// è¡çªæƒ…å ±
/// </summary>
struct CollisionMapInfo {
	// å¤©äº•è¡çª
	bool celling = false;
	// åºŠè¡çª
	bool landing = false;
	// å£è¡çª
	bool hitWall = false;
	// ç§»å‹•é‡
	Vector3 move;
};

/// <summary>
/// ã‚³ãƒ¼ãƒŠãƒ¼
/// </summary>
enum Corner {
	// å³ä¸‹
	kRightBottom,
	// å·¦ä¸‹
	kLeftBottom,
	// å³ä¸Š
	kRightTop,
	// å·¦ä¸Š
	kLeftTop,
	// è¦ç´ æ•°
	kNumCorners
};

/// <summary>
/// è¡çªã‚¿ã‚¤ãƒ—
/// </summary>
enum class CollisionType {
	kTop,
	kBottom,
	kLeft,
	kRight
};

/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ã€€
struct PlayerStatus {
	//é€Ÿåº¦ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	// åŠ é€Ÿåº¦
	float kAcceleration = 0.05f;
	// é€Ÿåº¦æ¸›è¡°ç‡
	float kAttenuation = 0.2f;
	// æœ€å¤§é€Ÿåº¦
	float kMaxSpeed = 0.1f;

	//ãƒ€ãƒƒã‚·ãƒ¥ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	// ãƒ€ãƒƒã‚·ãƒ¥é€Ÿåº¦å€ç‡
	float kDashSpeedScale = 2.0f;
	// ï¼’å›æŠ¼ã—åˆ¤å®šæ™‚é–“
	uint32_t kDashDoubleTapFrame = 15;

	//ã‚¸ãƒ£ãƒ³ãƒ—ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	// é‡åŠ›åŠ é€Ÿåº¦
	float kGravity = 0.05f;
	// æœ€å¤§è½ä¸‹é€Ÿåº¦
	float kMaxFallSpeed = 1.0f;
	// ã‚¸ãƒ£ãƒ³ãƒ—åˆé€Ÿåº¦
	float kJumpPower = 0.5f;
	// æºœã‚æ™‚é–“
	float kMaxChargeTime = 0.2f;

	//å½“ãŸã‚Šåˆ¤å®šãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
	// å¹…
	float kWidth = 0.8f;
	// é«˜ã•
	float kHeight = 0.8f;
	// å½“ãŸã‚Šåˆ¤å®šã®ä½™è£•
	float kBlank = 0.0f;
	// å¾®å°å€¤
	float kEpsilon = 0.05f;

	//æ¸›è¡°ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	// ç€åœ°æ™‚ã®æ¸›è¡°ç‡
	float kAttenuationLanding = 0.1f;
	// å£ã«è¡çªã—ãŸã¨ãã®æ¸›è¡°ç‡
	float kAttenuationWall = 1.0f;

	//æŒ¯ã‚Šå‘ããƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	// è§’åº¦ã®è£œé–“ã‚¿ã‚¤ãƒ 
	float kTurnTime = 0.1f;
};

class Player :public Collider
{
public:
	// ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹
	Collider::Type GetType() const override;
	AABB GetAABB() const override;
	void OnCollision(Collider* other)override;

public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize(Vector3 position);

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();


	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();

private:
	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æŒ™å‹•æ›´æ–°çµ±æ‹¬ / åˆ¤å®š / ç§»å‹• / ãã®ä»–
	/// </summary>
	void UpdateBehavior();

	/// <summary>
	/// ç§»å‹•å‡¦ç†
	/// </summary>
	void Move();

	/// <sumary>
	/// ã‚¸ãƒ£ãƒ³ãƒ—å‡¦ç†
	/// </sumary>
	void Jump();

	/// <summary>
	/// ImGuiè¡¨ç¤º
	/// </summary>
	void ImGui();

	/// <summary>
	/// ãƒãƒƒãƒ—è¡çªãƒã‚§ãƒƒã‚¯
	/// </summary>
	void MapCollision(CollisionMapInfo& collisionInfo);

	/// <sumary>
	/// å¤©äº•è¡çªãƒã‚§ãƒƒã‚¯
	///ã€€å¤©äº•ã«è¡çªã—ãŸã‚‰ç§»å‹•é‡ã‚’èª¿æ•´
	///ã€€</sumary>
	void CellingCollisionMove(CollisionMapInfo& collisionInfo);

	/// <sumary>
	/// åºŠè¡çªãƒã‚§ãƒƒã‚¯
	/// åºŠã«è¡çªã—ãŸã‚‰ç§»å‹•é‡ã‚’èª¿æ•´
	/// </sumary>
	void LandingCollisionMove(CollisionMapInfo& collisionInfo);

	/// <summary>
	/// å£è¡çªãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="collisionInfo"></param>
	void WallCollisionMove(CollisionMapInfo& collisionInfo);

	/// <summary>
	/// è¡çªãƒãƒƒãƒ—æƒ…å ±å–å¾—
	/// </summary>
	/// <param name="info"></param>
	void PlayerCollisionMove(const CollisionMapInfo& info);


	/// <summary>
	/// è¡çªãƒãƒƒãƒ—æƒ…å ±å–å¾—
	/// </summary>
	/// <param name="collisionInfo"></param>
	/// <param name="type"></param>
	/// <param name="checkCorners"></param>
	/// <param name="offset"></param>
	/// <param name="mooveCondition"></param>
	void CollisionMapInfoDirection(
		CollisionMapInfo& collisionInfo,
		CollisionType type,
		const std::array<Corner, 2>& checkCorners,
		const Vector3& offset,
		std::function<bool(const CollisionMapInfo&)>mooveCondition);

	/// <summary>
	/// ã‚³ãƒ¼ãƒŠãƒ¼ä½ç½®å–å¾—
	/// </summary>
	Vector3 CornerPosition(const Vector3& center, Corner corner);

	/// <summary>
	/// å½“ãŸã‚Šåˆ¤å®šãƒã‚¤ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
	/// </summary>
	/// <param name="posList"></param>
	/// <param name="type"></param>
	/// <param name="collisionInfo"></param>
	bool CheckCollisionPoints(const std::array<Vector3, 2>& posList, CollisionType type, CollisionMapInfo& collisionInfo);


	/// <summary>
	/// å½“ãŸã‚Šåˆ¤å®šãƒ–ãƒ­ãƒƒã‚¯ãƒ†ãƒ¼ãƒ–ãƒ«
	/// </summary>
	/// <param name="type">æŒ‡å®šã®ãƒ–ãƒ­ãƒƒã‚¯ã¯åˆ¤å®šã‚’å–ã‚‹ã‹</param>
	/// <returns>å½“ãŸã£ã¦ã„ã‚‹ã‹ã„ãªã„ã‹</returns>
	bool IsHitBlockTable(BlockType type);

	/// <summary>
	/// ã‚´ãƒ¼ãƒ«ãƒ–ãƒ­ãƒƒã‚¯å½“ãŸã‚Šåˆ¤å®šãƒ†ãƒ¼ãƒ–ãƒ«
	/// </summary>
	/// <param name="type">ã‚´ãƒ¼ãƒ«åˆ¤å®šã®ã‚ã‚‹ãƒ–ãƒ­ãƒƒã‚¯</param>
	/// <returns>ã‚´ãƒ¼ãƒ«åˆ¤å®šã®ã‚ã‚‹ãƒ–ãƒ­ãƒƒã‚¯ã‹ã©ã†ã‹</returns>
	bool IsHitGoalBlockTable(BlockType type);

	/// <summary>
	/// å£Šã›ã‚‹ãƒ–ãƒ­ãƒƒã‚¯å½“ãŸã‚Šåˆ¤å®šãƒ†ãƒ¼ãƒ–ãƒ«
	/// </summary>
	/// <param name="type"></param>
	/// <returns></returns>
	bool IsHitBlockBreakableTable(BlockType type);

	/// <summary>
	/// ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ­»äº¡æ™‚ãƒªã‚»ãƒƒãƒˆ
	/// </summary>
	void DebugPlayerReset();

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã«å½“ãŸã£ãŸå ´åˆã®è¡çªå‡¦ç†
	/// </summary>
	void EnemyCollision();

	/// <summary>
	///	ç‚¹æ»…æ›´æ–°å‡¦ç†
	/// </summary>
	void FlashingUpdate();

	/// <summary>
	/// å‘ãã‚’å¤‰æ›´ã—ãŸã¨ãã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¢ãƒ‡ãƒ«ã‚’å›è»¢ã•ã›ã‚‹
	/// </summary>
	void PlayerTurn();


public:	/// Setter / Getter
	// æ­»äº¡åˆ¤å®šã®é«˜ã•ã‚’è¨­å®š
	void SetDeathHeight(float deathHeight) { deathHeight_ = deathHeight; }

	// ãƒãƒƒãƒ—ã®ã‚»ãƒƒãƒˆ
	void SetMap(Map* map) { map_ = map; }

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®æƒ…å ±å–å¾—
	const Vector3 GetTranslate()const { return playerModel_->GetTranslate(); }

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ•µã«ãƒ’ãƒƒãƒˆã—ã¦ã„ã‚‹ã‹ã©ã†ã‹
	bool GetHitEnemy()const { return isEnemyHit_; }
	
	// ã‚´ãƒ¼ãƒ«ã—ã¦ã„ã‚‹ã‹ã©ã†ã‹
	bool GetIsGoal()const { return isGoal_; }

	// æ“ä½œã®æœ‰åŠ¹/ç„¡åŠ¹
	void SetControlEnabled(bool enabled) { controlEnabled_ = enabled; }
	bool IsControlEnabled() const { return controlEnabled_; }


private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹
	PlayerStatus status_;
	// é€Ÿåº¦
	Vector3 velocity_ = {};

	// æ­»äº¡åˆ¤å®šã®é«˜ã• / ç”»é¢å¤–ã«å‡ºãŸã‚‰æ­»äº¡åˆ¤å®šã¨ã™ã‚‹
	float deathHeight_;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ãƒ¢ãƒ‡ãƒ«
	std::unique_ptr<Object3D> playerModel_ = nullptr;

	// æ­»äº¡ãƒ•ãƒ©ã‚°
	bool isDead_ = false;

	// ãƒãƒƒãƒ—
	Map* map_ = nullptr;

	// ã‚´ãƒ¼ãƒ«ãƒ•ãƒ©ã‚°
	bool isGoal_ = false;

	// ã‚¸ãƒ£ãƒ³ãƒ—
	bool onGround_ = true;

	// ãƒ€ãƒƒã‚·ãƒ¥
	bool isDash_ = false;

	// å‘ã / +1:å³ -1:å·¦ 0:ãªã—
	int32_t dashDirection_ = 0;

	// ãƒ€ãƒ–ãƒ«ã‚¿ãƒƒãƒ—åˆ¤å®šç”¨ã‚¿ã‚¤ãƒãƒ¼
	uint32_t rightTapTimer_ = 0;
	uint32_t leftTapTimer_ = 0;

	// ã‚¨ãƒãƒŸãƒ¼ã«å½“ãŸã£ãŸã‹ã©ã†ã‹
	bool isEnemyHit_ = false;
	
	// ç‚¹æ»…ç”¨ãƒ•ãƒ¬ãƒ¼ãƒ ã‚«ã‚¦ãƒ³ãƒˆ
	uint32_t flashingFrameCount_ = 0;
	// ç¾çŠ¶ã®ç‚¹æ»…å›æ•°
	uint32_t flashingCount_ = 0;
	// ç‚¹æ»…æŒç¶šãƒ•ãƒ¬ãƒ¼ãƒ æ•°
	 uint32_t maxFlashingFlame_ = 120;
	// ä½•ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«ç‚¹æ»…ã™ã‚‹ã‹
	 uint32_t flashingIntervalFrame_ = 10;
	// å¯è¦–ãƒ•ãƒ©ã‚°
	bool isVisible_ = true;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä¸€å‘¨
	float playerTurnAround_ = 6.3f;

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‘ã
	Direction direction_ = Direction::kRight;
	float turnSpeed_ = 0.2f;
	float targetYaw_ = 0.0f;


	// æ“ä½œã®æœ‰åŠ¹/ç„¡åŠ¹
	bool controlEnabled_ = true;


};



============================================================
File Path: Game/Application/StageType.cpp
============================================================
#include "StageType.h"


============================================================
File Path: Game/Application/StageType.h
============================================================
#pragma once

enum class StatgeType {
	stage1,
	stage2,
	stage3,
	stage4,
	stage5,
	stage6,
	stage7,
	stage8,
	stage9,
	stage10,
};


============================================================
File Path: Game/Camera/Camera.cpp
============================================================
#include "Camera.h"

Camera::Camera()
	: transform({ {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f} })
	, fovY(0.45f)
	, aspectRatio(float(WinAPI::kClientWidth) / float(WinAPI::kClientHeight))
	, nearClip(0.1f)
	, farClip(100.0f)
	, worldMatrix(MakeAffineMatrix(transform.scale,transform.rotate,transform.translate))
	, viewMatrix(Inverse(worldMatrix))
	, projectionMatrix(MakePerspectiveFovMatrix(fovY, aspectRatio, nearClip, farClip))
	, viewProjectionMatrix(Multiply(viewMatrix, projectionMatrix))
{

}

void Camera::Initialize()
{
}

void Camera::Update()
{
	// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã‹ã‚‰å¤‰æ›è¡Œåˆ—ã‚’è¨ˆç®—
	worldMatrix = MakeAffineMatrix(transform.scale, transform.rotate, transform.translate);
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã®é€†è¡Œåˆ—
	viewMatrix = Inverse(worldMatrix);
	// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—æ›´æ–°
	projectionMatrix = MakePerspectiveFovMatrix(fovY, aspectRatio, nearClip, farClip);
	// ãƒ“ãƒ¥ãƒ¼ãƒãƒˆãƒªãƒƒã‚¯ã‚¹ã®è¨ˆç®—
	viewProjectionMatrix = Multiply(viewMatrix, projectionMatrix);

}

void Camera::Draw()
{
}


============================================================
File Path: Game/Camera/Camera.h
============================================================
#pragma once
#include "MyMath.h"
#include "MakeMatrix.h"
#include "WinAPI.h"

/// ã‚«ãƒ¡ãƒ©ã‚¯ãƒ©ã‚¹
class Camera
{
public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	Camera();
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();
		
public:	
	// setter
	/// <summary>
	/// å›è»¢ãƒ»å¹³è¡Œç§»å‹•ã®è¨­å®š
	/// </summary>
	void SetRotate(const Vector3& rotate) { transform.rotate = rotate; }
	void SetTranslate(const Vector3& translate) { transform.translate = translate; }
	
	/// <summary>
	/// è¦–é‡è§’ã®è¨­å®š
	/// </summary>
	/// <param name="fov"></param>
	void SetFovY(float fov) { this->fovY = fov; }

	/// <summary>
	/// ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”ã®è¨­å®š
	/// </summary>
	/// <param name="aspect"></param>
	void SetAspectRatio(float aspect) { this->aspectRatio = aspect; }

	/// <summary>
	/// ãƒ‹ã‚¢ã‚¯ãƒªãƒƒãƒ—ã®è¨­å®š
	/// </summary>
	/// <param name="nearClip"></param>
	void SetNearClip(float nearClip) { this->nearClip = nearClip; }

	/// <summary>
	/// ãƒ•ã‚¡ãƒ¼ã‚¯ãƒªãƒƒãƒ—ã®è¨­å®š
	/// </summary>
	/// <param name="farClip"></param>
	void SetFarClip(float farClip) { this->farClip = farClip; }

	// getter
	/// <summary>
	/// å„ç¨®è¡Œåˆ—ã®å–å¾—
	/// </summary>
	const Matrix4x4& GetWorldMatrix()const { return worldMatrix; }
	
	/// <summary>
	/// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	const Matrix4x4& GetViewMatrix()const { return viewMatrix; }
	
	/// <summary>
	/// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã®å–å¾—
	/// </summary>
	const Matrix4x4& GetProjectionMatrix()const { return projectionMatrix; }
	
	/// <summary>
	/// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	const Matrix4x4& GetViewProjectionMatrix()const { return viewProjectionMatrix; }
	
	/// <summary> 
	/// æ‹¡ç¸®ãƒ»å›è»¢ãƒ»å¹³è¡Œç§»å‹•ã®å–å¾—
	/// </summary>
	const Vector3& GetScale()const { return transform.scale; }
	const Vector3& GetRotate()const { return transform.rotate; }
	const Vector3& GetTranslate()const { return transform.translate; }


private:
	// ã‚«ãƒ¡ãƒ©ã®å¤‰æ›æƒ…å ±
	Transform transform;
	// æ°´å¹³æ–¹å‘è¦–é‡è§’
	float fovY = 0.45f;
	// ã‚¢ã‚¹ãƒšã‚¯ãƒˆæ¯”
	float aspectRatio = float(WinAPI::kClientWidth) / float(WinAPI::kClientHeight);
	// ãƒ‹ã‚¢ã‚¯ãƒªãƒƒãƒ—
	float nearClip = 0.1f;
	// ãƒ•ã‚¡ãƒ¼ã‚¯ãƒªãƒƒãƒ—
	float farClip = 100.0f;
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—
	Matrix4x4 worldMatrix;
	Matrix4x4 viewMatrix;

	Matrix4x4 projectionMatrix;

	// ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—
	Matrix4x4 viewProjectionMatrix;


};



============================================================
File Path: Game/Camera/CameraController.cpp
============================================================
#include "CameraController.h"

static Vector3 Lerp(const Vector3& a, const Vector3& b, float t)
{
	return a + (b - a) * t;
}

void CameraController::Initialize()
{
}


void CameraController::Update(float deltaTime)
{
    // å‘ãã«å¿œã˜ãŸã€Œç›®æ¨™ã‚ªãƒ•ã‚»ãƒƒãƒˆã€ï¼ˆç†æƒ³å€¤ï¼‰
    float targetOffsetX = 0.0f;
    if (moveDirection > 0) {
        // å³ã«é€²ã‚€ã¨ãï¼šã‚«ãƒ¡ãƒ©ã‚’å°‘ã—å³ã¸ â†’ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ç”»é¢å·¦å¯„ã‚Š
        targetOffsetX = followOffsetX_;
    } else if (moveDirection < 0) {
        // å·¦ã«é€²ã‚€ã¨ãï¼šã‚«ãƒ¡ãƒ©ã‚’å°‘ã—å·¦ã¸ â†’ ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ç”»é¢å³å¯„ã‚Š
        targetOffsetX = -followOffsetX_;
    }
    // moveDirection == 0 ã®ã¨ãã¯ 0ï¼ˆä¸­å¤®ã«æˆ»ã‚‹ï¼‰

    // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’ãªã‚ã‚‰ã‹ã«åˆ‡ã‚Šæ›¿ãˆ
    float ot = offsetLerpSpeed_ * deltaTime;
    if (ot > 1.0f) ot = 1.0f;
    currentOffsetX_ = currentOffsetX_ + (targetOffsetX - currentOffsetX_) * ot;

    // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½® + ã‚ªãƒ•ã‚»ãƒƒãƒˆ = ç†æƒ³ã®ã‚«ãƒ¡ãƒ©ä¸­å¿ƒ
    float centerX = targetPosition_.x + currentOffsetX_;

    // ã‚«ãƒ¡ãƒ©ä¸­å¿ƒã‚’ã‚¹ãƒ†ãƒ¼ã‚¸ç¯„å›²ã§ã‚¯ãƒ©ãƒ³ãƒ—
    if (centerX < leftLimit_)  centerX = leftLimit_;
    if (centerX > rightLimit_) centerX = rightLimit_;

    // ã‚«ãƒ¡ãƒ©ä½ç½®ã‚’ã‚¹ãƒ ãƒ¼ã‚ºã«è¿½å¾“
    float t = followSpeed_ * deltaTime;
    if (t > 1.0f) t = 1.0f;

    Vector3 desired = cameraPosition_;
    desired.x = centerX;

    cameraPosition_ = Lerp(cameraPosition_, desired, t);
}

============================================================
File Path: Game/Camera/CameraController.h
============================================================
#pragma once
#include "engine/math/MyMath.h"
class CameraController
{

public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update(float deltaTime);




public:
	// ä½ç½®ã®ã‚»ãƒƒãƒˆ
	void SetTargetPosition(const Vector3& targetPosition) {
		
		// ç§»å‹•æ–¹å‘ã®åˆ¤å®š
		float dx = targetPosition.x - targetPosition_.x;
		// åˆ¤å®šç”¨ã®å¾®å°å€¤
		const float epsilon = 0.01f;
		// ç§»å‹•æ–¹å‘ã®è¨­å®š
		if (dx > epsilon) {
			moveDirection = 1; // å³ç§»å‹•
		} else if (dx < -epsilon)
		{
			moveDirection = -1; // å·¦ç§»å‹•
		}
		// ç¾åœ¨ã®ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã‚’æ›´æ–°
		targetPosition_ = targetPosition;
	}
	void SetCameraPosition(const Vector3& cameraPosition) { cameraPosition_ = cameraPosition; }
	// ä½ç½®ã®å–å¾—
	const Vector3& GetTargetPosition() const { return targetPosition_; }
	const Vector3& GetCameraPosition() const { return cameraPosition_; }
	// ã‚«ãƒ¡ãƒ©ã®è¿½å¾“ç¯„å›²ã®è¨­å®š
	void SetFollowRange(float leftLimit, float rightLimit) { leftLimit_ = leftLimit; rightLimit_ = rightLimit; };

private:
	// å—ã‘å–ã‚‹å¯¾è±¡ã®ä½ç½®
	Vector3 targetPosition_;

	// å—ã‘å–ã‚‹ã‚«ãƒ¡ãƒ©ã®ä½ç½®
	Vector3 cameraPosition_;

	// ãƒ‡ãƒƒãƒ‰ã‚¾ãƒ¼ãƒ³
	Vector2 deadZone_{ 2.0f, 1.0f };

	// è¿½å¾“é€Ÿåº¦
	float followSpeed_ = 60.0f;

	// ã‚«ãƒ¡ãƒ©ã®ç§»å‹•å¯èƒ½ç¯„å›²
	float leftLimit_ = 8.0f;
	float rightLimit_ = 92.0f;

	// ã©ã¡ã‚‰ã®æ–¹å‘ã«ç§»å‹•ã—ã¦ã„ã‚‹ã‹
	int32_t moveDirection = 0;
	// é€²è¡Œæ–¹å‘ã«å¯¾ã™ã‚‹ã‚«ãƒ¡ãƒ©ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆé‡
	float followOffsetX_ = 3.0f;
	// ç¾åœ¨ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆé‡
	float currentOffsetX_ = 0.0f;
	// ã‚ªãƒ•ã‚»ãƒƒãƒˆã®è£œé–“é€Ÿåº¦
	float offsetLerpSpeed_ = 2.0f;
};



============================================================
File Path: Game/Collision/Collider.cpp
============================================================
#include "Collider.h"


============================================================
File Path: Game/Collision/Collider.h
============================================================
#pragma once
#include "MyMath.h"
struct AABB
{
	Vector3 min;
	Vector3 max;
	
	bool Intersects(const AABB& other)const {
		return	
			(min.x <= other.max.x && max.x >= other.min.x) &&
			(min.y <= other.max.y && max.y >= other.min.y) &&
			(min.z <= other.max.z && max.z >= other.min.z);
	}
};

class Collider
{

public:
	enum class Type
	{
		Player,
		Enemy,
		Static,
	};

	virtual ~Collider() = default;

	virtual Type GetType() const = 0;
	virtual AABB GetAABB() const = 0;

	virtual void OnCollision(Collider* other) = 0;
};



============================================================
File Path: Game/Collision/CollisionManager.cpp
============================================================
#include "CollisionManager.h"

void CollisionManager::AddCollider(Collider* collider)
{
    /// ãƒªã‚¹ãƒˆã«ç™»éŒ²
	colliders.push_back(collider);
}

void CollisionManager::Clear()
{
    ///ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã™ã¹ã¦ã‚’å‰Šé™¤
	colliders.clear();
}

void CollisionManager::CheckAllCollisions()
{
	/// å…¨ã¦ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼åŒå£«ã®è¡çªåˆ¤å®š
    for (size_t i = 0; i < colliders.size(); ++i)
    {
        for (size_t j = i + 1; j < colliders.size(); ++j)
        {
            Collider* a = colliders[i];
            Collider* b = colliders[j];
			/// è¡çªåˆ¤å®š
            if (IsColliding(a, b))
			{
                /// è¡çªã—ã¦ã„ã‚‹å ´åˆã€é€šçŸ¥ã‚’è¡Œã†
                NotifyCollision(a, b);
            }
        }
    }
}

bool CollisionManager::IsColliding(Collider* a, Collider* b) {

    /// ï¼’ã¤ã®åˆ¤å®šã‚’å–ã‚‹
	return a->GetAABB().Intersects(b->GetAABB());

}

void CollisionManager::NotifyCollision(Collider* a, Collider* b) {
    /// è¡çªåˆ¤å®šãŒå–ã‚ŒãŸæ™‚é€šçŸ¥ã™ã‚‹
    a->OnCollision(b);
    b->OnCollision(a);
}

============================================================
File Path: Game/Collision/CollisionManager.h
============================================================
#pragma once
#include "engine/math/MyMath.h"
#include "Game/Collision/Collider.h"
/// <summary>
/// è¡çªåˆ¤å®šç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
class CollisionManager
{
public:
	/// <summary>
	/// åˆ¤å®šå¯¾è±¡è¿½åŠ 
	/// </summary>
	/// <param name="collider"></param>
	void AddCollider(Collider* collider);
	/// <summary>
	/// è¿½åŠ ã•ã‚ŒãŸã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å…¨ã¦å‰Šé™¤
	/// </summary>
	void Clear();
	/// <summary>
	/// å…¨ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼åŒå£«ã®è¡çªåˆ¤å®šã‚’è¡Œã†
	/// </summary>
	void CheckAllCollisions();

private:
	/// <summary>
	/// ï¼’ã¤ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã®è¡çªåˆ¤å®š
	/// </summary>
	bool IsColliding(Collider* a, Collider* b);

	/// <summary>
	/// è¡çªãŒç™ºç”Ÿã—ãŸï¼’ã¤ã®ã‚³ãƒ©ã‚¤ãƒ€ãƒ¼ã«é€šçŸ¥ã‚’è¡Œã†
	/// </summary>
	void NotifyCollision(Collider* a, Collider* b);

private:
	/// <summary>
	/// åˆ¤å®šå¯¾è±¡ãƒªã‚¹ãƒˆ
	/// </summary>
	std::vector<Collider*>colliders;
	
	
};



============================================================
File Path: Game/Loader/LevelLoader.cpp
============================================================
#include "LevelLoader.h"
#ifdef USE_IMGUI
#include "ImguiManager.h"
#endif
void LevelLoader::Load(const std::string& fileName)
{
	const std::string kDefaultBaseDirectory = "resources/levels/stage/";
	const std::string kExtension = ".json";
	const std::string fullPath = kDefaultBaseDirectory + fileName + kExtension;
	const std::string objPath = ".obj";

	/// ãƒ•ã‚¡ã‚¤ãƒ«ã‚¹ãƒˆãƒªãƒ¼ãƒ 
	std::ifstream file;

	/// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	file.open(fullPath);
	/// ãƒ•ã‚¡ã‚¤ãƒ«ã‚ªãƒ¼ãƒ—ãƒ³ã®æˆå¦
	if (file.fail()) {
		assert(0);
	}


	/// JSONæ–‡å­—åˆ—
	nlohmann::json deserialized;
	/// ãƒ‘ãƒ¼ã‚¹(è§£å‡)
	file >> deserialized;

	/// æ­£ã—ã„ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«ã‹ç¢ºèª
	assert(deserialized.is_object());
	assert(deserialized.contains("name"));
	assert(deserialized["name"].is_string());

	/// "name"ã‚’æ–‡å­—åˆ—ã¨ã—ã¦å–å¾—
	std::string name = deserialized["name"].get<std::string>();

	/// æ­£ã—ã„ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¤ãƒ«
	assert(name.compare("scene") == 0);

	/// ãƒ¬ãƒ™ãƒ«ãƒ‡ãƒ¼ã‚¿æ ¼ç´ç”¨ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	levelData = new LevelData();

	/// "Objects"ã®å…¨ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’èµ°æŸ»
	for (nlohmann::json& object : deserialized["objects"]) {
		assert(object.contains("type"));

		/// ç¨®åˆ¥ã‚’å–å¾—
		std::string type = object["type"].get<std::string>();


		// MESH
		if (type.compare("MESH") == 0) {
			
			/// ç„¡åŠ¹ãƒ•ãƒ©ã‚°ãŒã‚ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
			if (object.contains("disabled_flag") && object["disabled_flag"].get<bool>()) {
				continue;
			}
			
			/// ObjectDataè¦ç´ è¿½åŠ 
			levelData->objects.emplace_back(LevelLoader::ObjectData{});
			/// è¿½åŠ ã—ãŸè¦ç´ ã®å‚ç…§ã‚’å¾—ã‚‹
			LevelLoader::ObjectData& objectData = levelData->objects.back();
			
			if (object.contains("file_name")) {
				objectData.fileName = object["file_name"];
			}
			else if (object.contains("name")) {
				objectData.fileName = object["name"];
			}
			/// ãƒ•ã‚¡ã‚¤ãƒ«åã«æ‹¡å¼µå­ã‚’è¿½åŠ 
			objectData.fileName += objPath;


			/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿
			nlohmann::json& transform = object["transform"];
			// Translate
			objectData.transform.translate.x = (float)transform["translation"][0];
			objectData.transform.translate.y = (float)transform["translation"][2];
			objectData.transform.translate.z = (float)transform["translation"][1];
			// Rotate
			objectData.transform.rotate.x = (float)transform["rotation"][0];
			objectData.transform.rotate.y = (float)transform["rotation"][2];
			objectData.transform.rotate.z = (float)transform["rotation"][1];
			// Scale
			objectData.transform.scale.x = (float)transform["scaling"][0];
			objectData.transform.scale.y = (float)transform["scaling"][2];
			objectData.transform.scale.z = (float)transform["scaling"][1];


		}
		else if (type.compare("PlayerSpawn") == 0) {

			/// ç„¡åŠ¹ãƒ•ãƒ©ã‚°ãŒã‚ã‚‹å ´åˆã¯ã‚¹ã‚­ãƒƒãƒ—
			if (object.contains("disabled_flag") && object["disabled_flag"].get<bool>()) {
				continue;
			}

			/// æ–°ã—ã„ PlayerSpawnData ã‚’è¿½åŠ 
			levelData->playerSpawn.emplace_back(LevelLoader::PlayerSpawnData{});
			LevelLoader::PlayerSpawnData& spawnData = levelData->playerSpawn.back();

			/// ãƒ•ã‚¡ã‚¤ãƒ«åã®èª­ã¿è¾¼ã¿
			if (object.contains("file_name")) {
				spawnData.fileName = object["file_name"];
			} else if (object.contains("name")) {
				spawnData.fileName = object["name"];
			}

			/// å¿…è¦ã«å¿œã˜ã¦æ‹¡å¼µå­ã‚’è¿½åŠ ï¼ˆä¾‹ãˆã° ".obj"ï¼‰
			spawnData.fileName += objPath;

			// Transform
			const auto& transform = object["transform"];
			// Translate
			spawnData.transform.translate.x = static_cast<float>(transform["translation"][0]);
			spawnData.transform.translate.y = static_cast<float>(transform["translation"][2]);
			spawnData.transform.translate.z = static_cast<float>(transform["translation"][1]);
			// Rotate
			spawnData.transform.rotate.x = static_cast<float>(transform["rotation"][0]);
			spawnData.transform.rotate.y = static_cast<float>(transform["rotation"][2]);
			spawnData.transform.rotate.z = static_cast<float>(transform["rotation"][1]);

			
		}





		/// @ ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆèµ°æŸ»ã‚’å†å¸°é–¢æ•°ã«ã¾ã¨ã‚ã€å†å¸°å‘¼ã³å‡ºã—ã§æã‚’èµ°æŸ»ã™ã‚‹
		if (object.contains("Children")) {

		}
	}
}

void LevelLoader::CreateObject()
{
	// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ç”Ÿæˆã€é…ç½®
	for (auto& objectData : levelData->objects) {
		// ãƒ¢ãƒ‡ãƒ«ã‚’æŒ‡å®šã—ã¦3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ç”Ÿæˆ
		std::unique_ptr<Object3D> newObject = std::make_unique<Object3D>();
		newObject->Initialize();
		newObject->SetModel(objectData.fileName);
		newObject->SetTransform(objectData.transform);
		// ç™»éŒ²
		objects.push_back(std::move(newObject));
	}
}



void LevelLoader::Update()
{
	for (auto& object : objects) {
		if (object) {
#ifdef USE_IMGUI
			// ImGuiã§åº§æ¨™å¤‰æ›´UIã‚’è¡¨ç¤º
			ImGui::Begin("Object Transform");

			Vector3 pos = object->GetTranslate();
			if (ImGui::DragFloat3("Position", &pos.x, 0.1f)) {
				object->SetTranslate(pos);
			}

			Vector3 rot = object->GetRotate();
			if (ImGui::DragFloat3("Rotation", &rot.x, 0.1f)) {
				object->SetRotate(rot);
			}

			Vector3 scale = object->GetScale();
			if (ImGui::DragFloat3("Scale", &scale.x, 0.1f)) {
				object->SetScale(scale);
			}

			ImGui::End();
#endif
			object->Update();
		}
	}
}


void LevelLoader::Draw()
{
#ifdef _DEBUG

#endif

	/// ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»
	for (auto& object : objects) {
		object->Draw();
	}
}


const std::vector<LevelLoader::PlayerSpawnData>& LevelLoader::getPlayerSpawns() const
{
	assert(levelData);
	return levelData->playerSpawn;
}

bool LevelLoader::HasPlayerSpawn() const
{
	assert(levelData);
	return !levelData->playerSpawn.empty();
}

============================================================
File Path: Game/Loader/LevelLoader.h
============================================================
#pragma once  
#include <string>  
#include <fstream>  
#include <cassert>  
#include "resources/json/json.hpp"  
#include "engine/math/MyMath.h"  
#include "engine/3d/Model.h"
#include "engine/3d/Object3D.h"
class LevelLoader  
{  
public:  
    struct ObjectData {  
        Transform transform; 
        std::string fileName;
    };  

    struct PlayerSpawnData {
		Transform transform;
		std::string fileName;
	};

    struct LevelData {  
        std::vector<ObjectData> objects; 
		std::vector<PlayerSpawnData> playerSpawn;
    }; 

    const std::vector<PlayerSpawnData>& getPlayerSpawns()const;
    bool HasPlayerSpawn()const;


public:  
    /// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€  
    void Load(const std::string& jsonFilePath);  

    ///
    void CreateObject();
    /// <summary>
	/// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update();
	/// <summary>
	///  æç”»å‡¦ç†
	/// </summary>
	void Draw();



private:
    LevelData* levelData;

    std::unordered_map<std::string, Model*> models;
	std::vector<std::unique_ptr<Object3D>> objects;

};


============================================================
File Path: Game/Particle/EffectEmitter.cpp
============================================================
#include "EffectEmitter.h"
EffectEmitter::EffectEmitter()
{
}

EffectEmitter::~EffectEmitter()
{

}

void EffectEmitter::Update()
{
	// EmitCylinder();
	//EmitRing();
}

void EffectEmitter::EmitCylinder() 
{
	EffectManager::GetInstance()->EmitCylinder(effectName, emitter.transform, 1);
}

void EffectEmitter::EmitRing()
{
	EffectManager::GetInstance()->EmitRing(effectName, emitter.transform, 2);
}


============================================================
File Path: Game/Particle/EffectEmitter.h
============================================================
#pragma once
#include "EffectManager.h"
#include "engine/math/Mymath.h"
/// <summary>
/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¨ãƒŸãƒƒã‚¿ã‚¯ãƒ©ã‚¹
/// </summary>
class EffectEmitter
{
public:
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	EffectEmitter();
	~EffectEmitter();

	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç™ºç”Ÿ
	/// </summary>
	void EmitCylinder();
	void EmitRing();

	// Getter / Setter
	/// <summary>
	/// ã‚¨ãƒŸãƒƒã‚¿ã®Transformè¨­å®šãƒ»å–å¾—
	/// </summary>
	Transform GetTransform() { return emitter.transform; }
	void SetTransform(const Transform& transform) { emitter.transform = transform; }

	void SetEffectName(const std::string& name) { effectName = name; }
private:
	struct Emitter {
		Transform transform;		// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®TRANSAM
		float lifeTime;				// ç™ºç”Ÿæ™‚é–“
	};
	// ç™ºç”Ÿã•ã›ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æƒ…å ±
	Emitter emitter;

	// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒãƒ¼ãƒ 
	std::string effectName;

};



============================================================
File Path: Game/Particle/EffectManager.cpp
============================================================
#include "EffectManager.h"
#include <Logger.h>
#include "MakeMatrix.h"
#include <TextureManager.h>
#include "WinAPI.h"
#include <numbers>

EffectManager* EffectManager::instance = nullptr;

EffectManager* EffectManager::GetInstance()
{
	if (instance == nullptr)
	{
		instance = new EffectManager();
	}
	return instance;
}

void EffectManager::DeleteInstance()
{
	delete instance;
	instance = nullptr;
}

void EffectManager::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, Camera* camera)
{
	// å„ç¨®å–å¾—
	this->dxCommon = dxCommon;
	this->srvManager = srvManager;
	this->camera = camera;
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š
	blendMode = BlendMode::kBlendModeAdd;

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	CreatePipeline();

	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	CreateRingVertex();
	CreateCylinderVertex();

	// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ–
	InitializeMaterial();
}

void EffectManager::Update()
{
	// è¡Œåˆ—ã®æ›´æ–°
	UpdateMatrix();
	
	uvOffset.x += uvScrollSpeed.x * kDeltaTime;
	uvOffset.y += uvScrollSpeed.y * kDeltaTime;

	// wrap (0ã€œ1ã®ç¯„å›²ã«ä¿ã¤)
	uvOffset.x = std::fmod(uvOffset.x, 5.0f);
	uvOffset.y = std::fmod(uvOffset.y, 5.0f);
	materialData->uvTransform = MakeTranslateMatrix({ uvOffset.x, uvOffset.y, 0.0f });

	// æ›´æ–°ã—ãŸè¡Œåˆ—ã‚’GPUã«é€ã‚‹
	UpdateEffectInstanceData();
}



void EffectManager::CreateEffectGroup(const std::string& name, const std::string textureFilrPath)
{
	// ç™»éŒ²æ¸ˆã¿ã®åå‰ã‹ç¢ºèª
	if (effectGroups.contains(name)) {
		// ç™»éŒ²ã•ã‚Œã¦ã„ãŸã‚‰ãƒªã‚¿ãƒ¼ãƒ³
		Logger::Log("ã™ã§ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚°ãƒ«ãƒ¼ãƒ—åã§ã™");
		return;
	}
	// æ–°ãŸãªç©ºã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã—ã¦ã‚³ãƒ³ãƒ†ãƒŠã«ç™»éŒ²
	effectGroups[name] = EffectGroup();

	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	EffectGroup& effectGroup = effectGroups[name];

	// æ–°ãŸãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
	effectGroup.materialData.textureFilePath = textureFilrPath;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿
	TextureManager::GetInstance()->LoadTexture(effectGroup.materialData.textureFilePath);
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã«ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨­å®š
	effectGroup.materialData.textureIndex = TextureManager::GetInstance()->GetSrvIndex(effectGroup.materialData.textureFilePath);
	// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	effectGroup.instancingResource = dxCommon->CreateBufferResource(sizeof(ParticleForGPU) * kMaxEffectCount);
	effectGroup.srvIndex = srvManager->Allocate();
	// æ›¸ãè¾¼ã‚€ç‚ºã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	effectGroup.instancingResource->Map(0, nullptr, reinterpret_cast<void**>(&effectGroup.instancingData));

	srvManager->CreateSRVforStructuredBuffer(effectGroup.srvIndex, effectGroup.instancingResource.Get(), kMaxEffectCount, sizeof(ParticleForGPU));

	// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ã‚’åˆæœŸåŒ–
	effectGroup.kNumInstance = 0;
}

void EffectManager::DeleteEffectGroup(const std::string& name)
{
	auto it = effectGroups.find(name);
	if (it != effectGroups.end()) {
		// Unmapã§ãƒªãƒ¼ã‚¯ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
		if (it->second.instancingResource) {
			it->second.instancingResource->Unmap(0, nullptr);
			it->second.instancingData = nullptr; // ãƒã‚¤ãƒ³ã‚¿ã®ç„¡åŠ¹åŒ–
			it->second.instancingResource.Reset(); // ComPtrã®è§£æ”¾
		}

		// SRVã®è§£æ”¾ã‚‚ï¼ˆã‚‚ã—å¿…è¦ã§ã‚ã‚Œã°ï¼‰
		// srvManager->Release(it->second.srvIndex); // å¿…è¦ãªã‚‰

		// Mapã‹ã‚‰å‰Šé™¤
		effectGroups.erase(it);
	}
}

void EffectManager::EmitCylinder(const std::string& name, const Transform& transform, uint32_t count)
{
	// ç™»éŒ²æ¸ˆã¿ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚°ãƒ«ãƒ¼ãƒ—åã‹ç¢ºèª
	auto it = effectGroups.find(name);
	// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
	assert(it != effectGroups.end());
	// æŒ‡å®šã•ã‚ŒãŸã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
	EffectGroup& group = it->second;
	for (uint32_t i = 0; i < count; ++i) {
		EffectInstance effect;
		effect.transform = transform;
		effect.color = { 1.0f, 1.0f, 1.0f, 1.0f };
		effect.lifeTime = 1.0f;
		effect.currentTime = 0.0f;
		group.cylinderEffects.push_back(effect);
	}
}

void EffectManager::EmitRing(const std::string& name, const Transform& transform, uint32_t count)
{
	// ç™»éŒ²æ¸ˆã¿ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚°ãƒ«ãƒ¼ãƒ—åã‹ç¢ºèª
	auto it = effectGroups.find(name);
	// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
	assert(it != effectGroups.end());
	// æŒ‡å®šã•ã‚ŒãŸã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
	EffectGroup& group = it->second;
	for (uint32_t i = 0; i < count; ++i) {
		EffectInstance effect;
		effect.transform = transform;
		effect.color = { 1.0f, 1.0f, 1.0f, 1.0f };
		effect.lifeTime = 1.0f;
		effect.currentTime = 0.0f;
		group.ringEffects.push_back(effect);
	}
}




void EffectManager::CreateRingVertex()
{
	std::vector<VertexData> vertices;
	const uint32_t kRingDivide = 32;
	const float kOuterRadius = 1.0f;
	const float kInnerRadius = 0.2f;
	const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kRingDivide);

	for (uint32_t i = 0; i < kRingDivide; ++i) {
		float angle0 = i * radianPerDivide;
		float angle1 = (i + 1) * radianPerDivide;

		float sin0 = std::sin(angle0);
		float cos0 = std::cos(angle0);
		float sin1 = std::sin(angle1);
		float cos1 = std::cos(angle1);

		// å¤–å´ãƒ»å†…å´ã®å„ç‚¹
		Vector4 outer0 = { sin0 * kOuterRadius, cos0 * kOuterRadius, 0.0f, 1.0f };
		Vector4 outer1 = { sin1 * kOuterRadius, cos1 * kOuterRadius, 0.0f, 1.0f };
		Vector4 inner0 = { sin0 * kInnerRadius, cos0 * kInnerRadius, 0.0f, 1.0f };
		Vector4 inner1 = { sin1 * kInnerRadius, cos1 * kInnerRadius, 0.0f, 1.0f };

		Vector2 uvOuter0 = { float(i) / kRingDivide, 0.0f };
		Vector2 uvOuter1 = { float(i + 1) / kRingDivide, 0.0f };
		Vector2 uvInner0 = { float(i) / kRingDivide, 1.0f };
		Vector2 uvInner1 = { float(i + 1) / kRingDivide, 1.0f };

		Vector3 normal = { 0.0f, 0.0f, 1.0f };

		// ä¸‰è§’å½¢ 1ï¼ˆouter0, outer1, inner0ï¼‰
		vertices.push_back({ outer0, uvOuter0, normal });
		vertices.push_back({ outer1, uvOuter1, normal });
		vertices.push_back({ inner0, uvInner0, normal });

		// ä¸‰è§’å½¢ 2ï¼ˆinner0, outer1, inner1ï¼‰
		vertices.push_back({ inner0, uvInner0, normal });
		vertices.push_back({ outer1, uvOuter1, normal });
		vertices.push_back({ inner1, uvInner1, normal });
	}

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®ä½œæˆ
	size_t vertexSize = sizeof(VertexData) * vertices.size();

	Microsoft::WRL::ComPtr<ID3D12Resource> vertexBuffer;
	D3D12_HEAP_PROPERTIES heapProp{};
	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;

	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Width = vertexSize;
	resourceDesc.Height = 1;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.SampleDesc.Count = 1;
	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	dxCommon->GetDevice()->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertexBuffer));

	VertexData* mapData = nullptr;
	vertexBuffer->Map(0, nullptr, reinterpret_cast<void**>(&mapData));
	memcpy(mapData, vertices.data(), vertexSize);
	vertexBuffer->Unmap(0, nullptr);

	D3D12_VERTEX_BUFFER_VIEW vbView{};
	vbView.BufferLocation = vertexBuffer->GetGPUVirtualAddress();
	vbView.SizeInBytes = static_cast<UINT>(vertexSize);
	vbView.StrideInBytes = sizeof(VertexData);

	ringVertexBuffer = vertexBuffer;
	ringVertexBufferView = vbView;
	ringVertexCount = static_cast<uint32_t>(vertices.size());
}

void EffectManager::CreateCylinderVertex()
{
	std::vector<VertexData> vertices;
	const uint32_t kCylinderDivide = 32;
	const float kTopRadius = 1.0f;
	const float kBottomRadius = 1.0f;
	const float kHeight = 3.0f;
	const float halfHeight = kHeight * 0.5f;
	const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kCylinderDivide);

	for (uint32_t i = 0; i < kCylinderDivide; ++i) {
		float angle0 = i * radianPerDivide;
		float angle1 = (i + 1) * radianPerDivide;

		float sin0 = std::sin(angle0);
		float cos0 = std::cos(angle0);
		float sin1 = std::sin(angle1);
		float cos1 = std::cos(angle1);

		float u0 = float(i) / float(kCylinderDivide);
		float u1 = float(i + 1) / float(kCylinderDivide);

		Vector4 top0 = { sin0 * kTopRadius, +halfHeight, cos0 * kTopRadius, 1.0f };
		Vector4 top1 = { sin1 * kTopRadius, +halfHeight, cos1 * kTopRadius, 1.0f };
		Vector4 bottom0 = { sin0 * kBottomRadius, -halfHeight, cos0 * kBottomRadius, 1.0f };
		Vector4 bottom1 = { sin1 * kBottomRadius, -halfHeight, cos1 * kBottomRadius, 1.0f };

		Vector2 uvTop0 = { u0, 0.0f };
		Vector2 uvTop1 = { u1, 0.0f };
		Vector2 uvBottom0 = { u0, 1.0f };
		Vector2 uvBottom1 = { u1, 1.0f };

		Vector3 normal0 = Vector3{ sin0, 0.0f, cos0 }.Normalized();
		Vector3 normal1 = Vector3{ sin1, 0.0f, cos1 }.Normalized();

		vertices.push_back({ top0,    uvTop0,    normal0 });
		vertices.push_back({ top1,    uvTop1,    normal1 });
		vertices.push_back({ bottom0, uvBottom0, normal0 });

		vertices.push_back({ top1,    uvTop1,    normal1 });
		vertices.push_back({ bottom1, uvBottom1, normal1 });
		vertices.push_back({ bottom0, uvBottom0, normal0 });
	}

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®ä½œæˆ
	size_t vertexSize = sizeof(VertexData) * vertices.size();

	Microsoft::WRL::ComPtr<ID3D12Resource>vertexBuffer;
	D3D12_HEAP_PROPERTIES heapProp{};
	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;

	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Width = vertexSize;
	resourceDesc.Height = 1;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.SampleDesc.Count = 1;
	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	HRESULT hr = dxCommon->GetDevice()->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertexBuffer));
	assert(SUCCEEDED(hr));

	VertexData* mapData = nullptr;
	vertexBuffer->Map(0, nullptr, reinterpret_cast<void**>(&mapData));
	memcpy(mapData, vertices.data(), vertexSize);
	vertexBuffer->Unmap(0, nullptr);

	D3D12_VERTEX_BUFFER_VIEW vbView{};
	vbView.BufferLocation = vertexBuffer->GetGPUVirtualAddress();
	vbView.SizeInBytes = static_cast<UINT>(vertexSize);
	vbView.StrideInBytes = sizeof(VertexData);

	cylinderVertexBuffer = vertexBuffer;
	cylinderVertexBufferView = vbView;
	cylinderVertexCount = static_cast<uint32_t>(vertices.size());
}

void EffectManager::DrawRing()
{
	// ã‚³ãƒãƒ³ãƒ‰ : ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’è¨­å®š
	dxCommon->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
	// ã‚³ãƒãƒ³ãƒ‰ : ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¨­å®š
	dxCommon->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
	// ã‚³ãƒãƒ³ãƒ‰ : ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒãƒ­ã‚¸(æç”»å½¢çŠ¶)ã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	// ã‚³ãƒãƒ³ãƒ‰ : Ringç”¨ã®VertexBufferViewã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetVertexBuffers(0, 1, &ringVertexBufferView);
	// ã‚³ãƒãƒ³ãƒ‰ : ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã‚’è¨­å®š
	dxCommon->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());

	for (auto& [name, effectGroup] : effectGroups) {
		// Skip: ãƒªãƒ³ã‚°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãŒ1ã¤ã‚‚ãªã„å ´åˆ
		if (effectGroup.ringEffects.empty()) {
			continue;
		}

		// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°
		srvManager->SetGraphicsDescriptorTable(1, effectGroup.srvIndex);

		// ãƒ†ã‚¯ã‚¹ãƒãƒ£SRV
		D3D12_GPU_DESCRIPTOR_HANDLE textureHandle = srvManager->GetGPUDescriptorHandle(effectGroup.materialData.textureIndex);
		dxCommon->GetCommandList()->SetGraphicsRootDescriptorTable(2, textureHandle);

		// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®æç”»ï¼ˆæ­£ã—ã„ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ã‚’æŒ‡å®šï¼‰
		dxCommon->GetCommandList()->DrawInstanced(ringVertexCount, 1, 0, 0);
	}
}


void EffectManager::DrawCylinder()
{
	// ã‚³ãƒãƒ³ãƒ‰ : ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’è¨­å®š
	dxCommon->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
	// ã‚³ãƒãƒ³ãƒ‰ : ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¨­å®š
	dxCommon->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
	// ã‚³ãƒãƒ³ãƒ‰ : ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒ­ãƒã‚¸(æç”»å½¢çŠ¶)ã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	// ã‚³ãƒãƒ³ãƒ‰ : Cylinderç”¨ã®VertexBufferViewã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetVertexBuffers(0, 1, &cylinderVertexBufferView);
	// ã‚³ãƒãƒ³ãƒ‰ : ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã‚’è¨­å®š
	dxCommon->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());

	for (auto& [name, effectGroup] : effectGroups) {
		if (effectGroup.cylinderEffects.empty()) {
			continue;
		}
		// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°
		srvManager->SetGraphicsDescriptorTable(1, effectGroup.srvIndex);
		
		// ãƒ†ã‚¯ã‚¹ãƒãƒ£SRV index = 0(ä»®)
		D3D12_GPU_DESCRIPTOR_HANDLE textureHandle = srvManager->GetGPUDescriptorHandle(effectGroup.materialData.textureIndex);
		dxCommon->GetCommandList()->SetGraphicsRootDescriptorTable(2, textureHandle);
		// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®æç”»
		dxCommon->GetCommandList()->DrawInstanced(cylinderVertexCount, 1, 0, 0);
	}


}

#pragma region å†…éƒ¨å‡¦ç† / åˆæœŸåŒ–
void EffectManager::CreatePipeline()
{
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	CreateRootSignature();
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	SetGraphicsPipeline();
}

void EffectManager::CreateRootSignature()
{
	D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
	D3D12_DESCRIPTOR_RANGE descriptorRangeInstancing[1] = {};
	descriptorRange[0].BaseShaderRegister = 0; // 0ã‹ã‚‰å§‹ã¾ã‚‹
	descriptorRange[0].NumDescriptors = 1; // æ•°ã¯1ã¤
	descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRV
	descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—

	// 1. RootSignatureã®ä½œæˆ
	descriptionRootSignature.Flags =
		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	// RootParameterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚
	// 0.Material
	rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters[0].Descriptor.ShaderRegister = 0;

	// 1. ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®RootSignatureã®ä½œæˆ
	descriptorRangeInstancing[0].BaseShaderRegister = 0;
	descriptorRangeInstancing[0].NumDescriptors = 1;
	descriptorRangeInstancing[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
	descriptorRangeInstancing[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;
	// 1.TransformMatrix
	rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
	rootParameters[1].DescriptorTable.pDescriptorRanges = descriptorRangeInstancing;
	rootParameters[1].DescriptorTable.NumDescriptorRanges = _countof(descriptorRangeInstancing);
	// 2.Texture
	rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters[2].DescriptorTable.pDescriptorRanges = descriptorRange;
	rootParameters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange);

	descriptionRootSignature.pParameters = rootParameters;
	descriptionRootSignature.NumParameters = _countof(rootParameters);

	// Samplerã®è¨­å®š
	staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR; // ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿
	staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP; // 0~1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ
	staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
	staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER; // æ¯”è¼ƒã—ãªã„
	staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX; // ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†
	staticSamplers[0].ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†
	staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
	descriptionRootSignature.pStaticSamplers = staticSamplers;
	descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

	// ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒã‚¤ãƒŠãƒªã«ã™ã‚‹
	Microsoft::WRL::ComPtr<ID3DBlob> signatureBlob = nullptr;
	Microsoft::WRL::ComPtr<ID3DBlob> errorBlob = nullptr;
	HRESULT hr = D3D12SerializeRootSignature(&descriptionRootSignature,
		D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(hr)) {
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	// ãƒã‚¤ãƒŠãƒªã‚’å…ƒã«ç”Ÿæˆ
	hr = dxCommon->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(),
		signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
	assert(SUCCEEDED(hr));



	// 2. InputLayoutã®è¨­å®š
	inputElementDescs[0].SemanticName = "POSITION";
	inputElementDescs[0].SemanticIndex = 0;
	inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs[1].SemanticName = "TEXCOORD";
	inputElementDescs[1].SemanticIndex = 0;
	inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs[2].SemanticName = "NORMAL";
	inputElementDescs[2].SemanticIndex = 0;
	inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	inputLayoutDesc.pInputElementDescs = inputElementDescs;
	inputLayoutDesc.NumElements = _countof(inputElementDescs);

	// 3. BlendDtateã®è¨­å®š
	blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
	blendDesc.RenderTarget[0].BlendEnable = true;

	SetBlendMode(blendDesc, blendMode);
	currentBlendMode = BlendMode::kBlendModeAdd;  // ç¾åœ¨ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰
	// Î±å€¤ã®ãƒ–ãƒ¬ãƒ³ãƒ‰
	blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;
	blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;
	// RasterrizerStateã®è¨­å®š
	// ã‚«ãƒªãƒ³ã‚°ãªã—
	rasterrizerDesc.CullMode = D3D12_CULL_MODE_NONE;
	// å¡—ã‚Šã¤ã¶ã—ãƒ¢ãƒ¼ãƒ‰
	rasterrizerDesc.FillMode = D3D12_FILL_MODE_SOLID;
	// 4. Shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	vertexShaderBlob = dxCommon->CompileShader(L"resources/shaders/Particle.VS.hlsl",
		L"vs_6_0");
	assert(vertexShaderBlob != nullptr);
	pixelShaderBlob = dxCommon->CompileShader(L"resources/shaders/Particle.PS.hlsl",
		L"ps_6_0");
	assert(pixelShaderBlob != nullptr);

	// DepthStencilStateã®è¨­å®š
	// Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
	depthStencilDesc.DepthEnable = true;
	//æ›¸ãè¾¼ã¿ã—ã¾ã™
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
	//æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
}

void EffectManager::SetBlendMode(D3D12_BLEND_DESC& desc, BlendMode mode)
{
	switch (mode)
	{
	case kBlendModeAdd:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;
		break;
	case kBlendModeSubtract:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_REV_SUBTRACT;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;
		break;
	case kBlendModeMultiply:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_DEST_COLOR;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ZERO;
		break;
	case kBlendModeScreen:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_COLOR;
		break;
	default:
		assert(false);
		break;
	}
}

void EffectManager::SetGraphicsPipeline()
{
	graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();
	graphicsPipelineStateDesc.InputLayout = inputLayoutDesc;
	graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),
										vertexShaderBlob->GetBufferSize() };
	graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),
										pixelShaderBlob->GetBufferSize() };
	graphicsPipelineStateDesc.BlendState = blendDesc;
	graphicsPipelineStateDesc.RasterizerState = rasterrizerDesc;
	// Depthstencitã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
	// æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	// åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸ï¼ˆå½¢çŠ¶ï¼‰ã®ã‚¿ã‚¤ãƒ—ã€‚ä¸‰è§’å½¢
	graphicsPipelineStateDesc.PrimitiveTopologyType =
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	// ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã®ã‹è¨­å®šï¼ˆæ°—ã«ã—ãªãã¦è‰¯ã„ï¼‰
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	// å®Ÿéš›ã«ç”Ÿæˆ
	HRESULT hr = dxCommon->GetDevice()->CreateGraphicsPipelineState(&graphicsPipelineStateDesc,
		IID_PPV_ARGS(&graphicsPipelineState));
	assert(SUCCEEDED(hr));

}

void EffectManager::InitializeMaterial()
{
	materialResource = dxCommon->CreateBufferResource(sizeof(Material));
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã«æ›¸ãè¾¼ã¿
	materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	//materialData->color = Vector4(0.3f, 1.0f, 0.7f, 1.0f);
	materialData->color = Vector4(1.0f, 1.0f, 1.0f, 1.0f);
	materialData->enableLighting = true;
	materialData->uvTransform = MakeIdentity4x4();
}

#pragma endregion

#pragma region å†…éƒ¨å‡¦ç† / æ›´æ–°
void EffectManager::UpdateMatrix()
{
	// ã‚«ãƒ¡ãƒ©è¡Œåˆ—ã®å–å¾—
	cameraMatrix = camera->GetWorldMatrix();
	// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®å–å¾—
	viewMatrix = camera->GetViewMatrix();
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰æ—¥è¡Œåˆ—ã®å–å¾—
	backToFrontMatrix = MakeRotateYMatrix(std::numbers::pi_v<float>);

	// ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰ç”¨ã®è¡Œåˆ—
	billboardMatrix = Multiply(backToFrontMatrix, cameraMatrix);
	billboardMatrix.m[3][0] = 0.0f;
	billboardMatrix.m[3][1] = 0.0f;
	billboardMatrix.m[3][2] = 0.0f;
}

void EffectManager::UpdateEffectInstanceData()
{
	for (auto& [name, group] : effectGroups) {
		group.kNumInstance = 0;

		for (const auto& effect : group.cylinderEffects) {
			if (group.kNumInstance >= kMaxEffectCount) break;

			Matrix4x4 world = MakeAffineMatrix(effect.transform.scale, effect.transform.rotate, effect.transform.translate);
			Matrix4x4 wvp = Multiply(world, camera->GetViewProjectionMatrix());

			group.instancingData[group.kNumInstance].WVP = wvp;
			group.instancingData[group.kNumInstance].World = world;
			group.instancingData[group.kNumInstance].color = effect.color;

			++group.kNumInstance;
		}
		for (const auto& effect : group.ringEffects) {
			if (group.kNumInstance >= kMaxEffectCount) break;

			Matrix4x4 world = MakeAffineMatrix(effect.transform.scale, effect.transform.rotate, effect.transform.translate);
			Matrix4x4 wvp = Multiply(world, camera->GetViewProjectionMatrix());

			group.instancingData[group.kNumInstance].WVP = wvp;
			group.instancingData[group.kNumInstance].World = world;
			group.instancingData[group.kNumInstance].color = effect.color;

			++group.kNumInstance;
		}
	}
	
		
	
}



#pragma endregion

============================================================
File Path: Game/Particle/EffectManager.h
============================================================
#pragma once
#include "DirectXCommon.h"
#include "SrvManager.h"
#include "MyMath.h"
#include "Game/Camera/Camera.h"
/// <summary>
/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
class EffectManager
{
public:
    // ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³
    static EffectManager* GetInstance();
    static void DeleteInstance();

private:
    static EffectManager* instance;
    EffectManager() = default;
    ~EffectManager() = default;
    EffectManager(EffectManager&) = delete;
    EffectManager& operator=(EffectManager&) = delete;

    /// <summary>
	/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ä½œæˆ / åˆæœŸåŒ–å‡¦ç†å†…éƒ¨
    /// </summary>
    void CreatePipeline();
    /// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ / ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆå†…éƒ¨
    /// </summary>
    void CreateRootSignature();
    /// <summary>
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š / ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆå†…éƒ¨
    /// </summary>
    void SetGraphicsPipeline();
    /// <summary>
	/// ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š / ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆå†…éƒ¨
    /// </summary>
    /// <param name="desc"></param>
    /// <param name="mode"></param>
    void SetBlendMode(D3D12_BLEND_DESC& desc, BlendMode mode);

    /// <summary>
	/// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ / åˆæœŸåŒ–å‡¦ç†å†…éƒ¨
    /// </summary>
    void CreateVertexBufferView();
    /// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ– / åˆæœŸåŒ–å‡¦ç†å†…éƒ¨
    /// </summary>
    void InitializeMaterial();

    /// <summary>
	/// è¡Œåˆ—ã®æ›´æ–° / æ›´æ–°å‡¦ç†å†…éƒ¨
    /// </summary>
    void UpdateMatrix();

    /// <summary>
	/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–° / æ›´æ–°å‡¦ç†å†…éƒ¨
    /// </summary>
    void UpdateEffectInstanceData();


public:
    /// <summary>
	/// åˆæœŸåŒ–
    /// </summary>
    /// <param name="dxCommon"></param>
    /// <param name="srvManager"></param>
    /// <param name="camera"></param>
    void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, Camera* camera);
    
    /// <summary>
	/// æ›´æ–°
    /// </summary>
    void Update();
    
    /// <summary>
	/// æç”»
    /// </summary>
    void DrawRing();
    void DrawCylinder();


    /// <summary>
	/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆ
    /// </summary>
    /// <param name="name"></param>
    /// <param name="textureFilrPath"></param>
    void CreateEffectGroup(const std::string& name, const std::string textureFilrPath);
    /// <summary>
	/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚°ãƒ«ãƒ¼ãƒ—ã®å‰Šé™¤
    /// </summary>
    /// <param name="name"></param>
    void DeleteEffectGroup(const std::string& name);
    /// <summary>
	/// ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç™ºç”Ÿ
    /// </summary>
    /// <param name="name"></param>
    /// <param name="transform"></param>
    /// <param name="count"></param>
    void EmitCylinder(const std::string& name, const Transform& transform, uint32_t count);
    void EmitRing(const std::string& name, const Transform& transform, uint32_t count);


    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç”Ÿæˆ
    //void CreateRing(const Transform& transform);
    //void CreateCylinder(const Transform& transform);
    //void CreatePrimitive(const Transform& transform);

  
private:
    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨
    struct EffectGroup {
        MaterialData materialData;
        uint32_t srvIndex;
        Microsoft::WRL::ComPtr<ID3D12Resource>instancingResource;
        UINT kNumInstance;
        ParticleForGPU* instancingData;

		std::list <EffectInstance> ringEffects;
		std::list <EffectInstance> cylinderEffects;
    };

    

    DirectXCommon* dxCommon;
    SrvManager* srvManager;
    Camera* camera;

    // ãƒªãƒ³ã‚°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡
    Microsoft::WRL::ComPtr<ID3D12Resource> ringVertexBuffer = nullptr;
    D3D12_VERTEX_BUFFER_VIEW ringVertexBufferView{};
    uint32_t ringVertexCount = 0;

    // ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”¨ã®é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡
    Microsoft::WRL::ComPtr<ID3D12Resource> cylinderVertexBuffer = nullptr;
    D3D12_VERTEX_BUFFER_VIEW cylinderVertexBufferView{};
    uint32_t cylinderVertexCount = 0;

    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ãƒªã‚¹ãƒˆ
    
    // é ‚ç‚¹ç”Ÿæˆ
    void CreateRingVertex();
    void CreateCylinderVertex();

   

    // è¡Œåˆ—
    Matrix4x4 cameraMatrix;
    Matrix4x4 viewMatrix;
    Matrix4x4 backToFrontMatrix;
    Matrix4x4 billboardMatrix;

    // å®šæ•°
    const float kDeltaTime = 1.0f / 60.0f;

    // UVåº§æ¨™å¤‰æ›´
    Vector2 uvOffset = { 0.0f, 0.0f };
    Vector2 uvScrollSpeed = { 0.1f, 0.0f };  // æ°´å¹³æ–¹å‘ã«æµã™å ´åˆ

private:    // å†…éƒ¨ã§å‡¦ç†ã§ä½¿ç”¨ã—ã¦ã„ã‚‹å¤‰æ•°
    /// CreateRootSignature
    // ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
    D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
    // ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
    D3D12_ROOT_PARAMETER rootParameters[3] = {};
    // ã‚µãƒ³ãƒ—ãƒ©ãƒ¼
    D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
    // ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
    Microsoft::WRL::ComPtr<ID3D12RootSignature> rootSignature;
    // ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
    D3D12_INPUT_ELEMENT_DESC inputElementDescs[3];
    // ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
    D3D12_INPUT_LAYOUT_DESC inputLayoutDesc{};

    // blendmode
    BlendMode blendMode;
    BlendMode currentBlendMode;
    D3D12_BLEND_DESC blendDesc{};
    D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};
    D3D12_RASTERIZER_DESC rasterrizerDesc{};

    // ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒã‚¤ãƒŠãƒª
    Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob;
    Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob;

    /// SetGraphicsPipeLine
    // ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
    D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc;
    Microsoft::WRL::ComPtr<ID3D12PipelineState> graphicsPipelineState = nullptr;

    /// InitializeMaterial
    // ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹
    Microsoft::WRL::ComPtr<ID3D12Resource> materialResource = nullptr;
    // ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿
    Material* materialData = nullptr;

    /// CreateEffectGroup
    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚°ãƒ«ãƒ¼ãƒ—
    std::unordered_map<std::string, EffectGroup> effectGroups;
    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç™ºç”Ÿä¸Šé™
    static const int kMaxEffectCount = 1000;

};




============================================================
File Path: Game/Particle/ParticleEmitter.cpp
============================================================
#include "ParticleEmitter.h"
#include "EffectEmitter.h"

ParticleEmitter::ParticleEmitter()
    : currentTime(0.0f)
{
    emitter.transform.translate = { 0.0f, 0.0f, 0.0f };
    emitter.count = 1;
    emitter.frequency = 1.0f;
    emitter.frequencyTime = 0.0f;
}

ParticleEmitter::~ParticleEmitter()
{
   
}


void ParticleEmitter::Update()
{
    // æ™‚åˆ»ã‚’é€²ã‚ã‚‹
    currentTime += kDeltaTime;
    

    // ç™ºç”Ÿé »åº¦ã‚ˆã‚Šå¤§ãã„ãªã‚‰ç™ºç”Ÿ
    if (currentTime >= emitter.frequency)
    {
        Emit();
        // ã‚«ãƒ¬ãƒ³ãƒˆã‚¿ã‚¤ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆ
        currentTime = 0.0f;
    }
}



void ParticleEmitter::Emit()
{
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç™ºç”Ÿã•ã›ã‚‹
    ParticleManager::GetInstance()->Emit(particleName, emitter.transform.translate, emitter.count);
    //ParticleManager::GetInstance()->EffectEmit(particleName, emitter.transform.translate, emitter.count);
}

void ParticleEmitter::BreakEmit()
{
	ParticleManager::GetInstance()->Emit(particleName, emitter.transform.translate, emitter.count);
}



============================================================
File Path: Game/Particle/ParticleEmitter.h
============================================================
#pragma once
#include "ParticleManager.h"
using namespace std;
/// <summary>
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒŸãƒƒã‚¿ã‚¯ãƒ©ã‚¹
/// </summary>
class ParticleEmitter
{
public:
    /// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    ParticleEmitter();
    ~ParticleEmitter();
    /// <summary>
	/// æ›´æ–°
    /// </summary>
    void Update();
    /// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿ
    /// </summary>
    void Emit();

	/// <summary>
	/// ç ´å£Šå¯èƒ½ãƒ–ãƒ­ãƒƒã‚¯ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿ
	/// </summary>
	void BreakEmit();

	// Getter / Setter
	/// <summary>
	/// ã‚¨ãƒŸãƒƒã‚¿ã®Transformè¨­å®šãƒ»å–å¾—
	/// </summary>
	/// <param name="transform"></param>
    void SetTransform(const Transform& transform) { emitter.transform = transform; }
	Transform GetTransform()const { return emitter.transform; }

	/// <summary>
	/// Particleã®ç™ºç”Ÿä½ç½®è¨­å®šãƒ»å–å¾—
	/// </summary>
	/// <param name="translate"></param>
	void SetTranslate(const Vector3& translate) { emitter.transform.translate = translate; }
	Vector3 GetTranslate()const { return emitter.transform.translate; }

	/// <summary>
	/// Particleã®å›è»¢è¨­å®šãƒ»å–å¾—
	/// </summary>
	/// <param name="rotate"></param>
	void SetRotate(const Vector3& rotate) { emitter.transform.rotate = rotate; }
	Vector3 GetRotate()const { return emitter.transform.rotate; }

	/// <summary>
	/// Particleã®ã‚¹ã‚±ãƒ¼ãƒ«è¨­å®šãƒ»å–å¾—
	/// </summary>
	/// <param name="scale"></param>
	void SetScale(const Vector3& scale) { emitter.transform.scale = scale; }
	Vector3 GetScale()const { return emitter.transform.scale; }

	/// <summary>
	/// ç™ºç”Ÿã•ã›ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ•°è¨­å®šãƒ»å–å¾—
	/// </summary>
	/// <param name="name"></param>
	void SetParticleName(const string& name) { particleName = name; }

private:
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ§‹é€ ä½“
    struct Emitter {
        Transform transform;	// ã‚¨ãƒŸãƒƒã‚¿ã®Transform
        uint32_t count;			// ç”Ÿæˆã™ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ•°
        float frequency;		// ç”Ÿæˆã™ã‚‹é »åº¦
        float frequencyTime;	// ç”Ÿæˆã™ã‚‹æ™‚é–“
    };
    
    // ã‚«ãƒ¬ãƒ³ãƒˆã‚¿ã‚¤ãƒ 
    float currentTime;
    // ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã®æ™‚é–“é–“éš”ï¼ˆä¾‹: 60FPSã®å ´åˆï¼‰
	const float kDeltaTime = 1.0f / 60.0f;
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ç™ºç”Ÿé–“éš”
    const float emitInterval = 1.0f;
    
	// æç”»ä¸Šé™æ•° / ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°
    const uint32_t kNumMaxInstance = 100;
    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒªã‚¹ãƒˆ
	std::list<Particle> particles;
	// Emitter
	Emitter emitter;

    // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒãƒ¼ãƒ 
    string particleName;

private:
    Vector3 test;
};


============================================================
File Path: Game/Particle/ParticleManager.cpp
============================================================
#include "ParticleManager.h"
#include <Logger.h>
#include "MakeMatrix.h"
#include <TextureManager.h>
#include "WinAPI.h"
#include <numbers>
ParticleManager* ParticleManager::instance = nullptr;
ParticleManager* ParticleManager::GetInstance()
{
	if (instance == nullptr)
	{
		instance = new ParticleManager();
	}
	return instance;

}

void ParticleManager::DeleteInstance()
{
	delete instance;
	instance = nullptr;
}

void ParticleManager::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, Camera* camera)
{
	// ãƒ¡ãƒ³ãƒå¤‰æ•°ã®åˆæœŸåŒ–
	this->dxCommon = dxCommon;
	this->srvManager = srvManager;
	// ã‚«ãƒ¡ãƒ©ã®å–å¾—
	this->camera = camera;

	// ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š
	blendMode = BlendMode::kBlendModeAdd;
	// ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆæœŸåŒ–
	InitializeRandomEngine();
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	CreatePipeline();
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–(åº§æ¨™ç­‰)
	InitializeVertexData();
	// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ–
	InitializeMaterial();

	// ãƒªãƒ³ã‚°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ–
	//CreateRingVertex();

	// ã‚·ãƒªãƒ³ãƒ€ãƒ¼ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	//CreateCylinderVertex();
}

void ParticleManager::InitializeRandomEngine()
{
	// ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆæœŸåŒ–
	std::random_device rnd;
	randomEngine = std::mt19937(rnd());
}

void ParticleManager::CreatePipeline()
{
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	CreateRootSignature();
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	SetGraphicsPipeline();
}

void ParticleManager::CreateRootSignature()
{
	D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
	descriptorRange[0].BaseShaderRegister = 0; // t0
	descriptorRange[0].NumDescriptors = 1; 
	descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRV
	descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—

	D3D12_DESCRIPTOR_RANGE descriptorRangeTexture[1] = {};
	descriptorRangeTexture[0].BaseShaderRegister = 1; // t1å§‹ã¾ã‚‹
	descriptorRangeTexture[0].NumDescriptors = 1; 
	descriptorRangeTexture[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRV
	descriptorRangeTexture[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—

	D3D12_ROOT_PARAMETER rootParameters[3] = {};


	// RootParameterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚
	// 0.Material
	rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters[0].Descriptor.ShaderRegister = 0;
	rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;

	// 1.TransformMatrix
	rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	rootParameters[1].DescriptorTable.pDescriptorRanges = descriptorRange;
	rootParameters[1].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange);
	rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
	// 2.Texture
	rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	rootParameters[2].DescriptorTable.pDescriptorRanges = descriptorRangeTexture;
	rootParameters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRangeTexture);
	rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;

	// Samplerã®è¨­å®š
	staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR; // ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿
	staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP; // 0~1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ
	staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER; // æ¯”è¼ƒã—ãªã„
	staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX; // ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†
	staticSamplers[0].ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†
	staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†

	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
	descriptionRootSignature.Flags =
		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;

	descriptionRootSignature.pParameters = rootParameters;
	descriptionRootSignature.NumParameters = _countof(rootParameters);

	descriptionRootSignature.pStaticSamplers = staticSamplers;
	descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

	// ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒã‚¤ãƒŠãƒªã«ã™ã‚‹
	Microsoft::WRL::ComPtr<ID3DBlob> signatureBlob = nullptr;
	Microsoft::WRL::ComPtr<ID3DBlob> errorBlob = nullptr;
	HRESULT hr = D3D12SerializeRootSignature(&descriptionRootSignature,
		D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(hr)) {
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	// ãƒã‚¤ãƒŠãƒªã‚’å…ƒã«ç”Ÿæˆ

	hr = dxCommon->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(),
		signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
	assert(SUCCEEDED(hr));



	// 2. InputLayoutã®è¨­å®š
	inputElementDescs[0].SemanticName = "POSITION";
	inputElementDescs[0].SemanticIndex = 0;
	inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs[1].SemanticName = "TEXCOORD";
	inputElementDescs[1].SemanticIndex = 0;
	inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs[2].SemanticName = "NORMAL";
	inputElementDescs[2].SemanticIndex = 0;
	inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputLayoutDesc.pInputElementDescs = inputElementDescs;
	inputLayoutDesc.NumElements = _countof(inputElementDescs);

	// 3. BlendDtateã®è¨­å®š
	blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
	blendDesc.RenderTarget[0].BlendEnable = true;

	SetBlendMode(blendDesc, blendMode);
	currentBlendMode = BlendMode::kBlendModeAdd;  // ç¾åœ¨ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰
	// Î±å€¤ã®ãƒ–ãƒ¬ãƒ³ãƒ‰
	blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;
	blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;
	// RasterrizerStateã®è¨­å®š
	// ã‚«ãƒªãƒ³ã‚°ãªã—
	rasterrizerDesc.CullMode = D3D12_CULL_MODE_NONE;
	// å¡—ã‚Šã¤ã¶ã—ãƒ¢ãƒ¼ãƒ‰
	rasterrizerDesc.FillMode = D3D12_FILL_MODE_SOLID;
	// 4. Shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	vertexShaderBlob = dxCommon->CompileShader(L"resources/shaders/Particle.VS.hlsl",
		L"vs_6_0");
	assert(vertexShaderBlob != nullptr);
	pixelShaderBlob = dxCommon->CompileShader(L"resources/shaders/Particle.PS.hlsl",
		L"ps_6_0");
	assert(pixelShaderBlob != nullptr);

	// DepthStencilStateã®è¨­å®š
	// Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
	depthStencilDesc.DepthEnable = true;
	//æ›¸ãè¾¼ã¿ã—ã¾ã™
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
	//æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
}




void ParticleManager::SetGraphicsPipeline()
{
	graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();
	graphicsPipelineStateDesc.InputLayout = inputLayoutDesc;
	graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),
										vertexShaderBlob->GetBufferSize() };
	graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),
										pixelShaderBlob->GetBufferSize() };
	graphicsPipelineStateDesc.BlendState = blendDesc;
	graphicsPipelineStateDesc.RasterizerState = rasterrizerDesc;
	// Depthstencitã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
	// æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	// åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸ï¼ˆå½¢çŠ¶ï¼‰ã®ã‚¿ã‚¤ãƒ—ã€‚ä¸‰è§’å½¢
	graphicsPipelineStateDesc.PrimitiveTopologyType =
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	// ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã®ã‹è¨­å®šï¼ˆæ°—ã«ã—ãªãã¦è‰¯ã„ï¼‰
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	// å®Ÿéš›ã«ç”Ÿæˆ
	HRESULT hr = dxCommon->GetDevice()->CreateGraphicsPipelineState(&graphicsPipelineStateDesc,
		IID_PPV_ARGS(&graphicsPipelineState));
	assert(SUCCEEDED(hr));
}


void ParticleManager::SetBlendMode(D3D12_BLEND_DESC& desc, BlendMode mode)
{
	switch (mode)
	{
	case kBlendModeAdd:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;
		break;
	case kBlendModeSubtract:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_REV_SUBTRACT;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;
		break;
	case kBlendModeMultiply:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_DEST_COLOR;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ZERO;
		break;
	case kBlendModeScreen:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_COLOR;
		break;
	default:
		assert(false);
		break;
	}
}

void ParticleManager::InitializeVertexData()
{

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’åˆæœŸåŒ–
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, 0.0f, 1.0f},   .texcoord = {0.0f, 0.0f}, .normal = {0.0f, 0.0f, 1.0f} });
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, 0.0f, 1.0f},  .texcoord = {1.0f, 0.0f}, .normal = {0.0f, 0.0f, 1.0f} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, 0.0f, 1.0f},  .texcoord = {0.0f, 1.0f}, .normal = {0.0f, 0.0f, 1.0f} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, 0.0f, 1.0f},  .texcoord = {0.0f, 1.0f}, .normal = {0.0f, 0.0f, 1.0f} });
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, 0.0f, 1.0f},  .texcoord = {1.0f, 0.0f}, .normal = {0.0f, 0.0f, 1.0f} });
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, 0.0f, 1.0f}, .texcoord = {1.0f, 1.0f}, .normal = {0.0f, 0.0f, 1.0f} });

	// ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ
	CreateVertexBufferView();
}

void ParticleManager::CreateVertexBufferView()
{
	vertexResource = dxCommon->CreateBufferResource(sizeof(VertexData) * modelData.vertices.size());
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼
	vertexBufferView.BufferLocation = vertexResource->GetGPUVirtualAddress();
	// 1é ‚ç‚¹åˆ†ã®ã‚µã‚¤ã‚º
	vertexBufferView.StrideInBytes = sizeof(VertexData);
	// é ‚ç‚¹æ•°
	vertexBufferView.SizeInBytes = UINT(sizeof(VertexData) * modelData.vertices.size());
	// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿ / ãƒãƒƒãƒ—
	vertexResource->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));
	// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	memcpy(vertexData, modelData.vertices.data(), sizeof(VertexData) * modelData.vertices.size());

}

void ParticleManager::InitializeMaterial()
{
	// ãƒªã‚½ãƒ¼ã‚¹ç”Ÿæˆ
	materialResource = dxCommon->CreateBufferResource(sizeof(Material));

	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã«æ›¸ãè¾¼ã¿
	materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));

	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	materialData->color = Vector4(0.3f, 1.0f, 0.7f, 1.0f);
	materialData->enableLighting = true;
	materialData->uvTransform = MakeIdentity4x4();
}

void ParticleManager::CreateParticleGroup(const std::string& name, const std::string textureFilePath)
{

	// ç™»éŒ²æ¸ˆã¿ã®åå‰ã‹ç¢ºèª
	if (particleGroups.contains(name))
	{
		// ç™»éŒ²ã•ã‚Œã¦ã„ãŸã‚‰ãƒªã‚¿ãƒ¼ãƒ³
		Logger::Log("æ—¢ã«ç™»éŒ²ã•ã‚Œã¦ã„ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—åã§ã™");
		return;
	}
	// æ–°ãŸãªç©ºã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆã—ã‚³ãƒ³ãƒ†ãƒŠã«ç™»éŒ²
	particleGroups[name] = ParticleGroup();
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	ParticleGroup& particleGroup = particleGroups[name];

	// æ–°ãŸãªãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
	particleGroup.materialData.textureFilePath = textureFilePath;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿
	TextureManager::GetInstance()->LoadTexture(particleGroup.materialData.textureFilePath);

	particleGroup.textureSrvIndex = TextureManager::GetInstance()->GetSrvIndex(particleGroup.materialData.textureFilePath);

	
	particleGroup.instancingResource = dxCommon->CreateBufferResource(sizeof(ParticleForGPU) * kMaxParticle);

	// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	particleGroup.instancingSrvIndex = srvManager->Allocate();
	// æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	particleGroup.instancingResource->Map(0, nullptr, reinterpret_cast<void**>(&particleGroup.instancingData));

	

	srvManager->CreateSRVforStructuredBuffer(
		particleGroup.instancingSrvIndex, 
		particleGroup.instancingResource.Get(), 
		kMaxParticle, 
		sizeof(ParticleForGPU));

	// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ã‚’åˆæœŸåŒ–
	particleGroup.kNumInstance = 0;
}

void ParticleManager::Update()
{
	uvOffset.x += uvScrollSpeed.x * kDeltaTime;
	uvOffset.y += uvScrollSpeed.y * kDeltaTime;

	// wrap (0ã€œ1ã®ç¯„å›²ã«ä¿ã¤)
	uvOffset.x = std::fmod(uvOffset.x, 1.0f);
	uvOffset.y = std::fmod(uvOffset.y, 1.0f);
	materialData->uvTransform = MakeTranslateMatrix({ uvOffset.x, uvOffset.y, 0.0f });

	// è¡Œåˆ—ã®æ›´æ–°
	UpdateMatrix();
	// å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®å‡¦ç†
	UpdateParticle();

}

void ParticleManager::UpdateMatrix()
{
	// ã‚«ãƒ¡ãƒ©è¡Œåˆ—ã®å–å¾—
	cameraMatrix = camera->GetWorldMatrix();
	// ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã®å–å¾—
	viewMatrix = camera->GetViewMatrix();
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ã®å–å¾—
	backToFrontMatrix = MakeRotateYMatrix(std::numbers::pi_v<float>);

	// ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰ç”¨ã®è¡Œåˆ—
	billboardMatrix = Multiply(backToFrontMatrix, cameraMatrix);
	billboardMatrix.m[3][0] = 0.0f;
	billboardMatrix.m[3][1] = 0.0f;
	billboardMatrix.m[3][2] = 0.0f;
}

void ParticleManager::UpdateParticle()
{
	// å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã«ã¤ã„ã¦å‡¦ç†
	for (auto& [name, particleGroup] : particleGroups)
	{
		particleGroup.kNumInstance = 0;
		// å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’æ›´æ–°
		for (auto particleIterator = particleGroup.particles.begin(); particleIterator != particleGroup.particles.end();)
		{
			// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°ãŒä¸Šé™ã‚’è¶…ãˆã¦ã„ãªã„ãªã‚‰ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€
			if (particleGroup.kNumInstance < kMaxParticle)
			{
				// ç”Ÿå­˜æ™‚é–“ã‚’éãã¦ã„ãŸã‚‰æ›´æ–°ã›ãšæç”»å¯¾è±¡ã«ã—ãªã„
				if (particleIterator->lifeTime <= particleIterator->currentTime)
				{
					// æ¶ˆã™
					particleIterator = particleGroup.particles.erase(particleIterator);
					continue;
				}
				// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼‘å€‹ã”ã¨ã®æ›´æ–°
				particleIterator->transform.translate.x += particleIterator->velocity.x * kDeltaTime;
				particleIterator->transform.translate.y += particleIterator->velocity.y * kDeltaTime;
				particleIterator->transform.translate.z += particleIterator->velocity.z * kDeltaTime;
				particleIterator->currentTime += kDeltaTime;

				Matrix4x4 worldMatrixParticle = MakeAffineMatrix(particleIterator->transform.scale, particleIterator->transform.rotate, particleIterator->transform.translate);
				Matrix4x4 worldViewProjectionMatrix = Multiply(worldMatrixParticle, camera->GetViewProjectionMatrix());
				// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
				particleGroup.instancingData[particleGroup.kNumInstance].WVP = worldViewProjectionMatrix;
				particleGroup.instancingData[particleGroup.kNumInstance].World = worldMatrixParticle;
				particleGroup.instancingData[particleGroup.kNumInstance].color = particleIterator->color;
				particleGroup.instancingData[particleGroup.kNumInstance].color.w = 1.0f - (particleIterator->currentTime / particleIterator->lifeTime);

				++particleGroup.kNumInstance;
			}
			// æ¬¡ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã«é€²ã‚ã‚‹
			++particleIterator;
		}
	}
}



void ParticleManager::Draw()
{
	
	// ã‚³ãƒãƒ³ãƒ‰ : ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¨­å®š
	dxCommon->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
	// ã‚³ãƒãƒ³ãƒ‰ : ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒ­ãƒã‚¸(æç”»å½¢çŠ¶)ã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	// ã‚³ãƒãƒ³ãƒ‰ : VertexBufferViewã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);

	// ã‚³ãƒãƒ³ãƒ‰ : ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’è¨­å®š
	dxCommon->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°
	dxCommon->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());

	// å…¨ã¦ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã«ã¤ã„ã¦å‡¦ç†
	for (auto& [name, particleGroup] : particleGroups)
	{ 
		if(particleGroup.kNumInstance == 0)
		{
			continue;
		}

		// è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°
		dxCommon->GetCommandList()->SetGraphicsRootDescriptorTable(
			1,
			srvManager->GetGPUDescriptorHandle(particleGroup.instancingSrvIndex));

		// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã®æ›´æ–°
		//srvManager->SetGraphicsDescriptorTable(1, particleGroup.instancingSrvIndex);

		// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã®è¨­å®š
		dxCommon->GetCommandList()->SetGraphicsRootDescriptorTable(2, 
			srvManager->GetGPUDescriptorHandle(particleGroup.textureSrvIndex));
		
		// æç”»
		dxCommon->GetCommandList()->DrawInstanced(6, particleGroup.kNumInstance, 0, 0);
	}
}

void ParticleManager::DeleteParticleGroup(const std::string& name)
{
	auto it = particleGroups.find(name);
	if (it != particleGroups.end()) {
		// Unmapã§ãƒªãƒ¼ã‚¯ã—ãªã„ã‚ˆã†ã«ã™ã‚‹
		if (it->second.instancingResource) {
			it->second.instancingResource->Unmap(0, nullptr);
			it->second.instancingData = nullptr; // ãƒã‚¤ãƒ³ã‚¿ã®ç„¡åŠ¹åŒ–
			it->second.instancingResource.Reset(); // ComPtrã®è§£æ”¾
		}

		// SRVã®è§£æ”¾ã‚‚ï¼ˆã‚‚ã—å¿…è¦ã§ã‚ã‚Œã°ï¼‰
		// srvManager->Release(it->second.srvIndex); // å¿…è¦ãªã‚‰

		// Mapã‹ã‚‰å‰Šé™¤
		particleGroups.erase(it);
	}
}


// Particleã¯Emitterã‚’ç”Ÿæˆã—ãªã„ã¨æç”»ã•ã‚Œãªã„ã®ã§ã“ã®ãƒ¡ã‚½ãƒƒãƒ‰ã ã‘ã‚’å‘¼ã³å‡ºã—ã¦ã‚‚æç”»ã•ã‚Œãªã„
void ParticleManager::Emit(const std::string& name, const Vector3& position, uint32_t count)
{
	// ç™»éŒ²æ¸ˆã¿ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—åã‹ãƒã‚§ãƒƒã‚¯
	auto it = particleGroups.find(name);
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ãŒå­˜åœ¨ã™ã‚‹ã“ã¨ã‚’ç¢ºèª
	assert(it != particleGroups.end());
	// æŒ‡å®šã•ã‚ŒãŸãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¿½åŠ 
	ParticleGroup& group = it->second;
	// å„ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’ç”Ÿæˆã—è¿½åŠ 
	for (uint32_t i = 0; i < count; ++i) {
		Particle newParticle = MakeParticle(randomEngine, position);
		group.particles.push_back(newParticle);
	}
}

void ParticleManager::EffectEmit(const std::string& name, const Vector3& position, uint32_t count)
{
	auto it = particleGroups.find(name);
	assert(it != particleGroups.end());
	ParticleGroup& group = it->second;

	for (uint32_t i = 0; i < count; ++i) {
		Particle newParticle;
		newParticle.transform.scale = { 0.1f, 0.1f, 0.1f };
		newParticle.transform.rotate = { 0.0f,0.0f,0.0f };
		newParticle.transform.translate = position;
		newParticle.velocity = { 0.0f, 0.0f, 0.0f };
		newParticle.color = { 1.0f, 1.0f, 1.0f, 1.0f };
		newParticle.lifeTime = 1.0f;
		newParticle.currentTime = 0.0f;
		newParticle = MakeCylinderEffect(position);
		group.particles.push_back(newParticle);
	}
}

Particle ParticleManager::MakeParticle(std::mt19937& randomEngine, const  Vector3& position)
{
	Particle particle;
	std::uniform_real_distribution<float> distPosition(-1.0f, 1.0f);
	std::uniform_real_distribution<float> distVelocity(-1.0f, 1.0f);
	std::uniform_real_distribution<float> distColor(0.0f, 1.0f);
	std::uniform_real_distribution<float> distTime(1.0f, 3.0f);

	particle.transform.scale = { 1.0f, 1.0f, 1.0f };
	particle.transform.rotate = { 0.0f, 3.3f, 0.0f };
	Vector3 randomPosition = { distPosition(randomEngine), distPosition(randomEngine),5.0f };
	particle.transform.translate = position + randomPosition;
	particle.velocity = { distVelocity(randomEngine), distVelocity(randomEngine), distVelocity(randomEngine) };
	particle.color = { distColor(randomEngine), distColor(randomEngine), distColor(randomEngine), 1.0f };
	particle.lifeTime = distTime(randomEngine);
	particle.currentTime = 0;

	return particle;
}

Particle ParticleManager::MakePrimitiveEffect(std::mt19937& randomEngine, const Vector3& translate)
{
	Particle particle;

	std::uniform_real_distribution<float>distRotate(-std::numbers::pi_v<float>, std::numbers::pi_v<float>);
	std::uniform_real_distribution<float>distScale(0.4f, 1.5f);

	particle.transform.scale = { 0.05f,distScale(randomEngine),1.0f };// æ¨ªã«ã¤ã¶ã™
	particle.transform.rotate = { 0.0f,0.0f,distRotate(randomEngine) };
	particle.transform.translate = Vector3(translate.x, translate.y, 15.0f);
	particle.velocity = { 0.0f,0.0f,0.0f };
	//white
	particle.color = { 1.0f,1.0f,1.0f,1.0f };
	particle.lifeTime = 10.0f;
	particle.currentTime = 0;
	return particle;


#pragma region ãƒœãƒ³ãƒ‰ãƒ«ãƒ‰
	//Particle particle;
	//particle.transform.scale = { 0.05f,1.0f,1.0f };// æ¨ªã«ã¤ã¶ã™
	//particle.transform.rotate = { 0.0f,0.0f,0.0f, };
	//particle.transform.translate = Vector3(translate.x, translate.y, 15.0f);
	//particle.velocity = { 0.0f,0.0f,0.0f };
	////purple
	//particle.color = { 102.0f, 51.0f, 153.0f, 1.0f };
	//particle.lifeTime = 10.0f;
	//particle.currentTime = 0;
	//return particle;
#pragma endregion
}



void ParticleManager::CreateRingVertex()
{
	std::vector<VertexData> vertices;
	const uint32_t kRingDivide = 32;
	const float kOuterRadius = 1.0f;
	const float kInnerRadius = 0.2f;
	const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kRingDivide);

	for (uint32_t i = 0; i < kRingDivide; ++i) {
		float angle0 = i * radianPerDivide;
		float angle1 = (i + 1) * radianPerDivide;

		float sin0 = std::sin(angle0);
		float cos0 = std::cos(angle0);
		float sin1 = std::sin(angle1);
		float cos1 = std::cos(angle1);

		// å¤–å´ãƒ»å†…å´ã®å„ç‚¹
		Vector4 outer0 = { sin0 * kOuterRadius, cos0 * kOuterRadius, 0.0f, 1.0f };
		Vector4 outer1 = { sin1 * kOuterRadius, cos1 * kOuterRadius, 0.0f, 1.0f };
		Vector4 inner0 = { sin0 * kInnerRadius, cos0 * kInnerRadius, 0.0f, 1.0f };
		Vector4 inner1 = { sin1 * kInnerRadius, cos1 * kInnerRadius, 0.0f, 1.0f };

		Vector2 uvOuter0 = { float(i) / kRingDivide, 0.0f };
		Vector2 uvOuter1 = { float(i + 1) / kRingDivide, 0.0f };
		Vector2 uvInner0 = { float(i) / kRingDivide, 1.0f };
		Vector2 uvInner1 = { float(i + 1) / kRingDivide, 1.0f };

		Vector3 normal = { 0.0f, 0.0f, 1.0f };

		// ä¸‰è§’å½¢ 1ï¼ˆouter0, outer1, inner0ï¼‰
		vertices.push_back({ outer0, uvOuter0, normal });
		vertices.push_back({ outer1, uvOuter1, normal });
		vertices.push_back({ inner0, uvInner0, normal });

		// ä¸‰è§’å½¢ 2ï¼ˆinner0, outer1, inner1ï¼‰
		vertices.push_back({ inner0, uvInner0, normal });
		vertices.push_back({ outer1, uvOuter1, normal });
		vertices.push_back({ inner1, uvInner1, normal });
	}

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®ä½œæˆ
	size_t vertexSize = sizeof(VertexData) * vertices.size();

	Microsoft::WRL::ComPtr<ID3D12Resource> vertexBuffer;
	D3D12_HEAP_PROPERTIES heapProp{};
	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;

	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Width = vertexSize;
	resourceDesc.Height = 1;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.SampleDesc.Count = 1;
	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	dxCommon->GetDevice()->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertexBuffer));

	VertexData* mapData = nullptr;
	vertexBuffer->Map(0, nullptr, reinterpret_cast<void**>(&mapData));
	memcpy(mapData, vertices.data(), vertexSize);
	vertexBuffer->Unmap(0, nullptr);

	D3D12_VERTEX_BUFFER_VIEW vbView{};
	vbView.BufferLocation = vertexBuffer->GetGPUVirtualAddress();
	vbView.SizeInBytes = static_cast<UINT>(vertexSize);
	vbView.StrideInBytes = sizeof(VertexData);

	ringVertexBuffer = vertexBuffer;
	ringVertexBufferView = vbView;
	ringVertexCount = static_cast<uint32_t>(vertices.size());
}

void ParticleManager::DrawRing()
{
	if (!ringVertexBuffer) return;

	auto* cmdList = dxCommon->GetCommandList();

	// å¿…è¦ãªãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootSignature(rootSignature.Get());
	cmdList->SetPipelineState(graphicsPipelineState.Get());
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	cmdList->IASetVertexBuffers(0, 1, &ringVertexBufferView);
	cmdList->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£SRVï¼ˆä»®ã«index=0ã¨ã™ã‚‹ï¼‰
	D3D12_GPU_DESCRIPTOR_HANDLE textureHandle = srvManager->GetGPUDescriptorHandle(0);
	cmdList->SetGraphicsRootDescriptorTable(2, textureHandle);

	cmdList->DrawInstanced(ringVertexCount, 1, 0, 0);

}

Particle ParticleManager::MakeRingEffect(const Vector3& position) {
	Particle particle;
	particle.transform.scale = { 1.0f, 1.0f, 1.0f };     // ã‚µã‚¤ã‚ºï¼ˆå¤§ãã™ãã‚‹ã¨ç”»é¢å¤–ï¼‰
	particle.transform.rotate = { 0.0f, 0.0f, 0.0f };
	particle.transform.translate = { 0.0f, 0.0f, 5.0f }; // Z = 5.0f ã§æ‰‹å‰ã«è¡¨ç¤ºã•ã‚Œã‚„ã™ã„
	particle.velocity = { 0.0f, 0.0f, 0.0f };
	particle.color = { 1.0f, 1.0f, 1.0f, 1.0f };
	particle.lifeTime = 1.0f;
	particle.currentTime = 0.0f;
	return particle;
}

Particle ParticleManager::MakeCylinderEffect(const Vector3& position)
{
	Particle particle;
	particle.transform.scale = { 1.0f, 1.0f, 1.0f };     // ã‚µã‚¤ã‚ºï¼ˆå¤§ãã™ãã‚‹ã¨ç”»é¢å¤–ï¼‰
	particle.transform.rotate = { 0.0f, 0.0f, 0.0f };
	particle.transform.translate = position;
	particle.velocity = { 0.0f, 0.0f, 0.0f };
	particle.color = { 1.0f, 1.0f, 1.0f, 1.0f };
	particle.lifeTime = 1.0f;
	particle.currentTime = 0.0f;
	return particle;
}

void ParticleManager::CreateCylinderVertex() {
	std::vector<VertexData> vertices;
	const uint32_t kCylinderDivide = 32;
	const float kTopRadius = 1.0f;
	const float kBottomRadius = 1.0f;
	const float kHeight = 3.0f;
	const float halfHeight = kHeight * 0.5f;
	const float radianPerDivide = 2.0f * std::numbers::pi_v<float> / float(kCylinderDivide);

	for (uint32_t i = 0; i < kCylinderDivide; ++i) {
		float angle0 = i * radianPerDivide;
		float angle1 = (i + 1) * radianPerDivide;

		float sin0 = std::sin(angle0);
		float cos0 = std::cos(angle0);
		float sin1 = std::sin(angle1);
		float cos1 = std::cos(angle1);

		float u0 = float(i) / float(kCylinderDivide);
		float u1 = float(i + 1) / float(kCylinderDivide);

		// å„é ‚ç‚¹ã®ä½ç½®
		Vector4 top0 = { sin0 * kTopRadius, +halfHeight, cos0 * kTopRadius, 1.0f };
		Vector4 top1 = { sin1 * kTopRadius, +halfHeight, cos1 * kTopRadius, 1.0f };
		Vector4 bottom0 = { sin0 * kBottomRadius, -halfHeight, cos0 * kBottomRadius, 1.0f };
		Vector4 bottom1 = { sin1 * kBottomRadius, -halfHeight, cos1 * kBottomRadius, 1.0f };

		// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™
		Vector2 uvTop0 = { u0, 0.0f };
		Vector2 uvTop1 = { u1, 0.0f };
		Vector2 uvBottom0 = { u0, 1.0f };
		Vector2 uvBottom1 = { u1, 1.0f };

		// æ³•ç·šãƒ™ã‚¯ãƒˆãƒ«ï¼ˆæ­£è¦åŒ–ï¼‰
		Vector3 normal0 = Vector3{ sin0, 0.0f, cos0 }.Normalized();
		Vector3 normal1 = Vector3{ sin1, 0.0f, cos1 }.Normalized();

		// å´é¢ï¼šä¸‰è§’å½¢2æšï¼ˆ1ã‚¯ã‚¢ãƒƒãƒ‰ï¼‰
		vertices.push_back({ top0,    uvTop0,    normal0 });
		vertices.push_back({ top1,    uvTop1,    normal1 });
		vertices.push_back({ bottom0, uvBottom0, normal0 });

		vertices.push_back({ top1,    uvTop1,    normal1 });
		vertices.push_back({ bottom1, uvBottom1, normal1 });
		vertices.push_back({ bottom0, uvBottom0, normal0 });
	}

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ä½œæˆ
	size_t vertexSize = sizeof(VertexData) * vertices.size();

	Microsoft::WRL::ComPtr<ID3D12Resource> vertexBuffer;
	D3D12_HEAP_PROPERTIES heapProp{};
	heapProp.Type = D3D12_HEAP_TYPE_UPLOAD;

	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	resourceDesc.Width = vertexSize;
	resourceDesc.Height = 1;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.SampleDesc.Count = 1;
	resourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;

	HRESULT hr = dxCommon->GetDevice()->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_GENERIC_READ,
		nullptr,
		IID_PPV_ARGS(&vertexBuffer));
	assert(SUCCEEDED(hr));

	VertexData* mapData = nullptr;
	vertexBuffer->Map(0, nullptr, reinterpret_cast<void**>(&mapData));
	memcpy(mapData, vertices.data(), vertexSize);
	vertexBuffer->Unmap(0, nullptr);

	D3D12_VERTEX_BUFFER_VIEW vbView{};
	vbView.BufferLocation = vertexBuffer->GetGPUVirtualAddress();
	vbView.SizeInBytes = static_cast<UINT>(vertexSize);
	vbView.StrideInBytes = sizeof(VertexData);

	ringVertexBuffer = vertexBuffer;
	ringVertexBufferView = vbView;
	ringVertexCount = static_cast<uint32_t>(vertices.size());
}



void ParticleManager::DrawCylinder()
{
	if (!ringVertexBuffer) return;

	auto* cmdList = dxCommon->GetCommandList();

	// å¿…è¦ãªãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚»ãƒƒãƒˆ
	cmdList->SetGraphicsRootSignature(rootSignature.Get());
	cmdList->SetPipelineState(graphicsPipelineState.Get());
	cmdList->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	cmdList->IASetVertexBuffers(0, 1, &ringVertexBufferView);
	cmdList->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£SRVï¼ˆä»®ã«index=0ã¨ã™ã‚‹ï¼‰
	D3D12_GPU_DESCRIPTOR_HANDLE textureHandle = srvManager->GetGPUDescriptorHandle(0);
	cmdList->SetGraphicsRootDescriptorTable(2, textureHandle);

	cmdList->DrawInstanced(ringVertexCount, 1, 0, 0);


}


============================================================
File Path: Game/Particle/ParticleManager.h
============================================================
#pragma once
#include "DirectXCommon.h"
#include "SrvManager.h"
#include "MyMath.h"
#include <random>
#include "Game/Camera/Camera.h"


/// <summary>
/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
/// </summary>
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹

class ParticleManager
{
public:

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ§‹é€ ä½“
	struct ParticleGroup {		// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ— // ä½¿ç”¨ã™ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ã”ã¨ã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã¨ã—ã¦ã¾ã¨ã‚ã‚‹
		MaterialData materialData;			// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿					
		std::list<Particle> particles;		// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒªã‚¹ãƒˆ		
		uint32_t instancingSrvIndex;					// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ç”¨ã®SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹	
		Microsoft::WRL::ComPtr<ID3D12Resource> instancingResource;	// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ç”¨ã®ãƒªã‚½ãƒ¼ã‚¹
		UINT kNumInstance;					// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹æ•°
		ParticleForGPU* instancingData;		// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚·ãƒ³ã‚°ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ãƒã‚¤ãƒ³ã‚¿
		uint32_t textureSrvIndex;               // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
		
	};

	/// <summary>
	/// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å–å¾—
	/// </summary>
	static ParticleManager* GetInstance();
	/// <summary>
	/// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹å‰Šé™¤
	/// </summary>
	static void DeleteInstance();
private:
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³
	static ParticleManager* instance;
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ã‚³ãƒ”ãƒ¼ç¦æ­¢
	ParticleManager() = default;
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~ParticleManager() = default;
	// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ä»£å…¥æ¼”ç®—å­ã‚’å‰Šé™¤
	ParticleManager(ParticleManager&) = delete;
	// ä»£å…¥æ¼”ç®—å­
	ParticleManager& operator=(ParticleManager&) = delete;


	// åˆæœŸåŒ–å†…éƒ¨å‡¦ç†
	/// <summary>
	/// ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã®åˆæœŸåŒ–
	/// </summary>
	void InitializeRandomEngine();
	/// <summary>
	/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	/// </summary>
	void CreatePipeline();
	/// <summary>
	/// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–(åº§æ¨™ç­‰)
	/// </summary>
	void InitializeVertexData();
	/// <summary>
	/// ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ
	/// </summary>
	void CreateVertexBufferView();
	/// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ–
	/// </summary>
	void InitializeMaterial();

	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ç”Ÿæˆå†…éƒ¨
	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	/// </summary>
	void CreateRootSignature();
	/// <summary>
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	/// </summary>
	void SetGraphicsPipeline();
	/// <summary>
	/// ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š
	/// </summary>
	/// <param name="desc"></param>
	/// <param name="mode"></param>
	void SetBlendMode(D3D12_BLEND_DESC& desc, BlendMode mode);





public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon"></param>
	/// <param name="srvManager"></param>
	/// <param name="camera"></param>
	void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, Camera* camera);


	/// <summary>
	///  ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®ä½œæˆ
	/// </summary>
	/// <param name="name"></param>
	/// <param name="textureFilrPath"></param>
	void CreateParticleGroup(const std::string& name, const std::string textureFilrPath);


	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();

	// æ›´æ–°å†…éƒ¨å‡¦ç†
	/// <summary>
	/// è¡Œåˆ—æ›´æ–°
	/// </summary>
	void UpdateMatrix();
	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ›´æ–°
	/// </summary>
	void UpdateParticle();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã®å‰Šé™¤
	/// </summary>
	/// <param name="name"></param>
	void DeleteParticleGroup(const std::string& name);

	/// <summary>
	/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç™ºç”Ÿ
	/// </summary>
	/// <param name="name"></param>
	/// <param name="position"></param>
	/// <param name="count"></param>
	void Emit(const std::string& name, const Vector3& position, uint32_t count);
	/// <summary>
	/// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ç™ºç”Ÿ(ç‰¹æ®Šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ)
	/// </summary>
	/// <param name="name"></param>
	/// <param name="position"></param>
	/// <param name="count"></param>
	void EffectEmit(const std::string& name, const Vector3& position, uint32_t count);


	/// <summary>
	/// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«(é€šå¸¸)ç”Ÿæˆ
	/// </summary>
	Particle MakeParticle(std::mt19937& randomEngine, const Vector3& position);

	/// <summary>
	/// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã‚¨ãƒ•ã‚§ã‚¯ãƒˆç”Ÿæˆ
	/// </summary>
	Particle MakePrimitiveEffect(std::mt19937& randomEngine, const Vector3& translate);
	/// <summary>
	/// Ringã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	/// </summary>
	/// <param name="position"></param>
	/// <returns></returns>
	Particle MakeRingEffect(const Vector3& position);
	/// <summary>
	/// Cylinderã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	/// </summary>
	/// <param name="position"></param>
	/// <returns></returns>
	Particle MakeCylinderEffect(const Vector3& position);

	/// <summary>
	/// Ring
	/// </summary>
	void CreateRingVertex();
	/// <summary>
	/// RingEffectã®æç”»
	/// </summary>
	void DrawRing();

	/// <summary>
	/// Cylinder
	/// </summary>
	void CreateCylinderVertex();
	/// <summary>
	/// CylinderEffectã®æç”»
	/// </summary>
	void DrawCylinder();

	/// <summary>
	/// ImGuiæç”»
	/// </summary>
	void DrawImgui();

	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ã‚»ãƒƒãƒˆã™ã‚‹
	/// </summary>
	/// <param name="cameraPtr_"></param>
	void SetCamera(Camera* cameraPtr_) { camera = cameraPtr_; }


private:
	// DirectXCommon
	DirectXCommon* dxCommon;
	// SRVãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
	SrvManager* srvManager;
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
	VertexData* vertexData = nullptr;
	// ã‚«ãƒ¡ãƒ©
	Camera* camera = nullptr;

	// ãƒ©ãƒ³ãƒ€ãƒ ã‚¨ãƒ³ã‚¸ãƒ³
	std::mt19937 randomEngine;


	// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	D3D12_ROOT_PARAMETER rootParameters[3] = {};
	// ã‚µãƒ³ãƒ—ãƒ©ãƒ¼
	D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	Microsoft::WRL::ComPtr<ID3D12RootSignature> rootSignature;
	// ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_ELEMENT_DESC inputElementDescs[3];
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆ

	// ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_LAYOUT_DESC inputLayoutDesc{};

	// ãƒ–ãƒ¬ãƒ³ãƒ‰
	BlendMode blendMode;
	BlendMode currentBlendMode;
	D3D12_BLEND_DESC blendDesc{};
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};
	D3D12_RASTERIZER_DESC rasterrizerDesc{};
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
	Microsoft::WRL::ComPtr<ID3D12PipelineState> graphicsPipelineState = nullptr;
	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc;
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒã‚¤ãƒŠãƒª
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob;
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ç™ºç”Ÿä¸Šé™
	static const int kMaxParticle = 1000;

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexResource = nullptr;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ãƒ‡ãƒ¼ã‚¿
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
	ModelData modelData;
	// ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView;
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> materialResource = nullptr;
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿
	Material* materialData = nullptr;
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ— / ã‚°ãƒ«ãƒ¼ãƒ—åã‚’ã‚­ãƒ¼ã«ã—ã¦ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ç®¡ç†
	std::unordered_map<std::string, ParticleGroup> particleGroups;

	// ã‚«ãƒ¡ãƒ©è¡Œåˆ—
	Matrix4x4 cameraMatrix;
	// ãƒ¯ãƒ¼ãƒ«ãƒ‰ãƒ“ãƒ¥ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—
	Matrix4x4 viewMatrix;
	// ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—
	Matrix4x4 projectionMatrix;
	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆè¡Œåˆ—
	Matrix4x4 backToFrontMatrix;
	// ãƒ“ãƒ«ãƒœãƒ¼ãƒ‰è¡Œåˆ—
	Matrix4x4 billboardMatrix;
	bool useBillboard = false;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®ãƒªã‚¹ãƒˆ
	std::list<Particle>particles;

	// Î”tã‚’å®šç¾©ï¼–ï¼foså›ºå®š
	const float kDeltaTime = 1.0f / 60.0f;

	// ãƒªãƒ³ã‚°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	Microsoft::WRL::ComPtr<ID3D12Resource> ringVertexBuffer = nullptr;
	D3D12_VERTEX_BUFFER_VIEW ringVertexBufferView{};
	uint32_t ringVertexCount = 0;

	// UVåº§æ¨™å¤‰æ›´
	Vector2 uvOffset = { 0.0f, 0.0f };
	Vector2 uvScrollSpeed = { 0.1f, 0.0f };  // æ°´å¹³æ–¹å‘ã«æµã™å ´åˆ


};



============================================================
File Path: Game/Scene/GamePlayScene.cpp
============================================================
#include "GamePlayScene.h"
#include "Game/Application/Map/Map.h"
#include "Game/Application/Player/Player.h"
#include "Game/Collision/CollisionManager.h"
#include "Game/Particle/ParticleManager.h"
#include "InsideScene/Framework.h"
#ifdef USE_IMGUI
#include "engine/base/ImGuiManager.h"
#endif
GamePlayScene::GamePlayScene()
{
}

GamePlayScene::~GamePlayScene()
{
}

void GamePlayScene::Initialize(DirectXCommon* dxCommon)
{
	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
	SpriteCommon::GetInstance()->Initialize(dxCommon);
	/// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®åˆæœŸåŒ–
	Audio::GetInstance()->Initialize();
	soundData = Audio::GetInstance()->LoadWave("resources/mokugyo.wav");
	xaudio2_ = Audio::GetInstance()->GetXAudio2();
	Audio::GetInstance()->SoundPlayWave(xaudio2_, soundData);

	// ã‚«ãƒ¡ãƒ©ã‚¯ãƒ©ã‚¹ã®ç”Ÿæˆ
	camera = Framework::GetMainCamera();



	// å›ºå®šYZ
	introFixedY_ = camTargetPos_.y;
	introFixedZ_ = camTargetPos_.z;
	// æ¼”å‡ºé–‹å§‹æ™‚ã®ã‚«ãƒ¡ãƒ©ã®ä½ç½®
	cameraTransform.translate = camTargetPos_;
	// ã‚«ãƒ¡ãƒ©ã«åæ˜ 
	camera->SetTranslate(cameraTransform.translate);
	// ã‚¹ã‚¿ãƒ¼ãƒˆæ¼”å‡ºã®é–‹å§‹
	startPhase_ = StartCamPhase::MoveToLeft;
	startTimer_ = 0.0f;
	stageStartEventFlag_ = true;


	// ãƒãƒƒãƒ—
	map = std::make_unique<Map>();
	map->Initialize("1-1");


	collision_ = std::make_unique<CollisionManager>();

	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆæœŸåŒ–
	player = std::make_unique<Player>();
	player->Initialize(Vector3{ 2.0f,2.0f,0.0f });
	player->SetMap(map.get());
	//player->SetTransitionTiming(TransitionTiming::OnDeath);

	InitializeEnemy();

	//sceneTransition = std::make_unique<SceneTransition>();
	//sceneTransition->Initialize(10);

	titleLogoObject = std::make_unique<Object3D>();
	titleLogoObject->Initialize();
	titleLogoObject->SetModel("title.obj");
	titleLogoTransform = {
		{ 1.0f,1.0f,1.0f },
		{ 1.6f,3.2f,0.0f },
		{ 7.4f,-3.1f,50.0f }
	};

	titleLogoObject->SetTransform(titleLogoTransform);

	backGround = std::make_unique<BackGround>();
	backGround->Initialize();

	cameraController_ = std::make_unique<CameraController>();
	cameraController_->Initialize();

	SpritesInitialize();

	stageStartEventFlag_ = true;
	player->SetControlEnabled(false);

	isPlayerControlLocked_ = true;

}


void GamePlayScene::Update()
{
	camera->Update();


	titleLogoObject->Update();

	backGround->Update();


	// ã‚¹ã‚¿ãƒ¼ãƒˆæ¼”å‡ºä¸­ã¯ã‚«ãƒ¡ãƒ©ã‚’æ›´æ–°
	if (stageStartEventFlag_) {
		UpdateStartCamera(dt);
	}

	bool isEnemyHitNow = player->GetHitEnemy();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒæ•µã«å½“ãŸã£ãŸã‚‰ã‚«ãƒ¡ãƒ©ã‚’ã‚·ã‚§ã‚¤ã‚¯ã™ã‚‹
	if (player->GetHitEnemy() && !wasEnemyHit_) {
		enemyHitShakeActive_ = true;
		enemyHitSprite_->SetColor({ 1.0f, 1.0f, 1.0f, 1.0f });
		enemyHitTimer_ = 0.0f;
		// ã‚«ãƒ¡ãƒ©ã®å…ƒã®ä½ç½®ã‚’ä¿å­˜
		enemyHitBasePos = camera->GetTranslate();

	}
	Vector4 currentColor = enemyHitSprite_->GetColor();
	if (currentColor.w > 0.0f) {
		// æ¸›ç®—ã‚¹ãƒ”ãƒ¼ãƒ‰ã¯ 0.01f ï½ 0.05f ãã‚‰ã„ã§èª¿æ•´ã—ã¦ãã ã•ã„
		float newAlpha = (std::max)(0.0f, currentColor.w - 0.02f);
		enemyHitSprite_->SetColor({ currentColor.x, currentColor.y, currentColor.z, newAlpha });
	}
	wasEnemyHit_ = isEnemyHitNow;

	// ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ã®æ›´æ–°
	if (enemyHitShakeActive_) {
		// 
		EnemyHitShake(dt);
	}

	//sceneTransition->Update();

	/// ãƒãƒƒãƒ—ã®æ›´æ–°
	map->Update();

	// ã‚¨ãƒãƒŸãƒ¼ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒå¤‰æ›´ã•ã‚ŒãŸã‚‰ã‚¨ãƒãƒŸãƒ¼ã‚’å†ç”Ÿæˆ
	if (map->ConsumeEnemyLayerDirtyFlag()) {
		GenerateEnemy();
	}


	/// ãƒãƒƒãƒ—ã¨ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åˆ¤å®šã®ãŸã‚ãƒãƒƒãƒ—ãƒãƒƒãƒ—ãƒ‡ãƒ¼ã‚¿ã‚’ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚‚æ¸¡ã™

	cameraController_->SetFollowRange(8.0f, 92.0f);
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æ›´æ–°
	if (isPlayerControlLocked_) {
		player->SetControlEnabled(false);
	} else {
		player->SetControlEnabled(true);
	}


	player->Update();
	if (stageStartEventFlag_ == false)
	{
		cameraController_->SetCameraPosition(cameraTransform.translate);
		Vector3 playerPosition = player->GetTranslate();
		cameraController_->SetTargetPosition(playerPosition);
		cameraController_->Update(dt);
		cameraTransform.translate = cameraController_->GetCameraPosition();
		camera->SetTranslate(cameraTransform.translate);
	}
	for (auto& enemy : enemies) {
		enemy->Update();
	}

	/// å½“ãŸã‚Šã¯åˆ¤å®š
	CheckCollision();
	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æ›´æ–°
	SpritesUpdate();

	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚´ãƒ¼ãƒ«ã«è§¦ã‚Œã¦ã„ãŸã‚‰ã‚·ãƒ¼ãƒ³é·ç§»
	bool isGoal = player->GetIsGoal();
	if (isGoal) {
		sceneManager->ChangeScene("GAMEPLAY");
	}

	/// ImGuiã®æç”»
	DrawImgui();


}

void GamePlayScene::Draw()
{
	///////////////////
	//  ãƒ¢ãƒ‡ãƒ«ã®æç”»   //
	///////////////////

	backGround->Draw();


	//sceneTransition->Draw();
	/// ãƒãƒƒãƒ—ã®æç”»
	map->Draw();

	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æç”»
	player->Draw();

	/// æ•µã®æç”»
	for (auto& enemy : enemies) {
		enemy->Draw();
	}

	ParticleManager::GetInstance()->Draw();

	///////////////////
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®æç”» //
	///////////////////

	SpritesDraw();

}

void GamePlayScene::InitializeEnemy()
{

	// csvã‚’èª­ã¿è¾¼ã¿æ•µã®é…ç½®æƒ…å ±ã‚’å–å¾—
	GenerateEnemy();

}

void GamePlayScene::GenerateEnemy()
{
	// ã‚¨ãƒãƒŸãƒ¼ã‚’ä¸€æ—¦ã‚¯ãƒªã‚¢
	enemies.clear();

	const EnemyLayerData& enemyLayerData = map->GetEnemyLayerData();
	const auto& enemyData = enemyLayerData.enemyData;

	const uint32_t mapHeight = static_cast<uint32_t>(enemyData.size());
	for (uint32_t y = 0; y < mapHeight; y++) {
		const uint32_t mapWidth = static_cast<uint32_t>(enemyData[y].size());
		for (uint32_t x = 0; x < mapWidth; x++) {
			EnemyType type = enemyData[y][x];
			// æ•µã®ç¨®é¡ãŒNoneãªã‚‰ã‚¹ã‚­ãƒƒãƒ—
			if (EnemyType::None == type) {
				continue;
			}

			// æ•µã®ç”Ÿæˆ
			// EnemyTypeã‹ã‚‰æ•µã®ç¨®é¡ã‚’ç‰¹å®šã—ã¦ç”Ÿæˆ
			std::string enemyId;
			switch (type) {
			case EnemyType::NormalEnemy:
				enemyId = "NormalEnemy";
				break;
			case EnemyType::FlyingEnemy:
				enemyId = "FlyingEnemy";
				break;
			default:
				// æœªçŸ¥ã®ã‚¿ã‚¤ãƒ—
				continue;
			}

			// ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã§ã‚¨ãƒãƒŸãƒ¼ã‚’ç”Ÿæˆ
			auto enemy = EnemyFactory::CreateEnemy(enemyId);
			// ç”Ÿæˆå¤±æ•—ãƒã‚§ãƒƒã‚¯
			if (!enemy) continue;
			// ã‚¨ãƒãƒŸãƒ¼ã®åˆæœŸåŒ–
			enemy->Initialize();
			// ãƒãƒƒãƒ—ä¸Šã®ä½ç½®ã«ã‚»ãƒƒãƒˆ
			Vector3 enemyPos = map->GetMapChipPositionByIndex(x, y);
			// ã‚ªãƒ•ã‚»ãƒƒãƒˆ
			enemyPos.x += enemySpawnOffset_;
			enemyPos.y -= enemySpawnOffset_;
			enemy->SetTranslate(enemyPos);
			// ã‚¨ãƒãƒŸãƒ¼ãƒªã‚¹ãƒˆã«è¿½åŠ 
			enemies.push_back(std::move(enemy));
		}
	}
}

void GamePlayScene::CheckCollision()
{

	collision_->Clear();

	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	if (player) {
		collision_->AddCollider(player.get());
	}

	/// ã‚¨ãƒãƒŸãƒ¼å…¨ç¨®
	for (auto& enemy : enemies) {
		if (!enemy)continue;

		if (enemy->IsAlive()) {
			collision_->AddCollider(enemy.get());
		}
	}
	// è¡çªåˆ¤å®šå®Ÿè¡Œ
	collision_->CheckAllCollisions();

}

void GamePlayScene::UpdateStartCamera(float dt)
{
	// å·¦å³ã®ç«¯ã®åº§æ¨™ / YZã¯å›ºå®š
	Vector3 leftPos = { introLeftX_,introFixedY_,introFixedZ_ };
	Vector3 rightPos = { introRightX_,introFixedY_,introFixedZ_ };
	// é–‹å§‹åº§æ¨™
	Vector3 startPos = { camTargetPos_.x,introFixedY_,introFixedZ_ };

	// StartCamPhaseã®å„ãƒ•ã‚§ãƒ¼ã‚ºã”ã¨ã®å‡¦ç†
	switch (startPhase_) {

	case StartCamPhase::MoveToLeft:
	{
		// @todo: ç†è§£èª¬æ˜
		// ã‚²ãƒ¼ãƒ å†…æ™‚é–“ã‚’é€²ã‚ã‚‹
		startTimer_ += dt;
		// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨
		float t = EaseOutCubic(startTimer_ / introMoveDur_);
		// å·¦ç«¯ã¸ç§»å‹•
		cameraTransform.translate = Lerp(startPos, leftPos, t);

		// ãƒ•ã‚§ãƒ¼ã‚ºç§»è¡Œåˆ¤å®š
		if (startTimer_ >= introMoveDur_) {
			// PanToRightã¸ç§»è¡Œ
			startPhase_ = StartCamPhase::PanToRight;
			// ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
			startTimer_ = 0.0f;
			// ä½ç½®è£œæ­£
			cameraTransform.translate = leftPos;
		}
	}
	break;

	case StartCamPhase::PanToRight:
	{
		// ã‚²ãƒ¼ãƒ å†…æ™‚é–“ã‚’é€²ã‚ã‚‹
		startTimer_ += dt;
		// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨
		float t = EaseOutCubic(startTimer_ / introPanDur_);
		// å³ç«¯ã¸ãƒ‘ãƒ³
		cameraTransform.translate = Lerp(leftPos, rightPos, t);

		// ãƒ•ã‚§ãƒ¼ã‚ºç§»è¡Œåˆ¤å®š / å³ç«¯ã«åˆ°é”ã—ãŸã‚‰
		if (startTimer_ >= introPanDur_) {
			// Holdã¸ç§»è¡Œ
			startPhase_ = StartCamPhase::Hold;
			// ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
			startTimer_ = 0.0f;
			// ä½ç½®è£œæ­£
			cameraTransform.translate = rightPos;
		}
	}
	break;

	case StartCamPhase::Hold:
	{
		// ã‚²ãƒ¼ãƒ å†…æ™‚é–“ã‚’é€²ã‚ã‚‹
		startTimer_ += dt;
		// ãã®ã¾ã¾å³ç«¯ã§åœæ­¢
		cameraTransform.translate = rightPos;
		// ãƒ•ã‚§ãƒ¼ã‚ºç§»è¡Œåˆ¤å®š / åœæ­¢æ™‚é–“çµŒéã—ãŸã‚‰
		if (startTimer_ >= introHoldDur_) {
			// ReturnToStartã¸ç§»è¡Œ
			startPhase_ = StartCamPhase::ReturnToStart;
			// ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
			startTimer_ = 0.0f;
		}
	}
	break;

	case StartCamPhase::ReturnToStart:
	{
		// ã‚²ãƒ¼ãƒ å†…æ™‚é–“ã‚’é€²ã‚ã‚‹
		startTimer_ += dt;

		// 0ï½1ã«æ­£è¦åŒ–ï¼ˆduration=0å¯¾ç­–è¾¼ã¿ï¼‰
		float u = (introReturnDur_ > 0.0f) ? (startTimer_ / introReturnDur_) : 1.0f;
		u = std::clamp(u, 0.0f, 1.0f);

		// ã‚¤ãƒ¼ã‚¸ãƒ³ã‚°é©ç”¨ï¼ˆBackã¯1ã‚’è¶…ãˆå¾—ã‚‹ã®ã§å¿…è¦ãªã‚‰clampï¼‰
		float t = EaseOutBack(u);
		t = std::clamp(t, 0.0f, 1.0f);

		// é–‹å§‹åœ°ç‚¹ã¸æˆ»ã‚‹
		cameraTransform.translate = Lerp(rightPos, startPos, t);

		// ãƒ•ã‚§ãƒ¼ã‚ºç§»è¡Œåˆ¤å®š / é–‹å§‹åœ°ç‚¹ã«æˆ»ã£ãŸã‚‰
		if (startTimer_ >= introReturnDur_) {
			// æ¼”å‡ºçµ‚äº†
			startPhase_ = StartCamPhase::None;
			// ã‚¿ã‚¤ãƒãƒ¼ãƒªã‚»ãƒƒãƒˆ
			startTimer_ = 0.0f;
			// ä½ç½®è£œæ­£ï¼ˆæœ€çµ‚ãƒ•ãƒ¬ãƒ¼ãƒ ã¯å¿…ãšç›®æ¨™ã«å›ºå®šï¼‰
			cameraTransform.translate = startPos;
		}
	} break;


	case StartCamPhase::None:
		// æ¼”å‡ºçµ‚äº†
		stageStartEventFlag_ = false;
		isPlayerControlLocked_ = false;
		player->SetControlEnabled(true);

		break;

	default:
		break;

	}

	camera->SetTranslate(cameraTransform.translate);
}

void GamePlayScene::EnemyHitShake(float dt)
{
	// ã‚¹ã‚¿ãƒ¼ãƒˆæ¼”å‡ºä¸­ã¯ç„¡åŠ¹
	if (stageStartEventFlag_) {
		return;

	}
	enemyHitTimer_ += dt;

	// æ¸›è¡°
	float u = std::clamp(1.0f - (enemyHitTimer_ / enemyHitShakeTime_), 0.0f, 1.0f);

	// ï¼’è»¸(x,y)ã®ã‚·ã‚§ã‚¤ã‚¯
	float sx = std::sin(enemyHitTimer_ * 80.0f);
	float sy = std::sin(enemyHitTimer_ * 100.0f);

	Vector3 offset = { sx * shakeAmp_ * u, sy * shakeAmp_ * u, 0.0f };

	cameraTransform.translate += offset;

	// ã‚·ã‚§ã‚¤ã‚¯çµ‚äº†
	if (enemyHitTimer_ >= enemyHitShakeTime_) {
		enemyHitTimer_ = 0.0f;
		enemyHitShakeActive_ = false;

		// æœ€çµ‚çš„ã«ã¯å…ƒã®ä½ç½®ã«æˆ»ã™
		camera->SetTranslate(enemyHitBasePos);
		cameraTransform.translate = enemyHitBasePos;

	}


}

void GamePlayScene::SpritesInitialize()
{
	// è‡ªæ©ŸãŒãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’å—ã‘ãŸã‚‰ç”»é¢ã‚·ã‚§ã‚¤ã‚¯ä¸­ã«å‡ºã™ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	enemyHitSprite_ = std::make_unique<Sprite>();
	enemyHitSprite_->Initialize("resources/HitDamage.png");
	enemyHitSprite_->SetPosition({ 0.0f,0.0f });
	enemyHitSprite_->SetSize({ 1280.0f,720.0f });

	enemyHitSprite_->SetColor({ 1.0f, 1.0f, 1.0f, 0.0f });

	// ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«UI
	controlUI_D = std::make_unique<Sprite>();
	controlUI_D->Initialize("resources/KyeUI/D.png");
	controlUI_D->SetPosition({ 200.0f,70.0f });
	controlUI_D->SetSize({ 50.0f,50.0f });

	controlUI_A = std::make_unique<Sprite>();
	controlUI_A->Initialize("resources/KyeUI/A.png");
	controlUI_A->SetPosition({ 100.0f,70.0f });
	controlUI_A->SetSize({ 50.0f,50.0f });

	controlUI_S = std::make_unique<Sprite>();
	controlUI_S->Initialize("resources/KyeUI/S.png");
	controlUI_S->SetPosition({ 150.0f,70.0f });
	controlUI_S->SetSize({ 50.0f,50.0f });

	controlUI_W = std::make_unique<Sprite>();
	controlUI_W->Initialize("resources/KyeUI/W.png");
	controlUI_W->SetPosition({ 150.0f,20.0f });
	controlUI_W->SetSize({ 50.0f,50.0f });

	controlUI_DashUI = std::make_unique<Sprite>();
	controlUI_DashUI->Initialize("resources/KyeUI/DashUI.png");
	controlUI_DashUI->SetPosition({ 700.0f,115.0f });
	controlUI_DashUI->SetSize({ 250.0f,100.0f });

	controlUI_move = std::make_unique<Sprite>();
	controlUI_move->Initialize("resources/KyeUI/moveUI.png");
	controlUI_move->SetPosition({ 430.0f,115.0f });
	controlUI_move->SetSize({ 250.0f,100.0f });
}

void GamePlayScene::SpritesUpdate()
{
	enemyHitSprite_->Update();

	// UI
	controlUI_D->Update();
	controlUI_A->Update();
	controlUI_S->Update();
	controlUI_W->Update();
	controlUI_DashUI->Update();
	controlUI_move->Update();

	// æŠ¼ã•ã‚Œã¦ã„ã‚‹ã‚­ãƒ¼ã ã‘è‰²ã‚’æ¿ƒãã™ã‚‹
	if (Input::GetInstance()->PushKey(DIK_D)) {
		controlUI_D->SetColor({ 1.0f,1.0f,1.0f,1.0f });
		// å°‘ã—ã ã‘å³ã«ãšã‚‰ã™
		controlUI_D->SetPosition({ 205.0f,70.0f });
	} else {
		controlUI_D->SetColor({ 1.0f,1.0f,1.0f,0.5f });
		controlUI_D->SetPosition({ 200.0f,70.0f });
	}
	if (Input::GetInstance()->PushKey(DIK_A)) {
		controlUI_A->SetColor({ 1.0f,1.0f,1.0f,1.0f });
		// å°‘ã—ã ã‘å·¦ã«ãšã‚‰ã™
		controlUI_A->SetPosition({ 95.0f,70.0f });
	} else {
		controlUI_A->SetColor({ 1.0f,1.0f,1.0f,0.5f });
		controlUI_A->SetPosition({ 100.0f,70.0f });
	}
	if (Input::GetInstance()->PushKey(DIK_S)) {
		controlUI_S->SetColor({ 1.0f,1.0f,1.0f,1.0f });
		controlUI_S->SetPosition({ 150.0f,75.0f });
	} else {
		controlUI_S->SetColor({ 1.0f,1.0f,1.0f,0.5f });
		controlUI_S->SetPosition({ 150.0f,70.0f });
	}
	if (Input::GetInstance()->PushKey(DIK_W)) {
		controlUI_W->SetColor({ 1.0f,1.0f,1.0f,1.0f });
		controlUI_W->SetPosition({ 150.0f,15.0f });
	} else {
		controlUI_W->SetColor({ 1.0f,1.0f,1.0f,0.5f });
		controlUI_W->SetPosition({ 150.0f,20.0f });
	}
	// ã©ã“ã‹ã—ã‚‰ã®ç§»å‹•ã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ãŸã‚‰DashUIã¨MoveUIã‚’å¼·èª¿
	if (Input::GetInstance()->PushKey(DIK_W) ||
		Input::GetInstance()->PushKey(DIK_A) ||
		Input::GetInstance()->PushKey(DIK_S) ||
		Input::GetInstance()->PushKey(DIK_D)) {
		UiActive_ = true;


	} else {
		controlUI_DashUI->SetColor({ 1.0f,1.0f,1.0f,0.0f });
		controlUI_move->SetColor({ 1.0f,1.0f,1.0f,0.0f });
	}

	if (UiActive_)
	{
		uiTimer++;
	}

	if (uiTimer > 60) {
		controlUI_move->SetColor({ 1.0f,1.0f,1.0f,1.0f });
	}
	if (uiTimer > 240)
	{
		controlUI_DashUI->SetColor({ 1.0f,1.0f,1.0f,1.0f });
	}
	if (uiTimer >= 300)
	{
		UiActive_ = false;
		uiTimer = 0;
	}
}

void GamePlayScene::SpritesDraw()
{
	if (enemyHitShakeActive_ || enemyHitSprite_->GetColor().w > 0.0f) {
		enemyHitSprite_->Draw();
	}
	if (!isPlayerControlLocked_) {

		controlUI_D->Draw();
		controlUI_A->Draw();
		controlUI_S->Draw();
		controlUI_W->Draw();
	}

	//controlUI_DashUI->Draw();
	//controlUI_move->Draw();
}



void GamePlayScene::Finalize()
{
	map->Finalize();

	/// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®çµ‚äº†å‡¦ç†
	Audio::GetInstance()->SoundUnload(&soundData);

	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®çµ‚äº†å‡¦ç†
	SpriteCommon::GetInstance()->Deletenstance();

}


void GamePlayScene::DrawImgui()
{
#ifdef USE_IMGUI
	ImGui::Begin("Camera Settings / GamePlayScene");
	//==============================
	// Start Camera Intro Tuning UI
	//==============================

	// ã‚«ãƒ¡ãƒ©ã®é…ç½® / å›è»¢ä¿®æ­£
	cameraTransform.translate = camera->GetTranslate();
	ImGui::DragFloat3("Camera Position", &cameraTransform.translate.x, 0.1f, -10000.0f, 10000.0f);
	
	cameraTransform.rotate = camera->GetRotate();
	ImGui::DragFloat3("Camera Rotation", &cameraTransform.rotate.x, 0.1f, -180.0f, 180.0f);
	


	if (ImGui::CollapsingHeader("Start Camera Intro", ImGuiTreeNodeFlags_DefaultOpen))
	{
		ImGui::Text("StageStartEventFlag: %s", stageStartEventFlag_ ? "true" : "false");
		ImGui::Text("StartPhase: %d", static_cast<int>(startPhase_));
		ImGui::Text("StartTimer: %.3f", startTimer_);

		ImGui::SeparatorText("Positions");
		ImGui::DragFloat("Intro Left X", &introLeftX_, 0.1f, -10000.0f, 10000.0f);
		ImGui::DragFloat("Intro Right X", &introRightX_, 0.1f, -10000.0f, 10000.0f);

		ImGui::DragFloat("Intro Fixed Y", &introFixedY_, 0.05f, -1000.0f, 1000.0f);
		ImGui::DragFloat("Intro Fixed Z", &introFixedZ_, 0.1f, -1000.0f, 1000.0f);

		ImGui::SeparatorText("Durations (sec)");
		ImGui::DragFloat("Move To Left Dur", &introMoveDur_, 0.01f, 0.0f, 10.0f);
		ImGui::DragFloat("Pan To Right Dur", &introPanDur_, 0.01f, 0.0f, 20.0f);
		ImGui::DragFloat("Hold Dur", &introHoldDur_, 0.01f, 0.0f, 10.0f);
		ImGui::DragFloat("Return Dur", &introReturnDur_, 0.01f, 0.0f, 10.0f);

		// äº‹æ•…é˜²æ­¢ï¼šRight < Left ã«ãªã£ãŸã‚‰å…¥ã‚Œæ›¿ãˆ
		if (introRightX_ < introLeftX_)
		{
			ImGui::TextColored(ImVec4(1, 0.6f, 0.2f, 1), "Warning: RightX < LeftX. Auto swap available.");
			if (ImGui::Button("Swap Left/Right"))
			{
				std::swap(introLeftX_, introRightX_);
			}
		}

		ImGui::SeparatorText("Controls");

		// ãã®å ´ã§æ¼”å‡ºã‚’ã‚„ã‚Šç›´ã™
		if (ImGui::Button("Restart Intro"))
		{
			// æ¼”å‡ºã®ã€Œæˆ»ã‚Šå…ˆã€ã‚’ camTargetPos_ åŸºæº–ã«ã™ã‚‹å ´åˆ
			// introFixedY_/Z ã¯UIã§ã„ã˜ã‚Œã‚‹ã®ã§ãã®ã¾ã¾
			startPhase_ = StartCamPhase::MoveToLeft;
			startTimer_ = 0.0f;
			stageStartEventFlag_ = true;
		}

		ImGui::SameLine();
		if (ImGui::Button("Skip Intro"))
		{
			startPhase_ = StartCamPhase::None;
			startTimer_ = 0.0f;
			stageStartEventFlag_ = false;
		}

		// camTargetPos_ ã‚’èª¿æ•´ã—ãŸã„å ´åˆï¼ˆå¿…è¦ãªã‚‰ï¼‰
		ImGui::SeparatorText("Target (Return) Position");
		ImGui::DragFloat3("Cam Target Pos", &camTargetPos_.x, 0.05f, -10000.0f, 10000.0f);
	}

	ImGui::SeparatorText("ControlUI Positions");
	Vector2 dPos = controlUI_D->GetPosition();
	Vector2 aPos = controlUI_A->GetPosition();
	Vector2 sPos = controlUI_S->GetPosition();
	Vector2 wPos = controlUI_W->GetPosition();

	Vector2 dSize = controlUI_D->GetSize();
	Vector2 aSize = controlUI_A->GetSize();
	Vector2 sSize = controlUI_S->GetSize();
	Vector2 wSize = controlUI_W->GetSize();

	ImGui::DragFloat2("D Position", &dPos.x, 1.0f, 0.0f, 1280.0f);
	ImGui::DragFloat2("D Size", &dSize.x, 1.0f, 0.0f, 500.0f);
	ImGui::DragFloat2("A Position", &aPos.x, 1.0f, 0.0f, 1280.0f);
	ImGui::DragFloat2("A Size", &aSize.x, 1.0f, 0.0f, 500.0f);
	ImGui::DragFloat2("S Position", &sPos.x, 1.0f, 0.0f, 1280.0f);
	ImGui::DragFloat2("S Size", &sSize.x, 1.0f, 0.0f, 500.0f);
	ImGui::DragFloat2("W Position", &wPos.x, 1.0f, 0.0f, 1280.0f);
	ImGui::DragFloat2("W Size", &wSize.x, 1.0f, 0.0f, 500.0f);
	controlUI_D->SetPosition(dPos);
	controlUI_D->SetSize(dSize);
	controlUI_A->SetPosition(aPos);
	controlUI_A->SetSize(aSize);
	controlUI_S->SetPosition(sPos);
	controlUI_S->SetSize(sSize);
	controlUI_W->SetPosition(wPos);
	controlUI_W->SetSize(wSize);

	controlUI_DashUI->SetPosition(controlUI_DashUI->GetPosition());
	Vector2 dashPos = controlUI_DashUI->GetPosition();
	Vector2 dashSize = controlUI_DashUI->GetSize();
	ImGui::DragFloat2("DashUI Position", &dashPos.x, 1.0f, 0.0f, 1280.0f);
	ImGui::DragFloat2("DashUI Size", &dashSize.x, 1.0f, 0.0f, 500.0f);
	controlUI_DashUI->SetPosition(dashPos);
	controlUI_DashUI->SetSize(dashSize);
	controlUI_move->SetPosition(controlUI_move->GetPosition());
	Vector2 movePos = controlUI_move->GetPosition();
	Vector2 moveSize = controlUI_move->GetSize();
	ImGui::DragFloat2("MoveUI Position", &movePos.x, 1.0f, 0.0f, 1280.0f);
	ImGui::DragFloat2("MoveUI Size", &moveSize.x, 1.0f, 0.0f, 500.0f);

	controlUI_move->SetPosition(movePos);
	controlUI_move->SetSize(moveSize);




	if (ImGui::Button("Vertical Camera")) {
		cameraTransform.translate = { 8.0f,20.0f,0.0f };
		cameraTransform.rotate = { 1.6f,0.0f,0.0f };
	}
	ImGui::End();

	camera->SetTranslate(cameraTransform.translate);
	camera->SetRotate(cameraTransform.rotate);
#endif

}

============================================================
File Path: Game/Scene/GamePlayScene.h
============================================================
#pragma once
#include "Audio.h"
#include "SpriteCommon.h"
#include "InsideScene/BaseScene.h"
#include "engine/math/MyMath.h"
#include "Game/Application/Enemy/EnemyFactory.h"
#include "Game/Application/BackGround.h"
#include "Game/Camera/CameraController.h"
#include "Game/Particle/ParticleEmitter.h"
#include "SceneTransition/SceneTransition.h"
// å‰æ–¹å®£è¨€
class Map;
class Player;
class Object3D;
class CollisionManager;
/// <summary>
/// ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã‚·ãƒ¼ãƒ³ : åŸºåº•ã‚·ãƒ¼ãƒ³ã‚¯ãƒ©ã‚¹ã‚’ç¶™æ‰¿
/// </summary>
class GamePlayScene :public BaseScene
{
public:
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	GamePlayScene();
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~GamePlayScene();
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="dxCommon"></param>
	void Initialize(DirectXCommon* dxCommon)override;
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;
	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw()override;
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize()override;

	/// <summary>
	/// Imguiä¸€æ‹¬ç®¡ç† / æç”»é–¢æ•°
	/// </summary>
	void DrawImgui();

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®åˆæœŸåŒ–
	/// </summary>
	void InitializeEnemy();

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ã®ç”Ÿæˆ
	/// </summary>
	void GenerateEnemy();

	/// <summary>\
	/// å½“ãŸã‚Šåˆ¤å®š
	/// </summary>
	void CheckCollision();

	/// <summary>
	/// ã‚¹ã‚¿ãƒ¼ãƒˆã‚«ãƒ¡ãƒ©ã®æ›´æ–°
	/// </summary>
	void UpdateStartCamera(float dt);

	/// <summary>
	/// ã‚¨ãƒãƒŸãƒ¼ãƒ’ãƒƒãƒˆæ™‚ã®ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯
	/// </summary>
	void EnemyHitShake(float dt);

	/// <summary>
	/// UI/ãƒ€ãƒ¡ãƒ¼ã‚¸/ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆé¡ã®åˆæœŸåŒ– / æ›´æ–° / æç”»
	/// </summary>
	void SpritesInitialize();
	void SpritesUpdate();
	void SpritesDraw();

	

private:
	// ãƒãƒƒãƒ—
	std::unique_ptr<Map> map;
	
	// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª
	// ã‚µã‚¦ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿
	SoundData soundData;
	IXAudio2* xaudio2_;

	// Player
	std::unique_ptr<Player> player;


	/// ã‚¨ãƒãƒŸãƒ¼ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
	std::vector<std::unique_ptr<EnemyBase>> enemies;

	/// ã‚³ãƒªã‚¸ãƒ§ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
	std::unique_ptr<CollisionManager> collision_;


	/// ã‚«ãƒ¡ãƒ©
	Camera* camera = nullptr;
	Transform cameraTransform;

	// ã‚¹ã‚¿ãƒ¼ãƒˆæ¼”å‡º
	enum class StartCamPhase {
		None,
		MoveToLeft,   // å·¦ç«¯ã¸ç§»å‹•ï¼ˆåˆæœŸä½ç½®ã‹ã‚‰ï¼‰
		PanToRight,   // å·¦â†’å³ã¸ãƒ‘ãƒ³
		Hold,         // å°‘ã—æ­¢ã‚ã‚‹ï¼ˆä»»æ„ï¼‰
		ReturnToStart // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼é–‹å§‹åœ°ç‚¹ã¸æˆ»ã‚‹
	};

	/// æ¨ªãƒ‘ãƒ³æ¼”å‡º
	// ç›®æ¨™ä½ç½®
	Vector3 camTargetPos_ = { 8.0f,3.5f,-20.0f };
	// å·¦ç«¯ã¸è¡Œãæ™‚é–“
	float introMoveDur_ = 0.6f;
	// å·¦ã‹ã‚‰å³ãƒ‘ãƒ³æ™‚é–“
	float introPanDur_ = 1.6f;
	// å³ç«¯ã§ã®åœæ­¢æ™‚é–“
	float introHoldDur_ = 1.0f;
	// é–‹å§‹åœ°ç‚¹ã¸æˆ»ã‚‹æ™‚é–“
	float introReturnDur_ = 3.0f;

	// å·¦ç«¯ã¨å³ç«¯
	float introLeftX_ = 8.0f;
	float introRightX_ = 92.0f;
	// èƒŒæ™¯ãŒå´©å£Šã—ãªã„é«˜ã•
	float introFixedY_ = 3.5f;
	// å›ºå®šZåº§æ¨™ / é€šå¸¸è·é›¢
	float introFixedZ_ = -20.0f;



	// ç¾åœ¨ã®ãƒ•ã‚§ãƒ¼ã‚º
	StartCamPhase startPhase_ = StartCamPhase::None;
	// ã‚«ãƒ¡ãƒ©ã‚¿ã‚¤ãƒãƒ¼
	float startTimer_ = 0.0f;
	// é–‹å§‹ä½ç½®
	Vector3 camStartPos_;
	
	// ã‚ªãƒ¼ãƒãƒ¼ã‚·ãƒ¥ãƒ¼ãƒˆä½ç½®
	Vector3 camOvershootPos_;
	// ã©ã‚Œã ã‘å¼•ãã‹
	const float pullBack = 30.0f;

	// ã‚«ãƒ¡ãƒ©ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	// ãƒ‰ãƒªãƒ¼ã‚¤ãƒ³æ™‚é–“
	float durDollyIn_ = 2.5f;
	// æºã‚Œæ™‚é–“
	float durSettle_ = 0.35f;
	// ã©ã‚Œãã‚‰ã„è¿‘ã¥ãã‹
	float overShootAmt_ = 2.0f;
	// æºã‚Œã®æ™‚é–“
	float shakeTime_ = 0.3f;
	// æºã‚Œã®å¼·ã•
	float shakeAmp_ = 0.1f;

	static inline float EaseOutCubic(float t) {
		t = std::clamp(t, 0.0f, 1.0f);
		return 1.0f - std::pow(1.0f - t, 3.0f);
	}
	static inline float EaseOutBack(float t, float s = 1.70158f) {
		t = std::clamp(t, 0.0f, 1.0f);
		return 1.0f + (s + 1.0f) * std::pow(t - 1.0f, 3.0f) + s * std::pow(t - 1.0f, 2.0f);
	}
	static inline Vector3 Lerp(const Vector3& a, const Vector3& b, float t) {
		return { a.x + (b.x - a.x) * t, a.y + (b.y - a.y) * t, a.z + (b.z - a.z) * t };
	}


	/// ã‚¿ã‚¤ãƒˆãƒ«ãƒ­ã‚´
	std::unique_ptr<Object3D> titleLogoObject;
	Transform titleLogoTransform;

	/// ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰
	std::unique_ptr<BackGround> backGround;


	// ã‚·ãƒ¼ãƒ³é·ç§»
	std::unique_ptr<SceneTransition> sceneTransition;

	// ãƒ•ã‚©ãƒ­ãƒ¼ã‚«ãƒ¡ãƒ©
	std::unique_ptr<CameraController> cameraController_;

	// ã‚¹ãƒ†ãƒ¼ã‚¸é–‹å§‹æ¼”å‡ºãƒ•ãƒ©ã‚°
	bool stageStartEventFlag_ = true;
	// å›ºå®šãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆç”¨ã®ãƒ‡ãƒ«ã‚¿ã‚¿ã‚¤ãƒ 
	const float dt = 1.0f / 60.0f;

	// ã‚¨ãƒãƒŸãƒ¼é…ç½®ã®ã‚ªãƒ•ã‚»ãƒƒãƒˆ
	float enemySpawnOffset_ = 0.5f;

	// ã‚¨ãƒãƒŸãƒ¼ãƒ’ãƒƒãƒˆã®ã‚·ã‚§ã‚¤ã‚¯æ™‚é–“
	float enemyHitShakeTime_ = 1.0f;
	// ã‚¨ãƒãƒŸãƒ¼ãƒ’ãƒƒãƒˆæ™‚ã®ã‚«ãƒ¡ãƒ©ã‚·ã‚§ã‚¤ã‚¯ç”¨
	bool enemyHitShakeActive_ = false;
	// ã‚·ã‚§ã‚¤ã‚¯æ™‚é–“
	float enemyHitTimer_ = 0.0f;
	// ã‚·ã‚§ã‚¤ã‚¯æŒç¶šæ™‚é–“ 
	Vector3 enemyHitBasePos{};
	// å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã®æ•µå½“ãŸã‚Šåˆ¤å®š
	bool wasEnemyHit_ = false;
	// ã‚¨ãƒãƒŸãƒ¼ãƒ’ãƒƒãƒˆæ™‚ã®ã‚·ã‚§ã‚¤ã‚¯ä¸­ã«å‡ºã™è¢«å¼¾ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::unique_ptr<Sprite> enemyHitSprite_;
	float alpha;

	std::unique_ptr<ParticleEmitter>testParticle_;

	// æ“ä½œUI
	std::unique_ptr<Sprite> controlUI_D;
	Vector2 controlUI_DPos_ = { 100.0f, 600.0f };
	Vector4 controlUIColorD_ = { 1.0f,1.0f,1.0f,0.5f };

	std::unique_ptr<Sprite>controlUI_A;
	Vector2 controlUIAPos_ = { 50.0f,600.0f };
	Vector4 controlUIColorA_ = { 1.0f,1.0f,1.0f,0.5f };

	std::unique_ptr<Sprite>controlUI_W;
	Vector2 controlUIWPos_ = { 75.0f,550.0f };
	Vector4 controlUIColorW_ = { 1.0f,1.0f,1.0f,0.5f };

	std::unique_ptr<Sprite>controlUI_S;
	Vector2 controlUISPos_ = { 75.0f,650.0f };
	Vector4 controlUIColorS_ = { 1.0f,1.0f,1.0f,0.5f };

	std::unique_ptr<Sprite>controlUI_DashUI;
	Vector2 controlUIDashUIPos_ = { 200.0f,600.0f };
	Vector4 controlUIDashUIColor_ = { 1.0f,1.0f,1.0f,0.5f };

	std::unique_ptr<Sprite>controlUI_move;
	Vector2 controlUImovePos_ = { 100.0f,700.0f };
	Vector4 controlUImoveColor_ = { 1.0f,1.0f,1.0f,0.5f };

	// UIã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ•ãƒ©ã‚°
	bool UiActive_ = false;
	int32_t uiTimer = 0;

	bool isPlayerControlLocked_ = false;

};



============================================================
File Path: Game/Scene/MyGame.cpp
============================================================
#include "MyGame.h"
#include "InsideScene/SceneFactory.h"
#include <dxgiformat.h>
#include <memory>
#include <RenderTexture.h>
#include <ModelManager.h>
#include <SkyBox/SkyBox.h>
#include <TextureManager.h>
#include <WinAPI.h>
#include <MyMath.h>
#include <Game/Application/ModelList.h>
#include <InsideScene/Framework.h>
#include <InsideScene/SceneManager.h>
void MyGame::Initialize()
{
	Framework::Initialize();
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ç”Ÿæˆ
	sceneFactory_ = make_unique<SceneFactory>();
	SceneManager::GetInstance()->SetSceneFactory(sceneFactory_.get());
	// ã‚·ãƒ¼ãƒ³managerã«æœ€åˆã®ã‚·ãƒ¼ãƒ³ã‚’ã‚»ãƒƒãƒˆ
	SceneManager::GetInstance()->ChangeScene("TITLE");

	modelList = make_unique<ModelList>();
	modelList->LoadAllModel();

	//ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹
	skyBox = make_unique<SkyBox>();
	skyBox->Initialize(dxCommon.get(), srvManager.get());

	renderTexture = std::make_unique<RenderTexture>();
	renderTexture->Initialize(dxCommon.get(),srvManager.get(),
		WinAPI::kClientWidth,WinAPI::kClientHeight,
		DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, 
		Vector4{ 1.0f, 1.0f, 1.0f, 1.0f });
}

void MyGame::Update()
{
#ifdef USE_IMGUI // ãƒ‡ãƒãƒƒã‚°æ™‚ã®ã¿æœ‰åŠ¹ImGuiã®å‡¦ç†
	imGui->Begin(); 
#endif 
	Framework::Update();
	skyBox->Update();
#ifdef USE_IMGUI // ãƒ‡ãƒãƒƒã‚°æ™‚ã®ã¿æœ‰åŠ¹ImGuiã®å‡¦ç†
	imGui->End();
#endif

}

void MyGame::Draw()
{
	if (usePostProcess_) {
		renderTexture->BeginRender();
		srvManager->PreDraw();
		SceneManager::GetInstance()->Draw();
		renderTexture->EndRender();

		dxCommon->PreDraw();
		srvManager->PreDraw();
		renderTexture->Draw();
	} else {
		dxCommon->PreDraw();
		srvManager->PreDraw();
		SceneManager::GetInstance()->Draw();
	}

	Framework::Draw();

#ifdef USE_IMGUI
	// ImGuiã®æç”»
	imGui->Draw();
#endif
	dxCommon->PostDraw();

	
//	renderTexture->BeginRender();
//	// DirectXã®æç”»æº–å‚™ã€‚å…¨ã¦ã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
//	dxCommon->PreDraw();
//	srvManager->PreDraw();
//
//	// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®æç”»	
//	SceneManager::GetInstance()->Draw();
//
//	
//	renderTexture->EndRender();
//	
//	
//	
//	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®æç”»
//	renderTexture->Draw();
//	// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®æç”»
//	//skyBox->Draw();
//	
//	Framework::Draw();
//	
//#ifdef USE_IMGUI
//	// ImGuiã®æç”»
//	imGui->Draw();
//#endif
//	
//	dxCommon->PostDraw();

}
#pragma region ã‚°ãƒ¬ã‚¤ã‚¹ã‚±ãƒ¼ãƒ«ä¸¦ã³
//void MyGame::Draw()
//{
//
//	renderTexture->BeginRender();
//
//	srvManager->PreDraw();
//	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™ã€‚3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
//	Object3DCommon::GetInstance()->DrawSettingCommon();
//
//	// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®æç”»	
//	SceneManager::GetInstance()->Draw();
//
//
//	renderTexture->EndRender();
//
//	// DirectXã®æç”»æº–å‚™ã€‚å…¨ã¦ã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
//	dxCommon->PreDraw();
//
//	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®æç”»
//	renderTexture->Draw();
//	// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®æç”»
//	//skyBox->Draw();
//
//	Framework::Draw();
//
//#ifdef _DEBUG
//	// ImGuiã®æç”»
//	imGui->Draw();
//#endif
//
//	dxCommon->PostDraw();
//
//}
#pragma endregion

void MyGame::Finalize()
{
	
#pragma region  è§£æ”¾å‡¦ç†
#ifdef USE_IMGUI
	// ImGuiã®çµ‚äº†å‡¦ç†
	imGui->Finalize();
#endif
	// CloseHandle(fenceEvent);
	TextureManager::GetInstance()->Finalize();
	// ãƒ¢ãƒ‡ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ã®çµ‚äº†å‡¦ç†
	ModelManager::GetInstance()->Finalize();
	winAPI->Finalize();

#pragma endregion

	Framework::Finalize();
}


============================================================
File Path: Game/Scene/MyGame.h
============================================================
#pragma once
#include"externals/DirectXTex/d3dx12.h"
#include "InsideScene/Framework.h"
#include "Game/Application/ModelList.h"
#include "engine/3d/SkyBox/SkyBox.h"

// ã‚²ãƒ¼ãƒ å…¨ä½“ : ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯ã‚¯ãƒ©ã‚¹ç¶™æ‰¿
class MyGame :public Framework
{
public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize() override;
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;
	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw()override;
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize()override;


private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	
	// èª­ã¿è¾¼ã‚€ãƒ¢ãƒ‡ãƒ«ã®ãƒªã‚¹ãƒˆ
	std::unique_ptr<ModelList> modelList;
	// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹
	std::unique_ptr<SkyBox> skyBox = nullptr;

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
	bool usePostProcess_ = false;

};



============================================================
File Path: Game/Scene/SceneSelectGraph/StageSelectGraph.cpp
============================================================
#include "StageSelectGraph.h"
#include <fstream>  

StageSelectGraph::StageSelectGraph()
{
}

StageSelectGraph::~StageSelectGraph()
{
}

void StageSelectGraph::Initialize()
{
	//// ãƒãƒ¼ãƒ‰ã®è¿½åŠ 
	//uint32_t nodeA = AddNode({ 0,0 }, 1, true);
	//uint32_t nodeB = AddNode({ 1,0 }, 2, false);
	//uint32_t nodeC = AddNode({ 1,1 }, 3, false);
	//uint32_t nodeD = AddNode({ 2,0 }, 4, false);
	//// ãƒãƒ¼ãƒ‰ã®æ¥ç¶š
	//Link(nodeA, nodeB, Direction::Right);
	//Link(nodeB, nodeC, Direction::Up);
	//Link(nodeB, nodeD, Direction::Down);

	LoadMapNodeFromJson("StageSelectNodes");

}


void StageSelectGraph::Finalize()
{
}

uint32_t StageSelectGraph::AddNode(MapPos pos, uint32_t stageId, bool unlocked)
{
	// æ–°ã—ã„ãƒãƒ¼ãƒ‰ã‚’ä½œæˆ
	StageNode newNode{};
	newNode.id = static_cast<uint32_t>(nodes_.size());
	newNode.position = pos;
	newNode.stageId = stageId;
	newNode.unlocked = unlocked;

	// å…¨æ–¹å‘ã®éš£æ¥ãƒãƒ¼ãƒ‰ã‚’ç„¡åŠ¹ã«è¨­å®š
	for (uint32_t i = 0; i < (uint32_t)Direction::count; i++) {
		newNode.neighbor[i] = INVALID_NODE_ID;
	}
	nodes_.push_back(newNode);
	return newNode.id;
}



void StageSelectGraph::Link(uint32_t fromNodeId, uint32_t toNodeId, Direction dir)
{
	// ãƒãƒ¼ãƒ‰åŒå£«ã‚’æ¥ç¶š
	nodes_[fromNodeId].neighbor[(uint32_t)dir] = toNodeId;
	// é€†æ–¹å‘ã‚‚æ¥ç¶š
	Direction reverseDir{};
	switch (dir) {
	case Direction::Up:		reverseDir = Direction::Down;	break;
	case Direction::Down:	reverseDir = Direction::Up;		break;
	case Direction::Left:	reverseDir = Direction::Right;	break;
	case Direction::Right:	reverseDir = Direction::Left;	break;
	}

	// é€†æ–¹å‘ã®æ¥ç¶š
	nodes_[toNodeId].neighbor[(uint32_t)reverseDir] = fromNodeId;
}

uint32_t StageSelectGraph::Move(uint32_t currentNodeId, Direction dir) const
{
	// ç§»å‹•å…ˆãƒãƒ¼ãƒ‰IDã‚’å–å¾—
	uint32_t nextNodeId = nodes_[currentNodeId].neighbor[(uint32_t)dir];
	
	// æœªæ¥ç¶šã§ã‚ã‚Œã°ç¾åœ¨ã®ãƒãƒ¼ãƒ‰ã‚’è¿”ã™
	if (nextNodeId == INVALID_NODE_ID) {
		return currentNodeId;
	}
	// ãƒ­ãƒƒã‚¯ã•ã‚Œã¦ã„ãŸã‚‰ç§»å‹•ã§ããªã„
	if (!nodes_[nextNodeId].unlocked) {
		return currentNodeId;
	}

	return nextNodeId;
}

const StageNode& StageSelectGraph::GetNode(uint32_t id) const
{

	return nodes_.at(id);

}

void StageSelectGraph::LoadMapNodeFromJson(const std::string& fileName)
{
	// JSONãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒãƒ¼ãƒ‰æƒ…å ±ã‚’èª­ã¿è¾¼ã‚€å‡¦ç†
	// filePathã¯ãƒªã‚½ãƒ¼ã‚¹ãƒ•ã‚©ãƒ«ãƒ€ã‹ã‚‰ã®ç›¸å¯¾ãƒ‘ã‚¹
	const std::string frontFilePath = "resources/StageSelect";
	const std::string kExtension = ".json";
	const std::string fullPath = frontFilePath + "/" + fileName + kExtension;

	// ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
	std::ifstream file;

	// ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	file.open(fullPath);

	// ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãŸã‹ã©ã†ã‹
	if (file.fail()){
		// ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤ºã—ã¦çµ‚äº†
		printf("Failed to open file: %s\n", fullPath.c_str());
		return;
	}

	// JSONæ–‡å­—åˆ—
	nlohmann::json deserialized;
	// ãƒ‘ãƒ¼ã‚¹(è§£å‡)
	file >> deserialized;

	// ãƒãƒ¼ãƒ‰æƒ…å ±ã®ç¢ºèª
	assert(deserialized.contains("nodes"));
	assert(deserialized["nodes"].is_array());

	// æ—¢å­˜ãƒãƒ¼ãƒ‰æƒ…å ±ã®ã‚¯ãƒªã‚¢
	nodes_.clear();

	// -------- 1ãƒ‘ã‚¹ç›®ï¼šãƒãƒ¼ãƒ‰ç”Ÿæˆã®ã¿ --------
	for (const auto& jsonNode : deserialized["nodes"]) {
		// ãƒãƒ¼ãƒ‰æƒ…å ±ã®ç¢ºèª
		assert(jsonNode.contains("position"));
		assert(jsonNode["position"].contains("x"));
		assert(jsonNode["position"].contains("y"));
		assert(jsonNode["position"]["x"].is_number_integer());
		assert(jsonNode["position"]["y"].is_number_integer());

		assert(jsonNode.contains("stage_id"));
		assert(jsonNode["stage_id"].is_number_integer());
		assert(jsonNode.contains("unlocked"));
		assert(jsonNode["unlocked"].is_boolean());

		// ãƒãƒ¼ãƒ‰æƒ…å ±ã®å–å¾—
		MapPos pos{};
		pos.x = jsonNode["position"]["x"].get<uint32_t>();
		pos.y = jsonNode["position"]["y"].get<uint32_t>();
		uint32_t stageId = jsonNode["stage_id"].get<uint32_t>();
		bool unlocked = jsonNode["unlocked"].get<bool>();

		// ãƒãƒ¼ãƒ‰ã®è¿½åŠ 
		AddNode(pos, stageId, unlocked);
	}

	// -------- 2ãƒ‘ã‚¹ç›®ï¼šneighbors è¨­å®š --------
	for (uint32_t i = 0; i < (uint32_t)nodes_.size(); ++i) {
		const auto& jsonNode = deserialized["nodes"][i];

		// neighborsæƒ…å ±ã®ç¢ºèª
		if (!jsonNode.contains("neighbors")) continue;
		assert(jsonNode["neighbors"].is_object());

		// neighborsæƒ…å ±ã®å–å¾—ã¨è¨­å®š
		for (const auto& it : jsonNode["neighbors"].items()) {
			const std::string& dirStr = it.key();
			uint32_t neighborId = it.value().get<uint32_t>();

			// æ–¹å‘ã®æ–‡å­—åˆ—ã‚’Directionåˆ—æŒ™å‹ã«å¤‰æ›
			Direction dir{};
			if (dirStr == "Up") dir = Direction::Up;
			else if (dirStr == "Down") dir = Direction::Down;
			else if (dirStr == "Left") dir = Direction::Left;
			else if (dirStr == "Right") dir = Direction::Right;
			else continue;

			// ç¯„å›²å¤–å‚ç…§ã®ä¿è­·
			if (neighborId >= nodes_.size()) continue;

			// éš£æ¥ãƒãƒ¼ãƒ‰ã®è¨­å®š
			SetNeighbor(i, dir, neighborId);
		}
	}



}


const char* DirectionToString(Direction d)
{
	switch (d) {
	case Direction::Up:    return "Up";
	case Direction::Down:  return "Down";
	case Direction::Left:  return "Left";
	case Direction::Right: return "Right";
	default:               return "Unknown"; 
	}
}


nlohmann::json StageSelectGraph::ToJson() const
{
	// json
	nlohmann::json root;
	// nodes 
	root["nodes"] = nlohmann::json::array();

	for (const auto& n : nodes_) {
		nlohmann::json jn;
		jn["position"] = { {"x",n.position.x},{"y",n.position.y} };
		jn["stage_id"] = n.stageId;
		jn["unlocked"] = n.unlocked;

		nlohmann::json neigh = nlohmann::json::object();
		for (uint32_t i = 0; i < (uint32_t)Direction::count; i++) {
			uint32_t to = n.neighbor[i];
			if (to != INVALID_NODE_ID) {
				neigh[DirectionToString((Direction)i)] = to;
			}
		}
		jn["neighbors"] = neigh;

		root["nodes"].push_back(jn);
	}
	return root;
}

std::string StageSelectGraph::ToJsonString(int indent) const
{
	return ToJson().dump(indent);
}

bool StageSelectGraph::SaveToJsonFile(const std::string& fileName) const
{
	const std::string frontFilePath = "resources/StageSelect";
	const std::string kExtension = ".json";
	const std::string fullPath = frontFilePath + "/" + fileName + kExtension;

	std::ofstream ofs(fullPath);
	if (ofs.fail())return false;

	ofs << ToJsonString(2);
	return true;
}

bool StageSelectGraph::RemoveNode(uint32_t id)
{
	return false;
}

bool StageSelectGraph::SetNodePos(uint32_t id, MapPos pos)
{
	// IDã®ãƒã‚§ãƒƒã‚¯ / ç¯„å›²å¤–ãªã‚‰å¤±æ•—
	if (id >= nodes_.size()) return false;
	// åº§æ¨™ã®è¨­å®š
	nodes_[id].position = pos;
	return true;
}


bool StageSelectGraph::SetNodeStageId(uint32_t id, uint32_t stageId)
{
	// IDã®ãƒã‚§ãƒƒã‚¯ / ç¯„å›²å¤–ãªã‚‰å¤±æ•—
	if (id >= nodes_.size()) return false;
	// ã‚¹ãƒ†ãƒ¼ã‚¸IDã®è¨­å®š
	nodes_[id].stageId = stageId;
	return true;
}

bool StageSelectGraph::SetNodeUnlocked(uint32_t id, bool unlocked)
{
	// IDã®ãƒã‚§ãƒƒã‚¯ / ç¯„å›²å¤–ãªã‚‰å¤±æ•—
	if (id >= nodes_.size()) return false;
	// ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹ã®è¨­å®š
	nodes_[id].unlocked = unlocked;
	return true;
}

bool StageSelectGraph::SetNeighbor(uint32_t from, Direction dir, uint32_t toOrInvalid)
{
	// IDã®ãƒã‚§ãƒƒã‚¯ / ç¯„å›²å¤–ãªã‚‰å¤±æ•—
	if (from >= nodes_.size()) return false;
	// toãŒç„¡åŠ¹ãªãƒãƒ¼ãƒ‰IDã§ãªã„å ´åˆã€ç¯„å›²å¤–ãªã‚‰å¤±æ•—
	if (toOrInvalid != INVALID_NODE_ID && toOrInvalid >= nodes_.size()) return false;
	// éš£æ¥ãƒãƒ¼ãƒ‰ã®è¨­å®š
	nodes_[from].neighbor[(int)dir] = toOrInvalid;
	return true;
}


bool StageSelectGraph::ClearNeighbor(uint32_t from, Direction dir)
{
	// éš£æ¥ãƒãƒ¼ãƒ‰ã‚’ç„¡åŠ¹ã«è¨­å®š
	return SetNeighbor(from, dir, INVALID_NODE_ID);
}


============================================================
File Path: Game/Scene/SceneSelectGraph/StageSelectGraph.h
============================================================
#pragma once
#include "MyMath.h"
#include <vector>
#include <cstdint>
#include <resources/json/json.hpp>
struct MapPos
{
	uint32_t x;
	uint32_t y;
};

enum class Direction
{
	Up,
	Down,
	Left,
	Right,
	count
};

struct StageNode {
	// ãƒãƒ¼ãƒ‰ID
	uint32_t id;
	// ãƒãƒ¼ãƒ‰ã®ä½ç½®
	MapPos position;
	// ã‚¹ãƒ†ãƒ¼ã‚¸ID
	uint32_t stageId;
	// ã‚¢ãƒ³ãƒ­ãƒƒã‚¯çŠ¶æ…‹
	bool unlocked;
	// éš£æ¥ãƒãƒ¼ãƒ‰IDé…åˆ— / èª­ã¿æ–¹ã¯ãƒã‚¤ãƒãƒ¼
	uint32_t neighbor[(uint32_t)Direction::count];
};

/// <summary>
/// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã‚°ãƒ©ãƒ•
/// </summary>
class StageSelectGraph
{
	
public:
	// ç„¡åŠ¹ãªãƒãƒ¼ãƒ‰ID
	static const uint32_t INVALID_NODE_ID = UINT32_MAX;
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	StageSelectGraph();
	~StageSelectGraph();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize();


	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();

	/// <summary>
	/// ãƒãƒ¼ãƒ‰è¿½åŠ 
	/// </summary>
	/// <param name="node">  </param>
	uint32_t AddNode(MapPos pos,uint32_t stageId,bool unlocked);

	/// <summary>
	/// ãƒãƒ¼ãƒ‰æ¥ç¶š
	/// </summary>
	/// <param name="fromNodeId"></param>
	/// <param name="toNodeId"></param>
	/// <param name="dir"></param>
	void Link(uint32_t fromNodeId, uint32_t toNodeId,Direction dir);
	
	/// <summary>
	/// ãƒãƒ¼ãƒ‰ç§»å‹•
	/// </summary>
	/// <param name="currentNodeId">ç§»å‹•å‰</param>
	/// <param name="dir">ç§»å‹•ã®æ–¹å‘</param>
	/// <returns></returns>
	uint32_t Move(uint32_t currentNodeId, Direction dir) const;
	
	/// <summary>
	/// ãƒãƒ¼ãƒ‰å–å¾—
	/// </summary>
	/// <param name="id"></param>
	/// <returns></returns>
	const StageNode& GetNode(uint32_t id)const;

	/// <summary>
	/// jsonãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒãƒ¼ãƒ‰æƒ…å ±ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="jsonNode"></param>
	void LoadMapNodeFromJson(const std::string& fileName);


	nlohmann::json ToJson() const;

	std::string ToJsonString(int indent = 2) const;

	bool SaveToJsonFile(const std::string& fileName) const;
private:
	// ãƒãƒ¼ãƒ‰ãƒªã‚¹ãƒˆ
	std::vector<StageNode> nodes_;

	
public:
	// --- ç·¨é›†APIï¼ˆImGuiç”¨ï¼‰ ---
	bool RemoveNode(uint32_t id);
	// ãƒãƒ¼ãƒ‰æƒ…å ±ç·¨é›†
	bool SetNodePos(uint32_t id, MapPos pos);
	bool SetNodeStageId(uint32_t id, uint32_t stageId);
	bool SetNodeUnlocked(uint32_t id, bool unlocked);
	// éš£æ¥ãƒãƒ¼ãƒ‰ç·¨é›† / è¿½åŠ ãƒ»å‰Šé™¤
	bool SetNeighbor(uint32_t from, Direction dir, uint32_t toOrInvalid);
	bool ClearNeighbor(uint32_t from, Direction dir);
	// ãƒãƒ¼ãƒ‰æ•°å–å¾—
	uint32_t GetNodeCount() const { return (uint32_t)nodes_.size(); }


};



============================================================
File Path: Game/Scene/SceneTransition/SceneTransition.cpp
============================================================
#include "SceneTransition.h"
#ifdef USE_IMGUI
#include "engine/base/ImGuiManager.h"
#endif
#include "engine/2d/SpriteCommon.h"
#include "Input.h"

static inline float Clamp01(float x) { return x < 0.f ? 0.f : (x > 1.f ? 1.f : x); }
static inline float Lerp(float a, float b, float t) { return a + (b - a) * t; }
static inline float EaseInOut(float t) {
	return (t < 0.5f) ? (4.f * t * t * t) : (1.f - powf(-2.f * t + 2.f, 3.f) / 2.f);
}
static inline float EaseIn(float t) { return t * t * t; }
void SceneTransition::Initialize(uint32_t division, uint32_t totalFrame)
{
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆåˆ†å‰²æ•°ã‚’è¨­å®š
	spriteCount = division;

	totalFrames_ = std::max<uint32_t>(2, totalFrame);

	// In / Out ã‚’åŠåˆ†ãšã¤
	inFrames_ = totalFrames_ / 2 + (totalFrames_ % 2);
	outFrames_ = totalFrames_ / 2;

	phase_ = Phase::In;
	frame_ = 0;

	spriteDate = {
		// pos
		{0.0f,50.0f},
		// size
		{0.0f,0.0f},
		// rotate
		{0.0f},
		// color
		{1.0f,1.0f,1.0f,1.0f}
	};

	sprites.clear();
	sprites.reserve(spriteCount);

	const float w = 1280.0f / spriteCount;

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚«ã‚¦ãƒ³ãƒˆåˆ†ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç”Ÿæˆ
	for (uint32_t i = 0; i < spriteCount; i++) {
		Sprite s;
		s.Initialize(textureFilePath);
		s.SetPosition({ i * w, 720.0f });

		// ã‚µã‚¤ã‚º / å·¦ç«¯ã‹ã‚‰å³ç«¯ã¾ã§å‡ç­‰ã«ä¸¦ã¹ã‚‹
		s.SetSize({ w,720.0f });

		s.SetColor({ 1.0f,1.0f,1.0f,1.0f });

		// ç™»éŒ²
		sprites.push_back(s);
	}

}

void SceneTransition::Update() {
	//// ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³ãƒ»ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆã®å‡¦ç†
	//if (!isTransition) {
	//	for (size_t i = 0; i < sprites.size(); ++i) {
	//		auto& s = sprites[i];
	//		float delay = i * 10.0f; // æ®µéšçš„ãªé…å»¶
	//		// ç”»é¢ã‚’è¦†ã†ã¾ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	//		if (timer > delay && timer < delay + 75.0f) {
	//			Vector2 pos = s.GetPosition();
	//			pos.y -= 10.0f; // ä¸Šæ˜‡
	//			s.SetPosition(pos);
	//		}
	//		s.Update();
	//	}
	//	if (timer > 75.0f + (spriteCount - 1) * 10.0f) {
	//		isTransition = true;
	//		timer = 0.0f;
	//	}
	//} else {
	//	for (size_t i = 0; i < sprites.size(); ++i) {
	//		auto& s = sprites[i];
	//		float delay = i * 10.0f; // æ®µéšçš„ãªé…å»¶
	//		// ç”»é¢ã‚’è¦†ã†ã¾ã§ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
	//		if (timer > delay && timer < delay + 75.0f) {
	//			Vector2 pos = s.GetPosition();
	//			pos.y += 10.0f; // ä¸‹é™
	//			s.SetPosition(pos);
	//		}
	//		s.Update();
	//	}
	//	if (timer > 75.0f + (spriteCount - 1) * 10.0f) {
	//		isTransition = false;
	//		timer = 0.0f;
	//	}
	//}

	Imgui();

	auto updatePhase = [&](uint32_t phaseFrames, bool reverse) {
		float phaseT = (phaseFrames == 0) ? 1.0f :
			static_cast<float>(frame_) / static_cast<float>(phaseFrames);
		phaseT = Clamp01(phaseT);

		for (uint32_t i = 0; i < spriteCount; ++i) {
			auto& s = sprites[i];

			float p = Clamp01(phaseT * spriteCount - static_cast<float>(i));
			p = EaseInOut(p);

			// ã“ã“ã‚’ä¿®æ­£ â†“
			float startY = reverse ? 0.0f : 720.0f;
			float endY = reverse ? 720.0f : 0.0f;

			float y = Lerp(startY, endY, p);

			Vector2 pos = s.GetPosition();
			pos.y = y;
			s.SetPosition(pos);


			s.Update();
		}

		if (frame_ >= phaseFrames) { frame_ = 0; return true; }
		++frame_; return false;
		};
	switch (phase_) {
	case Phase::In:
		// ä¸Šæ–¹å‘ã¸ä¸ŠãŒã‚‹æ¼”å‡ºï¼ˆä»Šã¾ã§é€šã‚Šï¼‰
		if (updatePhase(inFrames_, /*reverse=*/false)) {
			// ä¸ŠãŒã‚Šãã£ãŸã‚‰ä¸€æ°—ã«ä¸‹ã’ã‚‹ãƒ•ã‚§ãƒ¼ã‚ºã¸
			phase_ = Phase::Out;
			frame_ = 0;
		}
		break;

	case Phase::Out:
	{
		// t: 0â†’1 ã‚’ outFrames_ ã§é€²ã‚ã‚‹
		float t = (outFrames_ == 0) ? 1.0f
			: static_cast<float>(frame_) / static_cast<float>(outFrames_);
		t = Clamp01(t);
		float te = EaseIn(t); // è½ä¸‹ã¯åŠ é€Ÿã•ã›ã‚‹

		// å…¨ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆåŒæ™‚ã«ã€Œä¸Š(0) â†’ ä¸‹(720)ã€ã¸è½ä¸‹
		for (auto& s : sprites) {
			Vector2 pos = s.GetPosition();
			float startY = pos.y;         // ç›´å‰ã®ä½ç½®ï¼ˆé€šå¸¸ã¯ 0ï¼‰
			float endY = 720.0f;        // ç”»é¢ä¸‹
			// startY ãŒ 0 ã§ãªã„çŠ¶æ³ã§ã‚‚ã‚¹ãƒ ãƒ¼ã‚ºã«è½ã¡ã‚‹ã‚ˆã†ã€Lerp ã‚’æ¯ãƒ•ãƒ¬ãƒ¼ãƒ é©ç”¨
			pos.y = Lerp(startY, endY, te);
			s.SetPosition(pos);
			s.Update();
		}

		if (frame_ >= outFrames_) {
			phase_ = Phase::Done; // totalFrame å†…ã¯ Draw ç¶™ç¶šï¼ˆDone ã§ã‚‚æç”»OKã«ã—ã¦ã„ã‚‹ãªã‚‰ãã®ã¾ã¾ï¼‰
			frame_ = 0;
		} else {
			++frame_;
		}
	}
	break;
	}

}



void SceneTransition::Draw()
{
	//sprite->Draw();

	for (auto& s : sprites) {
		s.Draw();
	}
}

void SceneTransition::Imgui()
{
#ifdef USE_IMGUI
	ImGui::Begin("SceneTransition Debug");

	ImGui::Text("=== çŠ¶æ…‹ ===");
	const char* phaseNames[] = { "In", "Out", "Done" };
	ImGui::Text("Phase : %s", phaseNames[static_cast<int>(phase_)]);
	ImGui::Text("Frame : %u / Total %u", frame_, totalFrames_);
	ImGui::Text("In  : %u  Out : %u", inFrames_, outFrames_);
	ImGui::Separator();

	// é€²è¡Œåº¦ãƒãƒ¼
	float normalized = 0.0f;
	switch (phase_) {
	case Phase::In:  normalized = static_cast<float>(frame_) / inFrames_;  break;
	case Phase::Out: normalized = static_cast<float>(frame_) / outFrames_; break;
	default: break;
	}
	ImGui::ProgressBar(normalized, ImVec2(200, 20));
	ImGui::Text("Progress : %.2f %%", normalized * 100.0f);

	ImGui::Separator();
	ImGui::Text("=== ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ ===");
	ImGui::DragInt("SpriteCount", reinterpret_cast<int*>(&spriteCount), 1, 1, 100);
	ImGui::DragInt("TotalFrames", reinterpret_cast<int*>(&totalFrames_), 1, 10, 600);
	ImGui::DragFloat("BaseY", &baseY_, 1.0f, -2000.0f, 2000.0f);
	ImGui::DragFloat("TravelY", &travelY_, 1.0f, 0.0f, 3000.0f);

	// å‹•ãã®ç¢ºèªã‚’ã—ã‚„ã™ãã™ã‚‹ãŸã‚ã®æ‰‹å‹•ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«
	static float speed = 1.0f;
	ImGui::DragFloat("Speed Multiplier", &speed, 0.01f, 0.1f, 5.0f, "%.2fx");

	// ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
	if (ImGui::Button("Reset Transition")) {
		Initialize(spriteCount, totalFrames_);
	}

	// å¼·åˆ¶ãƒ•ã‚§ãƒ¼ã‚ºåˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³
	ImGui::Separator();
	if (ImGui::Button("Force -> In")) { phase_ = Phase::In;  frame_ = 0; }
	ImGui::SameLine();
	if (ImGui::Button("Force -> Out")) { phase_ = Phase::Out; frame_ = 0; }
	ImGui::SameLine();
	if (ImGui::Button("Force -> Done")) { phase_ = Phase::Done; }

	ImGui::Separator();
	ImGui::Text("=== å€‹åˆ¥ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆæƒ…å ± ===");
	for (size_t i = 0; i < sprites.size(); ++i) {
		const Vector2& pos = sprites[i].GetPosition();
		ImGui::Text("Sprite[%zu] : Y = %.2f", i, pos.y);
	}

	ImGui::End();
#endif
}


float SceneTransition::RandomRange(float min, float max)
{
	static std::mt19937 mt{ std::random_device{}() };
	std::uniform_real_distribution<float> dist(min, max);
	return dist(mt);
}


============================================================
File Path: Game/Scene/SceneTransition/SceneTransition.h
============================================================
#pragma once
#include <memory>
#include "engine/3d/Object3D.h"
#include "engine/2d/Sprite.h"
#include <random>


class SceneTransition
{
	public:
	enum class Type {
		kNone,
		kFadeIn,
		kFadeOut,
	};

	enum class Phase {
		In, Out,Done
	};

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	/// <param name="division"></param>
	void Initialize(uint32_t division,uint32_t totalFrame);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();
	/// <summary>
	/// Imgui
	/// </summary>
	void Imgui();
	
	/// <summary>
	/// ãƒ©ãƒ³ãƒ€ãƒ ãªå®Ÿæ•°å€¤ã‚’ç”Ÿæˆ
	/// </summary>
	/// <param name="min"></param>
	/// <param name="max"></param>
	/// <returns></returns>
	float RandomRange(float min, float max);

	/// <summary>
	/// ãƒ•ã‚§ãƒ¼ã‚ºã‚’Doneã«è¨­å®š
	/// </summary>
	bool IsFinished() const { return phase_ == Phase::Done; }

	
private:
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆãƒ‡ãƒ¼ã‚¿
	SpriteData spriteDate;
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::unique_ptr<Sprite> sprite;
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆé…åˆ—
	std::vector<Sprite> sprites;
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆåˆ†å‰²æ•°
	uint32_t spriteCount;
	
	// é€²è¡Œç®¡ç†
	Phase phase_ = Phase::In;

	uint32_t frame_ = 0;

	uint32_t totalFrames_ = 120;

	uint32_t inFrames_ = 60;
	uint32_t outFrames_ = 60;

	float baseY_ = 720.0f;
	float travelY_ = 1080.0f;



	std::string textureFilePath = "resources/Black.png";

};



============================================================
File Path: Game/Scene/StageClearScene.cpp
============================================================
#include "StageClearScene.h"
#include "Game/Camera/Camera.h"
#include "InsideScene/Framework.h"
#include "Input.h"
#include "ImGuiManager.h"
StageClearScene::StageClearScene()
{
}

StageClearScene::~StageClearScene()
{
}

void StageClearScene::Initialize(DirectXCommon* dxCommon)
{
	// ã‚«ãƒ¡ãƒ©ã®å–å¾—ã¨è¨­å®š
	camera = Framework::GetMainCamera();
	cameraTransform.translate = { 0.0f,0.0f,-10.0f };
	cameraTransform.rotate = { 0.0f,0.0f,0.0f };
	camera->SetTranslate(cameraTransform.translate);
	camera->SetRotate(cameraTransform.rotate);

	// @todo: ãŠç¥ã„æ„Ÿã®ã‚ã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’é™ã‚‰ã›ã‚‹


}

void StageClearScene::Update()
{
	// ã‚«ãƒ¡ãƒ©ã®æ›´æ–°
	camera->Update();

	// ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹ (1)
	if (Input::GetInstance()->TriggerKey(DIK_1)) {
		SceneManager::GetInstance()->ChangeScene("TITLE");
	}
	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã¸æˆ»ã‚‹ (2)
	else if (Input::GetInstance()->TriggerKey(DIK_2)) {
		SceneManager::GetInstance()->ChangeScene("STAGESELECT");
	}
	// ã‚²ãƒ¼ãƒ ãƒ—ãƒ¬ã‚¤ã¸æˆ»ã‚‹ (3)
	else if (Input::GetInstance()->TriggerKey(DIK_3)) {
		SceneManager::GetInstance()->ChangeScene("GAMEPLAY");
	}
	// ImGuiã®æç”»
	DrawImgui();
}

void StageClearScene::Draw()
{

}

void StageClearScene::Finalize()
{

}

void StageClearScene::DrawImgui()
{
#ifdef USE_IMGUI
	ImGui::Begin("StageClearScene");
	// ã‚·ãƒ¼ãƒ³é·ç§»ã®èª¬æ˜
	ImGui::Text("Press 1 to go to Title Scene");
	ImGui::Text("Press 2 to go to Stage Select Scene");
	ImGui::Text("Press 3 to go to Game Play Scene");

	// ã‚«ãƒ¡ãƒ©ä½ç½®ã®èª¿æ•´
	ImGui::DragFloat3("CameraPos", &cameraTransform.translate.x, 0.1f);
	ImGui::DragFloat3("CameraRot", &cameraTransform.rotate.x, 0.01f);
	camera->SetTranslate(cameraTransform.translate);
	camera->SetRotate(cameraTransform.rotate);

	ImGui::End();
#endif
}


============================================================
File Path: Game/Scene/StageClearScene.h
============================================================
#pragma once
#include "InsideScene/BaseScene.h"
#include "MyMath.h"

class Object3D;
class Camera;
class StageClearScene :
    public BaseScene
{
public:
	StageClearScene();
	~StageClearScene();

	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize(DirectXCommon* dxCommon)override;

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update()override;

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw()override;

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize()override;

	/// <summary>
	/// Imguiä¸€æ‹¬ç®¡ç†
	/// </summary>
	void DrawImgui();

private:
	/// ã‚«ãƒ¡ãƒ©
	Camera* camera = nullptr;
	Transform cameraTransform;
};



============================================================
File Path: Game/Scene/StageSelectScene.cpp
============================================================
#include "StageSelectScene.h"
#include "InsideScene/Framework.h"
#include "Game/Camera/Camera.h"
#include "engine/3d/Object3D.h"
#ifdef USE_IMGUI
#include "engine/base/ImGuiManager.h"
#endif

StageSelectScene::StageSelectScene()
{
}

StageSelectScene::~StageSelectScene()
{
}

void StageSelectScene::Initialize(DirectXCommon* dxCommon)
{
	// ã‚«ãƒ¡ãƒ©ã®å–å¾—
	camera = Framework::GetMainCamera();
	cameraTransform.translate = { 0.0f,20.0f,0.0f };
	cameraTransform.rotate = { 0.35f,0.0f,0.0f };
	camera->SetTranslate(cameraTransform.translate);
	camera->SetRotate(cameraTransform.rotate);
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ–
	playerModel = std::make_unique<Object3D>();
	playerModel->Initialize();
	playerModel->SetModel("Player.obj");
	playerTransform = {
		// scale
		{1.5f,1.5f,1.5f},
		// rotate
		{0.0f,0.0f,0.0f},
		// translate
		{-20.0f,1.0f,50.0f},
	};
	playerModel->SetTransform(playerTransform);

	// èƒŒæ™¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®åˆæœŸåŒ–
	stageSelectBase1 = std::make_unique<Object3D>();
	stageSelectBase1->Initialize();
	stageSelectBase1->SetModel("SelectBaseGround.obj");
	stageSelectBase1Transform = {
		// Scale
		{ 1.5f, 1.0f, 2.5f },
		// Rotate
		{ 0.0f, 0.0f, 0.0f },
		// Translate
		{ 0.0f, 0.0f, 50.0f }
	};
	stageSelectBase1->SetTransform(stageSelectBase1Transform);

	skyBack = std::make_unique<Object3D>();
	skyBack->Initialize();
	skyBack->SetModel("BackSky.obj");
	skyBackTransform = {
		// Scale
		{ 50.0f, 50.0f, 40.0f },
		// Rotate
		{ 3.2f, 0.0f, 0.0f },
		// Translate
		{ 0.0f, 0.0f, 100.0f }
	};
	skyBack->SetTransform(skyBackTransform);


	stageSelectGraph = std::make_unique<StageSelectGraph>();
	stageSelectGraph->Initialize();
	// ãƒãƒ¼ãƒ‰ã®è¿½åŠ 
	startNodeId = 0;
	currentNodeId = startNodeId;

	ApplyNodeToCursorTransform();
}

void StageSelectScene::Update()
{
	// ç©ºèƒŒæ™¯ã®æ›´æ–°
	skyBack->Update();
	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆåœŸå°ã®æ›´æ–°
	stageSelectBase1->Update();

	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆå…¥åŠ›å‡¦ç†
	ApplyNodeToCursorTransform();

	// å…¥åŠ›ã—ãŸæ–¹å‘ã«ç§»å‹• 
	HandleSelectInput();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•å‡¦ç†
	PlayerMove();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ‡ãƒ«ã®æ›´æ–°
	playerModel->Update();

	// ImGuiã®æç”»
	DrawImgui();
}

void StageSelectScene::Draw()
{
	// ç©ºèƒŒæ™¯ã®æç”»
	skyBack->Draw();
	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆåœŸå°ã®æç”»
	stageSelectBase1->Draw();
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ¢ãƒ‡ãƒ«ã®æç”»
	playerModel->Draw();
}

void StageSelectScene::Finalize()
{
}

void StageSelectScene::DrawImgui()
{
#ifdef USE_IMGUI
	ImGui::Begin("StageSelectScene");
	// ã‚«ãƒ¡ãƒ©ä½ç½®ã®èª¿æ•´
	ImGui::DragFloat3("CameraPos", &cameraTransform.translate.x, 0.1f);
	ImGui::DragFloat3("CameraRot", &cameraTransform.rotate.x, 0.01f);
	camera->SetTranslate(cameraTransform.translate);
	camera->SetRotate(cameraTransform.rotate);

	ImGui::Separator();

	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼
	Transform transform = playerModel->GetTransform();
	ImGui::DragFloat3("PlayerPos", &transform.translate.x, 0.1f);
	ImGui::DragFloat3("PlayerRot", &transform.rotate.x, 0.1f);
	ImGui::DragFloat3("PlayerScale", &transform.scale.x, 0.1f);
	playerModel->SetTransform(transform);

	ImGui::Separator();
	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆåœŸå°ï¼‘
	stageSelectBase1Transform = stageSelectBase1->GetTransform();
	ImGui::DragFloat3("StageSelectBase1Pos", &stageSelectBase1Transform.translate.x, 0.1f);
	ImGui::DragFloat3("StageSelectBase1Rot", &stageSelectBase1Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("StageSelectBase1Scale", &stageSelectBase1Transform.scale.x, 0.1f);
	stageSelectBase1->SetTransform(stageSelectBase1Transform);

	ImGui::Separator();

	// ç©ºèƒŒæ™¯
	skyBackTransform = skyBack->GetTransform();
	ImGui::DragFloat3("SkyBackPos", &skyBackTransform.translate.x, 0.1f);
	ImGui::DragFloat3("SkyBackRot", &skyBackTransform.rotate.x, 0.1f);
	ImGui::DragFloat3("SkyBackScale", &skyBackTransform.scale.x, 0.1f);
	skyBack->SetTransform(skyBackTransform);

	ImGui::End();
	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã‚°ãƒ©ãƒ•ã®ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º
	DrawSelectGraphImGui();
#endif
}

void StageSelectScene::PlayerMove()
{
	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®åº§æ¨™å–å¾—
	Transform transform = playerModel->GetTransform();

	if (Input::GetInstance()->PushKey(DIK_W)) {
		transform.translate.z += 0.5f;
	}

	playerModel->SetTransform(transform);
}

void StageSelectScene::HandleSelectInput()
{
	if (Input::GetInstance()->TriggerKey(DIK_W)) {
		currentNodeId = stageSelectGraph->Move(currentNodeId, Direction::Up);
	} else if (Input::GetInstance()->TriggerKey(DIK_S)) {
		currentNodeId = stageSelectGraph->Move(currentNodeId, Direction::Down);
	} else if (Input::GetInstance()->TriggerKey(DIK_A)) {
		currentNodeId = stageSelectGraph->Move(currentNodeId, Direction::Left);
	} else if (Input::GetInstance()->TriggerKey(DIK_D)) {
		currentNodeId = stageSelectGraph->Move(currentNodeId, Direction::Right);
	}
}

void StageSelectScene::ApplyNodeToCursorTransform()
{
	const StageNode& node = stageSelectGraph->GetNode(currentNodeId);
	MapPos pos = node.position;
	Vector3 translate = playerModel->GetTransform().translate;
	translate.x += static_cast<float>(pos.x);
	translate.y;
	translate.z += static_cast<float>(pos.y);
	playerModel->SetTranslate(translate);

	
}

void StageSelectScene::DrawSelectGraphImGui()
{
#ifdef USE_IMGUI
    // Graph ãŒç„¡ã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
    if (!stageSelectGraph)
    {
        ImGui::Begin("StageSelect Graph");
        ImGui::TextDisabled("stageSelectGraph is null.");
        ImGui::End();
        return;
    }

    const uint32_t count = stageSelectGraph->GetNodeCount();

    // é¸æŠIDã®è£œæ­£
    if (count == 0)
    {
        editNodeId_ = 0;
        prevEditNodeId_ = UINT32_MAX; // æ¬¡ã«ãƒãƒ¼ãƒ‰ãŒã§ããŸã‚‰ãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹ã‚ˆã†ã«
    } else if (editNodeId_ >= count)
    {
        editNodeId_ = count - 1;
    }

    // é¸æŠãŒå¤‰ã‚ã£ãŸã¨ãã ã‘ç·¨é›†ãƒãƒƒãƒ•ã‚¡ã¸ãƒ­ãƒ¼ãƒ‰ï¼ˆâ˜…é€”ä¸­ç·¨é›†ã§ããªã„å•é¡Œã®è§£æ¶ˆç‚¹ï¼‰
    auto toUi = [&](uint32_t id)->int {
        return (id == StageSelectGraph::INVALID_NODE_ID) ? -1 : (int)id;
        };

    if (count > 0 && editNodeId_ != prevEditNodeId_)
    {
        prevEditNodeId_ = editNodeId_;
        const StageNode& n = stageSelectGraph->GetNode(editNodeId_);

        editX_ = (int)n.position.x;
        editY_ = (int)n.position.y;
        editStageId_ = (int)n.stageId;
        editUnlocked_ = n.unlocked;

        editNeighUp_ = toUi(n.neighbor[(int)Direction::Up]);
        editNeighDown_ = toUi(n.neighbor[(int)Direction::Down]);
        editNeighLeft_ = toUi(n.neighbor[(int)Direction::Left]);
        editNeighRight_ = toUi(n.neighbor[(int)Direction::Right]);

        jsonDirty_ = true;
    }

    auto toId = [&](int v)->uint32_t {
        return (v < 0) ? StageSelectGraph::INVALID_NODE_ID : (uint32_t)v;
        };

    auto validateNeighbor = [&](int v)->int {
        if (v < 0) return 0;                 // none
        if ((uint32_t)v >= count) return 2;  // invalid
        return 1;                            // ok
        };

    // ========= UI =========
    ImGui::Begin("StageSelect Graph", nullptr, ImGuiWindowFlags_NoCollapse);

    ImGui::Text("Nodes: %u", count);
    ImGui::SameLine();
    ImGui::TextDisabled("Selected: %u", (count > 0) ? editNodeId_ : 0);
    ImGui::Separator();

    // ---- Tabs ----
    if (ImGui::BeginTabBar("GraphTabs"))
    {
        // ======================
        // List tab
        // ======================
        if (ImGui::BeginTabItem("List"))
        {
            ImGui::Checkbox("Unlocked only", &filterUnlockedOnly_);
            ImGui::SameLine();
            ImGui::SetNextItemWidth(140.0f);
            ImGui::InputInt("Filter StageId", &filterStageId_);
            ImGui::SameLine();
            if (ImGui::Button("Clear"))
            {
                filterUnlockedOnly_ = false;
                filterStageId_ = -1;
            }

            ImGui::Separator();

            ImGui::BeginChild("NodeList", ImVec2(0, 0), true);

            if (ImGui::BeginTable("nodes_table", 6,
                ImGuiTableFlags_RowBg | ImGuiTableFlags_Borders | ImGuiTableFlags_ScrollY |
                ImGuiTableFlags_Resizable | ImGuiTableFlags_SizingStretchProp))
            {
                ImGui::TableSetupColumn("Index", ImGuiTableColumnFlags_WidthFixed, 60);
                ImGui::TableSetupColumn("StageId", ImGuiTableColumnFlags_WidthFixed, 70);
                ImGui::TableSetupColumn("Unlocked", ImGuiTableColumnFlags_WidthFixed, 80);
                ImGui::TableSetupColumn("X", ImGuiTableColumnFlags_WidthFixed, 60);
                ImGui::TableSetupColumn("Y", ImGuiTableColumnFlags_WidthFixed, 60);
                ImGui::TableSetupColumn("Neigh", ImGuiTableColumnFlags_WidthFixed, 70);
                ImGui::TableHeadersRow();

                for (uint32_t i = 0; i < count; ++i)
                {
                    const StageNode& n = stageSelectGraph->GetNode(i);

                    if (filterUnlockedOnly_ && !n.unlocked) continue;
                    if (filterStageId_ >= 0 && (int)n.stageId != filterStageId_) continue;

                    int neighCount = 0;
                    for (int d = 0; d < (int)Direction::count; ++d)
                        if (n.neighbor[d] != StageSelectGraph::INVALID_NODE_ID) neighCount++;

                    ImGui::TableNextRow();

                    ImGui::TableNextColumn();
                    bool selected = (editNodeId_ == i);

                    ImGui::PushID((int)i);
                    if (!n.unlocked) ImGui::PushStyleColor(ImGuiCol_Text, IM_COL32(160, 160, 160, 255));
                    if (ImGui::Selectable("##row", selected, ImGuiSelectableFlags_SpanAllColumns))
                    {
                        editNodeId_ = i;     // æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã§ãƒãƒƒãƒ•ã‚¡ãŒãƒ­ãƒ¼ãƒ‰ã•ã‚Œã‚‹
                    }
                    if (!n.unlocked) ImGui::PopStyleColor();
                    ImGui::PopID();

                    ImGui::SameLine();
                    ImGui::Text("%u", i);

                    ImGui::TableNextColumn(); ImGui::Text("%u", n.stageId);
                    ImGui::TableNextColumn(); ImGui::TextUnformatted(n.unlocked ? "Yes" : "No");
                    ImGui::TableNextColumn(); ImGui::Text("%u", n.position.x);
                    ImGui::TableNextColumn(); ImGui::Text("%u", n.position.y);
                    ImGui::TableNextColumn(); ImGui::Text("%d", neighCount);
                }

                ImGui::EndTable();
            }

            ImGui::EndChild();
            ImGui::EndTabItem();
        }

        // ======================
        // Node tab
        // ======================
        if (ImGui::BeginTabItem("Node"))
        {
            if (count == 0)
            {
                ImGui::TextDisabled("No nodes.");
            } else
            {
                ImGui::Text("Editing node: %u", editNodeId_);
                ImGui::Separator();

                ImGui::SetNextItemWidth(200.0f);
                ImGui::InputInt("StageId", &editStageId_);
                ImGui::Checkbox("Unlocked", &editUnlocked_);

                ImGui::Separator();

                ImGui::SetNextItemWidth(120.0f);
                ImGui::InputInt("PosX", &editX_);
                ImGui::SameLine();
                ImGui::SetNextItemWidth(120.0f);
                ImGui::InputInt("PosY", &editY_);

                if (ImGui::Button("Apply Node"))
                {
                    stageSelectGraph->SetNodeStageId(editNodeId_, (uint32_t)(std::max)(editStageId_, 0));
                    stageSelectGraph->SetNodeUnlocked(editNodeId_, editUnlocked_);
                    stageSelectGraph->SetNodePos(editNodeId_, {
                        (uint32_t)(std::max)(editX_, 0),
                        (uint32_t)(std::max)(editY_, 0)
                        });

                    jsonDirty_ = true;
                }

                ImGui::SameLine();
                if (ImGui::Button("Reload From Graph"))
                {
                    prevEditNodeId_ = UINT32_MAX; // æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã§å†ãƒ­ãƒ¼ãƒ‰
                }
            }

            ImGui::EndTabItem();
        }

        // ======================
        // Neighbors tab
        // ======================
        if (ImGui::BeginTabItem("Neighbors"))
        {
            if (count == 0)
            {
                ImGui::TextDisabled("No nodes.");
            } else
            {
                ImGui::Text("Editing node: %u", editNodeId_);
                ImGui::TextDisabled("Use -1 for none. Valid range: 0..%u", (count > 0) ? (count - 1) : 0);
                ImGui::Separator();

                ImGui::SetNextItemWidth(140.0f); ImGui::InputInt("Up", &editNeighUp_);
                {
                    int s = validateNeighbor(editNeighUp_);
                    ImGui::SameLine();
                    if (s == 0) ImGui::TextDisabled("none");
                    else if (s == 2) ImGui::TextColored(ImVec4(1, 0.2f, 0.2f, 1), "invalid");
                    else ImGui::Text("ok");
                }

                ImGui::SetNextItemWidth(140.0f); ImGui::InputInt("Down", &editNeighDown_);
                {
                    int s = validateNeighbor(editNeighDown_);
                    ImGui::SameLine();
                    if (s == 0) ImGui::TextDisabled("none");
                    else if (s == 2) ImGui::TextColored(ImVec4(1, 0.2f, 0.2f, 1), "invalid");
                    else ImGui::Text("ok");
                }

                ImGui::SetNextItemWidth(140.0f); ImGui::InputInt("Left", &editNeighLeft_);
                {
                    int s = validateNeighbor(editNeighLeft_);
                    ImGui::SameLine();
                    if (s == 0) ImGui::TextDisabled("none");
                    else if (s == 2) ImGui::TextColored(ImVec4(1, 0.2f, 0.2f, 1), "invalid");
                    else ImGui::Text("ok");
                }

                ImGui::SetNextItemWidth(140.0f); ImGui::InputInt("Right", &editNeighRight_);
                {
                    int s = validateNeighbor(editNeighRight_);
                    ImGui::SameLine();
                    if (s == 0) ImGui::TextDisabled("none");
                    else if (s == 2) ImGui::TextColored(ImVec4(1, 0.2f, 0.2f, 1), "invalid");
                    else ImGui::Text("ok");
                }

                if (ImGui::Button("Apply Neighbors"))
                {
                    stageSelectGraph->SetNeighbor(editNodeId_, Direction::Up, toId(editNeighUp_));
                    stageSelectGraph->SetNeighbor(editNodeId_, Direction::Down, toId(editNeighDown_));
                    stageSelectGraph->SetNeighbor(editNodeId_, Direction::Left, toId(editNeighLeft_));
                    stageSelectGraph->SetNeighbor(editNodeId_, Direction::Right, toId(editNeighRight_));
                    jsonDirty_ = true;
                }

                ImGui::SameLine();
                if (ImGui::Button("Jump To Up") && editNeighUp_ >= 0 && (uint32_t)editNeighUp_ < count)    editNodeId_ = (uint32_t)editNeighUp_;
                ImGui::SameLine();
                if (ImGui::Button("Jump To Down") && editNeighDown_ >= 0 && (uint32_t)editNeighDown_ < count) editNodeId_ = (uint32_t)editNeighDown_;

                if (ImGui::Button("Jump To Left") && editNeighLeft_ >= 0 && (uint32_t)editNeighLeft_ < count) editNodeId_ = (uint32_t)editNeighLeft_;
                ImGui::SameLine();
                if (ImGui::Button("Jump To Right") && editNeighRight_ >= 0 && (uint32_t)editNeighRight_ < count) editNodeId_ = (uint32_t)editNeighRight_;
            }

            ImGui::EndTabItem();
        }

        // ======================
        // JSON tab
        // ======================
        if (ImGui::BeginTabItem("JSON"))
        {
            ImGui::TextDisabled("Graph JSON preview (read-only).");

            if (ImGui::Button("Refresh"))
            {
                jsonDirty_ = true;
            }
            ImGui::SameLine();

            static char saveName[128] = "StageSelectNodes";
            ImGui::SetNextItemWidth(220.0f);
            ImGui::InputText("Save BaseName", saveName, sizeof(saveName));
            ImGui::SameLine();
            if (ImGui::Button("Save JSON"))
            {
                stageSelectGraph->SaveToJsonFile(saveName);
            }

            ImGui::Separator();

            if (jsonDirty_)
            {
                std::string s = stageSelectGraph->ToJsonString(2);
                strncpy_s(jsonBuf_, sizeof(jsonBuf_), s.c_str(), _TRUNCATE);
                jsonDirty_ = false;
            }

            ImGui::InputTextMultiline("##json",
                jsonBuf_, sizeof(jsonBuf_),
                ImVec2(-1.0f, -1.0f),
                ImGuiInputTextFlags_ReadOnly);

            ImGui::EndTabItem();
        }

        // ======================
        // Ops tab
        // ======================
        if (ImGui::BeginTabItem("Ops"))
        {
            ImGui::Text("Add Node");
            ImGui::SetNextItemWidth(90.0f);  ImGui::InputInt("New X", &newX_);
            ImGui::SameLine();
            ImGui::SetNextItemWidth(90.0f);  ImGui::InputInt("New Y", &newY_);
            ImGui::SameLine();
            ImGui::SetNextItemWidth(120.0f); ImGui::InputInt("New StageId", &newStageId_);
            ImGui::SameLine();
            ImGui::Checkbox("New Unlocked", &newUnlocked_);

            if (ImGui::Button("Add"))
            {
                uint32_t newId = stageSelectGraph->AddNode(
                    { (uint32_t)(std::max)(newX_, 0), (uint32_t)(std::max)(newY_, 0) },
                    (uint32_t)(std::max)(newStageId_, 0),
                    newUnlocked_
                );
                editNodeId_ = newId;
                prevEditNodeId_ = UINT32_MAX; // æ¬¡ãƒ•ãƒ¬ãƒ¼ãƒ ã§ãƒ­ãƒ¼ãƒ‰
                jsonDirty_ = true;
            }

            ImGui::Separator();
            ImGui::TextDisabled("Tips: Edit values here, then press Apply in each tab.");

            ImGui::EndTabItem();
        }

        ImGui::EndTabBar();
    }

    ImGui::End();
#endif
}


============================================================
File Path: Game/Scene/StageSelectScene.h
============================================================
#pragma once
#include "InsideScene/BaseScene.h"
#include <MyMath.h>
#include "SceneSelectGraph/StageSelectGraph.h"
struct StageStatus {

};
class Object3D;
class Camera;
class StageSelectScene :
    public BaseScene
{

    public:
    StageSelectScene();
    ~StageSelectScene();

    /// <summary>
    /// åˆæœŸåŒ–å‡¦ç†
    /// </summary>
    void Initialize(DirectXCommon* dxCommon)override;

    /// <summary>
    /// æ›´æ–°å‡¦ç†
    /// </summary>
    void Update()override;

    /// <summary>
    /// æç”»å‡¦ç†
    /// </summary>
    void Draw()override;

    /// <summary>
    /// çµ‚äº†å‡¦ç†
    /// </summary>
    void Finalize()override;

	/// <summary>
    /// Imguiä¸€æ‹¬ç®¡ç†
	/// </summary>
	void DrawImgui();

	/// <summary>
	/// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ç§»å‹•å‡¦ç†
	/// </summary>
    void PlayerMove();

private:
    void HandleSelectInput();

	void ApplyNodeToCursorTransform();
    
	void DrawSelectGraphImGui();

private:
	// ã‚«ãƒ¡ãƒ©
	Camera* camera = nullptr;
	Transform cameraTransform;

	// ã‚¹ãƒ†ãƒ¼ã‚¸é¸æŠã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3D> playerModel;
	Transform playerTransform;

    // ã‚»ãƒ¬ã‚¯ãƒˆç”»é¢ï¼‘ã®åœŸå°
	std::unique_ptr<Object3D> stageSelectBase1;
	Transform stageSelectBase1Transform;

    // ç©ºèƒŒæ™¯
	std::unique_ptr<Object3D> skyBack;
	Transform skyBackTransform;


	// ã‚¹ãƒ†ãƒ¼ã‚¸ã‚»ãƒ¬ã‚¯ãƒˆã‚°ãƒ©ãƒ•
	std::unique_ptr<StageSelectGraph> stageSelectGraph;
    uint32_t currentNodeId = 0;
	uint32_t startNodeId = 0;


private:
	uint32_t editNodeId_ = 0;

	// è¿½åŠ ç”¨å…¥åŠ›
	int newX_ = 0;
	int newY_ = 0;
	int newStageId_ = 0;
	bool newUnlocked_ = true;

	// æ¥ç¶šç·¨é›†ç”¨ï¼ˆãƒ—ãƒ«ãƒ€ã‚¦ãƒ³ï¼‰
	int neighborUp_ = -1;
	int neighborDown_ = -1;
	int neighborLeft_ = -1;
	int neighborRight_ = -1;
	

#ifdef USE_IMGUI
	// é¸æŠä¸­ãƒãƒ¼ãƒ‰ãŒå¤‰ã‚ã£ãŸã‹åˆ¤å®šç”¨
	uint32_t prevEditNodeId_ = UINT32_MAX;


	// ç·¨é›†ãƒãƒƒãƒ•ã‚¡ï¼ˆæ¯ãƒ•ãƒ¬ãƒ¼ãƒ ä¸Šæ›¸ãã•ã‚Œãªã„ã‚ˆã†ã«ä¿æŒï¼‰
	int editX_ = 0;
	int editY_ = 0;
	int editStageId_ = 0;
	bool editUnlocked_ = false;

	int editNeighUp_ = -1;
	int editNeighDown_ = -1;
	int editNeighLeft_ = -1;
	int editNeighRight_ = -1;

	// ãƒ•ã‚£ãƒ«ã‚¿
	int filterStageId_ = -1;     // -1ã§ç„¡åŠ¹
	bool filterUnlockedOnly_ = false;

	// JSON
	bool jsonDirty_ = true;
	char jsonBuf_[32768] = {};

	
#endif
};



============================================================
File Path: Game/Scene/TitleScene.cpp
============================================================
#include <thread>
#include "TitleScene.h"
#include "Input.h"
#include "Object3D.h"
#include "engine/3d/ModelManager.h"
#include "Game/Camera/camera.h"
#include "Game/Particle/ParticleManager.h"
#include "Game/Particle/ParticleEmitter.h"
#include "InsideScene/Framework.h"
TitleScene::TitleScene()
{

}

TitleScene::~TitleScene()
{
}

void TitleScene::Initialize(DirectXCommon* dxCommon)
{
	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®åˆæœŸåŒ–
	SpriteCommon::GetInstance()->Initialize(dxCommon);


	// ãƒãƒ«ãƒã‚¹ãƒ¬ãƒƒãƒ‰ã§ã®èª­ã¿è¾¼ã¿
	LoadAudio();
	LoadSprite();

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚°ãƒ«ãƒ¼ãƒ—ã‚’ä½œæˆ
	ParticleManager::GetInstance()->CreateParticleGroup("Particle", "resources/monsterball.png");
	particleEmitter = make_unique<ParticleEmitter>();
	particleEmitter->SetParticleName("Particle");

	ParticleManager::GetInstance()->CreateParticleGroup("neo", "resources/back1.png");
	particleEmitter2 = make_unique<ParticleEmitter>();
	particleEmitter2->SetTransform({ { 0.0f,0.0f,0.0f },{ 0.0f,0.0f,0.0f },{ 5.0f,0.0f,20.0f } });
	particleEmitter2->SetParticleName("neo");

	object3D = make_unique<Object3D>();
	object3D->Initialize();

	object3D->SetModel("plane.obj");
	object3D->SetTranslate(Vector3(-4.0f, 0.0f, 10.0f));

	object3D->SetScale(Vector3(0.2f, 0.2f, 0.2f));
	speed = object3D->GetTranslate();



	playerObject = std::make_unique<Object3D>();
	playerObject->Initialize();
	playerObject->SetModel("Player.obj");
	playerTransform = {
		{ 1.0f,1.0f,1.0f },
		{ 0.0f,0.0f,0.0f },
		{ 1.0f,-7.0f,20.0f }
	};
	playerObject->SetTransform(playerTransform);


	titleLogo = std::make_unique<Object3D>();
	titleLogo->Initialize();
	titleLogo->SetModel("title.obj");
	titleLogoTransform = {
		{ 1.0f,1.0f,1.0f },
		{ 1.6f,3.2f,0.0f },
		{ 7.4f,-3.1f,10.1f }
	};

	titleLogo->SetTransform(titleLogoTransform);




	//sceneTransition = std::make_unique<SceneTransition>();
	//sceneTransition->Initialize();

	background = std::make_unique<BackGround>();
	background->Initialize();

	// ã‚«ãƒ¡ãƒ©ã®å–å¾—ã¨è¨­å®š
	camera = Framework::GetMainCamera();
	camera->SetTranslate({7.5f,-4.0f,0.0f});
	camera->SetRotate({ 0.0f, 0.0f, 0.0f });

}

void TitleScene::Update()
{
	//sprite_->Update();
	camera->Update();

	background->Update();

	object3D->Update();
	titleLogo->Update();

	//sceneTransition->Update();

#ifdef USE_IMGUI
	DrawImgui();
#endif


	if (isStart) {
		// object3dã‚’ã²ã ã‚Šã‹ã‚‰å³ã«
		speed.x += 0.07f;
		object3D->SetTranslate(speed);

	}
	// ã‚¨ãƒŸãƒƒã‚¿ã®ä½ç½®ã‚’æ›´æ–°ï¼ˆãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«è¿½å¾“ã•ã›ã‚‹ãªã©ï¼‰
	Transform transform;
	transform.translate = { 1.0f, -5.0f, 15.0f };
	particleEmitter->SetTransform(transform);
	//particleEmitter->Update();
	//particleEmitter2->Update();



	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’å›è»¢
	playerTransform.rotate.z -= 0.05f; // å›è»¢é€Ÿåº¦ã¯èª¿æ•´å¯èƒ½
	playerObject->SetTransform(playerTransform);
	playerObject->Update();



	// ENTERã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸã‚‰
	if (Input::GetInstance()->TriggerKey(DIK_RETURN))
	{
		SceneManager::GetInstance()->ChangeScene("GAMEPLAY");
	}
	else if (Input::GetInstance()->TriggerKey(DIK_SPACE))
	{
		SceneManager::GetInstance()->ChangeScene("STAGESELECT");
	}
}

void TitleScene::Draw()
{

#pragma region 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™

	//sprite_->Draw();
#pragma endregion

#pragma region 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»

	background->Draw();

	//object3D->Draw();
	//levelData->Draw();
	playerObject->Draw();
	//Rainbow->Draw();

	

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æç”»
	ParticleManager::GetInstance()->Draw();
	//particleEmitter->Emit();
	//particleEmitter2->Emit();
	// ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®æç”»


	//EffectManager::GetInstance()->DrawRing();
	//EffectManager::GetInstance()->DrawCylinder();
	titleLogo->Draw();


	//sceneTransition->Draw();


#pragma endregion

}

void TitleScene::Finalize()
{


	// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®çµ‚äº†å‡¦ç†
	//Audio::GetInstance()->SoundUnload(&soundData);
	/*ParticleManager::GetInstance()->DeleteParticleGroup("Particle");
	EffectManager::GetInstance()->DeleteEffectGroup("Cylinder");
	EffectManager::GetInstance()->DeleteEffectGroup("Ring");*/

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã®çµ‚äº†å‡¦ç†
	SpriteCommon::GetInstance()->Deletenstance();
}

void TitleScene::LoadAudio()
{
	// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªã®åˆæœŸåŒ–
	//Audio::GetInstance()->Initialize();
	//soundData = Audio::GetInstance()->LoadWave("resources/fanfare.wav");
	//xaudio2_ = Audio::GetInstance()->GetXAudio2();
	//Audio::GetInstance()->SoundPlayWave(xaudio2_, soundData);

}

void TitleScene::LoadSprite() 
{
	sprite_ = make_unique<Sprite>();
	sprite_->Initialize("resources/gradationLine.png");
	sprite_->SetPosition({ 0.0f,0.0f });
	sprite_->SetRotation(0.0f);
}

void TitleScene::DrawImgui() {
#ifdef USE_IMGUI

	ImGui::Begin("playerObject");

	Transform pTransform = playerObject->GetTransform();
	ImGui::DragFloat3("Scale", &pTransform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotate", &pTransform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translate", &pTransform.translate.x, 0.1f);

	playerObject->SetTransform(pTransform);

	ImGui::End();

	/*ImGui::Begin("BackGround");

	ImGui::Text("Soil");
	ImGui::DragFloat3("Scales", &soilTransform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotates", &soilTransform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translates", &soilTransform.translate.x, 0.1f);
	soil->SetTransform(soilTransform);
	ImGui::Separator();

	ImGui::Text("Player");
	ImGui::DragFloat3("Scalep", &playerTransform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotatep", &playerTransform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translatep", &playerTransform.translate.x, 0.1f);
	playerObject->SetTransform(playerTransform);
	ImGui::Separator();
	// èƒŒæ™¯
	ImGui::Text("BackGround3");
	ImGui::DragFloat3("Scaleb", &titleBackGround3Transform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotateb", &titleBackGround3Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translateb", &titleBackGround3Transform.translate.x, 0.1f);
	titleBackGround3->SetTransform(titleBackGround3Transform);

	ImGui::Separator();

	ImGui::Text("BackGround3_2");
	ImGui::DragFloat3("Scalec3_2", &titleBackGround3_2Transform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotatec3_2", &titleBackGround3_2Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translatec3_2", &titleBackGround3_2Transform.translate.x, 0.1f);
	titleBackGround3_2->SetTransform(titleBackGround3_2Transform);
	ImGui::Separator();

	ImGui::Text("BackGround2");
	ImGui::DragFloat3("Scalec", &titleBackGround2Transform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotatec", &titleBackGround2Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translatec", &titleBackGround2Transform.translate.x, 0.1f);
	titleBackGround2->SetTransform(titleBackGround2Transform);

	ImGui::Separator();

	ImGui::Text("BackGround2_2");
	ImGui::DragFloat3("Scaled2_2", &titleBackGround2_2Transform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotated2_2", &titleBackGround2_2Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translated2_2", &titleBackGround2_2Transform.translate.x, 0.1f);
	titleBackGround2_2->SetTransform(titleBackGround2_2Transform);
	ImGui::Separator();
	ImGui::Text("BackGround2_3");
	ImGui::DragFloat3("Scaled2_3", &titleBackGround2_3Transform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotated2_3", &titleBackGround2_3Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translated2_3", &titleBackGround2_3Transform.translate.x, 0.1f);
	titleBackGround2_3->SetTransform(titleBackGround2_3Transform);
	ImGui::Separator();

	ImGui::Text("BackGround1");
	ImGui::DragFloat3("Scaled", &titleBackGround1Transform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotated", &titleBackGround1Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translated", &titleBackGround1Transform.translate.x, 0.1f);
	titleBackGround1->SetTransform(titleBackGround1Transform);

	ImGui::Separator();

	ImGui::Text("BackGround1_2");
	ImGui::DragFloat3("Scale1_2", &titeleBackGround1_2Transform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotate1_2", &titeleBackGround1_2Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translate1_2", &titeleBackGround1_2Transform.translate.x, 0.1f);
	titeleBackGround1_2->SetTransform(titeleBackGround1_2Transform);
	ImGui::Separator();
	ImGui::Text("BackGround1_3");
	ImGui::DragFloat3("Scale1_3", &titeleBackGround1_3Transform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotate1_3", &titeleBackGround1_3Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translate1_3", &titeleBackGround1_3Transform.translate.x, 0.1f);
	titeleBackGround1_3->SetTransform(titeleBackGround1_3Transform);
	ImGui::Separator();
	ImGui::Text("BackGround1_4");
	ImGui::DragFloat3("Scale1_4", &titeleBackGround1_4Transform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotate1_4", &titeleBackGround1_4Transform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translate1_4", &titeleBackGround1_4Transform.translate.x, 0.1f);
	titeleBackGround1_4->SetTransform(titeleBackGround1_4Transform);
	ImGui::Separator();
	ImGui::Text("SkyBack");
	ImGui::DragFloat3("Scalee", &skyBackTransform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotatee", &skyBackTransform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translatee", &skyBackTransform.translate.x, 0.1f);
	skyBack->SetTransform(skyBackTransform);


	ImGui::End();*/


	//if (levelData->HasPlayerSpawn()) {
	//	const auto& playerSpawn = levelData->getPlayerSpawns()[0];

	//	// ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ä½ç½®ã¨å›è»¢ã‚’ Object3D ã«ã‚»ãƒƒãƒˆ
	//	playerObject->SetTranslate(playerSpawn.transform.translate);
	//	playerObject->SetRotate(playerSpawn.transform.rotate);

	//	// ImGui ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã§è¡¨ç¤º
	//	ImGui::Begin("PlayerSpawn Info");

	//	const Vector3& pos = playerSpawn.transform.translate;
	//	const Vector3& rot = playerSpawn.transform.rotate;

	//	ImGui::Text("Translate: X = %.2f, Y = %.2f, Z = %.2f", pos.x, pos.y, pos.z);
	//	ImGui::Text("Rotate:    X = %.2f, Y = %.2f, Z = %.2f", rot.x, rot.y, rot.z);

	//	ImGui::End();
	//}




	//ImGui::Begin("Particle");

	//ImGui::Text("Transform");
	//ImGui::DragFloat3("Scalea", &emitterScale.x, 0.1f);
	//ImGui::DragFloat3("Rotatea", &emitterRotate.x, 0.1f);
	//ImGui::DragFloat3("Translatea", &emitterTranslate.x, 1.0f); // ã“ã“ã§test.xã‚’æ“ä½œå¯èƒ½ã«

	//ImGui::End();

	/*ImGui::Begin("effect");

	ImGui::Text("Transform");
	ImGui::DragFloat3("Scale", &effectTransform.scale.x, 0.1f);
	ImGui::DragFloat3("Rotate", &effectTransform.rotate.x, 0.1f);
	ImGui::DragFloat3("Translate", &effectTransform.translate.x, 1.0f);
	effectEmitter->SetTransform(effectTransform);

	ImGui::Text("asdf");
	ImGui::DragFloat3("CylinderScale", &cylinderTransform.scale.x, 0.1f);
	ImGui::DragFloat3("CylinderRotate", &cylinderTransform.rotate.x, 0.1f);
	ImGui::DragFloat3("CylinderTranslate", &cylinderTransform.translate.x, 1.0f);
	cylinder->SetTransform(cylinderTransform);
	ImGui::End();*/


#endif // _DEBUG

}



============================================================
File Path: Game/Scene/TitleScene.h
============================================================
#pragma once
#include "Audio.h"
#include "SpriteCommon.h"
#include "InsideScene/BaseScene.h"
#include "Sprite.h"
#include "InsideScene/SceneManager.h"
#include "Game/Particle/ParticleManager.h"
#include "Game/Particle/ParticleEmitter.h"
#include "Game/Particle/EffectManager.h"
#include "Game/Particle/EffectEmitter.h"
#include "Game/Loader/LevelLoader.h"
#include "SceneTransition/SceneTransition.h"
#include "Game/Application/BackGround.h"


#ifdef USE_IMGUI
#include "ImGuiManager.h"
#endif

/// <summary>
/// ã‚¿ã‚¤ãƒˆãƒ«ã‚·ãƒ¼ãƒ³
/// </summary>
class Camera;
class Object3D;
class TitleScene :public BaseScene
{
public:
	TitleScene();
	~TitleScene();
	// åˆæœŸåŒ–
	void Initialize(DirectXCommon* dxCommon)override;
	// æ›´æ–°
	void Update()override;
	// æç”»
	void Draw()override;
	// çµ‚äº†å‡¦ç†
	void Finalize()override;
	// ã‚¹ãƒ¬ãƒƒãƒ‰ç”¨ã®é–¢æ•°
	void LoadAudio();
	void LoadSprite();

	// Imguiä¸€æ‹¬ç®¡ç† / æç”»é–¢æ•°
	void DrawImgui();
private:

	// ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª
	// ã‚µã‚¦ãƒ³ãƒ‰ãƒ‡ãƒ¼ã‚¿
	//SoundData soundData;
	//IXAudio2* xaudio2_;

	// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆ
	std::unique_ptr<Sprite> sprite_;

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒŸãƒƒã‚¿ãƒ¼
	std::unique_ptr<ParticleEmitter> particleEmitter;
	std::unique_ptr<ParticleEmitter> particleEmitter2;

	// ãƒªãƒ³ã‚°ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
	std::unique_ptr<Object3D> object3D;
	// èƒŒæ™¯
	std::unique_ptr<Object3D> backgroundObject;


	// effect
	std::unique_ptr<EffectEmitter>effectEmitter;
	std::unique_ptr<EffectEmitter>cylinder;

private: // ã‚²ãƒ¼ãƒ è¦ç´ 
	Vector3 emitterScale = { 0.0f, 0.0f, 0.0f };
	Vector3 emitterRotate = { 0.0f, 0.0f, 0.0f };
	Vector3 emitterTranslate = { 0.0f, 0.0f, 10.0f };

	Transform effectTransform;

	Transform cylinderTransform;

	Vector3 speed = { 0.0f,0.0f,0.0f };


	bool isStart = false;



	/// levelloader
	std::unique_ptr<LevelLoader>levelData;

	std::unique_ptr<Object3D> playerObject;
	Transform playerTransform;

	std::unique_ptr<Object3D> Rainbow;
	Transform rainbowTransform;

	/// ã‚¿ã‚¤ãƒˆãƒ«ãƒ­ã‚´
	std::unique_ptr<Object3D> titleLogo;
	Transform titleLogoTransform;

	// ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰
	 std::unique_ptr<BackGround> background;

	 std::unique_ptr<Sprite> quxSprite_;

	 /// ã‚«ãƒ¡ãƒ©
	 Camera* camera = nullptr;

	//std::unique_ptr<SceneTransition> sceneTransition;

};



============================================================
File Path: InsideScene/AbstractSceneFactory.cpp
============================================================
#include "AbstractSceneFactory.h"


============================================================
File Path: InsideScene/AbstractSceneFactory.h
============================================================
#pragma once
#include "BaseScene.h"
#include <string>
// ã‚·ãƒ¼ãƒ³å·¥å ´ã‚¯ãƒ©ã‚¹
class AbstractSceneFactory
{
public:
	/// <summary>
	/// ä»®æƒ³ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	virtual ~AbstractSceneFactory() = default;
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	/// </summary>
	/// <param name="sceneName"></param>
	/// <returns></returns>
	virtual BaseScene* CreateScene(const std::string&sceneName) = 0;
};



============================================================
File Path: InsideScene/BaseScene.cpp
============================================================
#include "BaseScene.h"


============================================================
File Path: InsideScene/BaseScene.h
============================================================
#pragma once
#include "DirectXCommon.h"

/// <summary>
/// ã‚·ãƒ¼ãƒ³åŸºåº•ã‚¯ãƒ©ã‚¹
/// </summary>
class SceneManager;
class BaseScene
{
public:
    /// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
    /// </summary>
    virtual ~BaseScene() = default;
    /// <summary>
	/// åˆæœŸåŒ–
    /// </summary>
    /// <param name="dxCommon"></param>
    virtual void Initialize(DirectXCommon* dxCommon) = 0;
    /// <summary>
	/// æ›´æ–°
    /// </summary>
    virtual void Update() = 0;
    /// <summary>
	/// æç”»
    /// </summary>
    virtual void Draw() = 0;
    /// <summary>
	/// çµ‚äº†å‡¦ç†
    /// </summary>
    virtual void Finalize() = 0;
    // Setter
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ã‚»ãƒƒãƒˆ
	/// </summary>
    virtual void SetSceneManager(SceneManager* sceneManager) { this->sceneManager = sceneManager; }

protected:
	// ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
    SceneManager* sceneManager = nullptr;
};



============================================================
File Path: InsideScene/Framework.cpp
============================================================
#include "Framework.h"
void Framework::Initialize()
{
	//WindowsAPIã®åˆæœŸåŒ–
	winAPI = make_unique<WinAPI>();
	winAPI->Initialize();
	// dxCommonã®åˆæœŸåŒ–
	dxCommon = make_unique<DirectXCommon>();
	dxCommon->Initialize(winAPI.get());

	// å…¥åŠ›å‡¦ç†ã®ã‚¯ãƒ©ã‚¹ãƒã‚¤ãƒ³ã‚¿
	
	Input::GetInstance()->Initialize(winAPI.get());

	// SRVãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
	srvManager = make_unique<SrvManager>();
	srvManager->Initialize(dxCommon.get());
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®åˆæœŸåŒ–
	TextureManager::GetInstance()->Initialize(dxCommon.get(), srvManager.get());


#ifdef USE_IMGUI
	// ImGuiã®åˆæœŸåŒ–
	imGui = make_unique<ImGuiManager>();
	imGui->Initialize(winAPI.get(), dxCommon.get());
#endif

	// 3Dãƒ¢ãƒ‡ãƒ«ãƒãƒãƒ¼ã‚¸ãƒ£ã®åˆæœŸåŒ–
	ModelManager::GetInstance()->Initialize(dxCommon.get());
	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…±é€šéƒ¨ã®åˆæœŸåŒ–
	Object3DCommon::GetInstance()->Initialize(dxCommon.get());

	// ãƒ¢ãƒ‡ãƒ«å…±é€šéƒ¨ã®åˆæœŸåŒ–
	modelCommon = make_unique<ModelCommon>();
	modelCommon->Initialize(dxCommon.get());

	// ã‚«ãƒ¡ãƒ©
	camera = make_unique<Camera>();
	camera->SetRotate({ 0.0f, 0.0f, 0.0f });
	camera->SetTranslate({ 0.0f, 0.0f, -5.0f });

	// å…¨ã‚·ãƒ¼ãƒ³ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã‚«ãƒ¡ãƒ©ã«è¨­å®š
	mainCamera_ = camera.get();

	Object3DCommon::GetInstance()->SetDefaultCamera(camera.get());

	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
	ParticleManager::GetInstance()->Initialize(dxCommon.get(), srvManager.get(), camera.get());
	
	

	/// ãƒãƒƒãƒ—ã«åˆã‚ã›ã‚‹
	/*cameraTransform.translate = { 7.5f,-4.0f,0.0f };
	camera->SetTranslate(cameraTransform.translate);*/

}

void Framework::Update()
{
#pragma region WindowsAPIã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
	//Windowã®ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
	if (winAPI->ProcessMessage()) {
		//ã‚²ãƒ¼ãƒ ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
		isEndRequest_ = true;
		return;
	}
#pragma endregion

	Input::GetInstance()->Update();
	// ã‚«ãƒ¡ãƒ©ã®æ›´æ–°
	camera->Update();
#ifdef USE_IMGUI
	// ã‚«ãƒ¡ãƒ©ã®é…ç½®å›è»¢æƒ…å ±ã®å¤‰æ›´ãƒ»è¡¨ç¤ºUI
	ImGui::Begin("Camera Settings");
	ImGui::DragFloat3("Translate", &cameraTransform.translate.x, 0.1f);
	ImGui::DragFloat3("Rotate", &cameraTransform.rotate.x, 0.1f);
	ImGui::End();

	// ã‚«ãƒ¡ãƒ©ã«åæ˜ ã•ã›ã‚‹
	/*static bool useDebugCamera = false;
	ImGui::Checkbox("Use Debug Camera", &useDebugCamera);
	if (useDebugCamera) {*/
	/*camera->SetTranslate(cameraTransform.translate);
	camera->SetRotate(cameraTransform.rotate);*/
	//}
#endif 

	SceneManager::GetInstance()->Update(dxCommon.get());
	

	
	// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®æ›´æ–°
	ParticleManager::GetInstance()->Update();

	// ESCã‚­ãƒ¼ã§çµ‚äº†
	if (Input::GetInstance()->TriggerKey(DIK_ESCAPE))
	{
		isEndRequest_ = true;
	}
	
}


void Framework::Draw()
{
	


}


void Framework::Finalize()
{
	

	SceneManager::GetInstance()->Finalize();
	SceneManager::Deletenstance();
	Audio::GetInstance()->DeleteInstance();
	Object3DCommon::GetInstance()->DeleteInstance();
	SpriteCommon::GetInstance()->Deletenstance();
	TextureManager::GetInstance()->DeleteInstance();
	ModelManager::GetInstance()->Finalize();
	Input::GetInstance()->DeleteInstance();
	winAPI->Finalize();
	mainCamera_ = nullptr;
	ParticleManager::GetInstance()->DeleteInstance();

}

void Framework::Run()
{
	// ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–
	Initialize();
	// ã‚²ãƒ¼ãƒ ã®ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
	while (true) {
		// ã‚²ãƒ¼ãƒ ã®æ›´æ–°
		Update();
		if (IsEndRequest()) {
			break;
		}
		// ã‚²ãƒ¼ãƒ ã®æç”»
		Draw();
	}
	// ã‚²ãƒ¼ãƒ ã®çµ‚äº†å‡¦ç†
	Finalize();
}



============================================================
File Path: InsideScene/Framework.h
============================================================
#pragma once
#include<fstream>
#include<sstream>
#include<wrl.h>
#include "numbers"
#include "WinAPI.h"
#include "DirectXCommon.h"
#include "Sprite.h"
#include "SpriteCommon.h"
#include "TextureManager.h"
#include "Object3D.h"
#include "Object3DCommon.h"
#include "ModelManager.h"
#ifdef USE_IMGUI
#include "ImGuiManager.h"
#endif
#include "Audio.h"
#include "SceneManager.h"
#include "Game/Particle/ParticleManager.h"
#include "Game/Particle/EffectManager.h"
#include "engine/3d/SkyBox/SkyBox.h"
#include "AbstractSceneFactory.h"
#include "D3DResourceLeakChecker.h"
#include "Input.h"
#include "engine/2d/RenderTexture.h"
/// <summary>
/// ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯åŸºåº•ã‚¯ãƒ©ã‚¹
/// </summary>
class Framework
{

public:
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	virtual ~Framework() = default;
public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	virtual void Initialize();
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	virtual void Update();
	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	virtual void Draw() = 0;
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	virtual void Finalize();
	/// <summary>
	/// å®Ÿè¡Œ
	/// </summary>
	void Run();
	/// <summary>
	/// çµ‚äº†ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æœ‰ç„¡
	/// </summary>
	/// <returns></returns>
	bool IsEndRequest() { return isEndRequest_; }

protected:
	// çµ‚äº†ãƒªã‚¯ã‚¨ã‚¹ãƒˆ
	bool isEndRequest_ = false;
protected:// Initializeé–¢é€£
	// ãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚«ãƒ¼
	//D3DResourceLeakChecker leakCheck;
	// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦API
	std::unique_ptr<WinAPI> winAPI;
	// DirectXå…±é€šéƒ¨
	std::unique_ptr<DirectXCommon> dxCommon;
	// ImGui
#ifdef USE_IMGUI
	std::unique_ptr<ImGuiManager> imGui;
#endif
	// SRVãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
	std::unique_ptr<SrvManager> srvManager;
	// ãƒ¢ãƒ‡ãƒ«å…±é€šéƒ¨
	std::unique_ptr<ModelCommon> modelCommon;
	// ã‚«ãƒ¡ãƒ©
	std::unique_ptr<Camera> camera;


	// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£
	std::unique_ptr<RenderTexture> renderTexture = nullptr;

public:
	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
	std::unique_ptr<AbstractSceneFactory> sceneFactory_ = nullptr;
	// å…¨ã‚·ãƒ¼ãƒ³ãŒã‚¢ã‚¯ã‚»ã‚¹å¯èƒ½ãªã‚«ãƒ¡ãƒ©
	static Camera* GetMainCamera() { return mainCamera_; }
private:
	
	/// ã‚«ãƒ¡ãƒ©ã®åº§æ¨™
	Transform cameraTransform = {
		{0.0f, 0.0f, -10.0f}, // translate
		{0.0f, 0.0f, 0.0f}, // rotate
		{ 1.0f, 1.0f,-10.0f } // scale
	};

	static inline Camera* mainCamera_ = nullptr;
	
};



============================================================
File Path: InsideScene/SceneFactory.cpp
============================================================
#include "SceneFactory.h"
#include "Game/Scene/TitleScene.h"
#include "Game/Scene/GamePlayScene.h"
#include "Game/Scene/StageSelectScene.h"
#include "Game/Scene/StageClearScene.h"
BaseScene* SceneFactory::CreateScene(const std::string& sceneName)
{
    // æ¬¡ã®ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	BaseScene* scene = nullptr;
	if (sceneName == "TITLE")
	{
		scene = new TitleScene();
	}
	else if (sceneName == "STAGESELECT")
	{
		scene = new StageSelectScene();
	}
	else if (sceneName == "GAMEPLAY")
	{
		scene = new GamePlayScene();
	}
	else if (sceneName == "STAGECLEAR")
	{
		scene = new StageClearScene();
	}
	return scene;
}


============================================================
File Path: InsideScene/SceneFactory.h
============================================================
#pragma once
#include "AbstractSceneFactory.h"
/// <summary>
/// ã‚·ãƒ¼ãƒ³å·¥å ´ã‚¯ãƒ©ã‚¹
/// </summary>
class SceneFactory : public AbstractSceneFactory
{
public:
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	/// </summary>
	/// <param name="sceneName"></param>
	/// <returns></returns>
	BaseScene* CreateScene(const std::string& sceneName)override;
};



============================================================
File Path: InsideScene/SceneManager.cpp
============================================================
#include "SceneManager.h"

static SceneManager* instance = nullptr;


SceneManager* SceneManager::GetInstance()
{
	if (instance == nullptr)
	{
		instance = new SceneManager();
	}
	return instance;
}

void SceneManager::Deletenstance()
{
	if (instance != nullptr)
	{
		delete instance;
		instance = nullptr;
	}
}

void SceneManager::Update(DirectXCommon* dxCommon)
{
    // æ¬¡ã®ã‚·ãƒ¼ãƒ³ãŒäºˆç´„ã•ã‚Œã¦ã„ã‚‹å ´åˆ
    if (nextScene_) {
        // ä»Šã®ã‚·ãƒ¼ãƒ³ã®çµ‚äº†å‡¦ç†
        if (scene_) {
            scene_->Finalize();
            delete scene_;
        }
        // æ¬¡ã®ã‚·ãƒ¼ãƒ³ã®åˆæœŸåŒ–
        scene_ = nextScene_;
        nextScene_ = nullptr;
        // ã‚·ãƒ¼ãƒ³ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®è¨­å®š
        scene_->SetSceneManager(this);
        scene_->Initialize(dxCommon);
    }
    // å®Ÿè¡Œä¸­ã‚·ãƒ¼ãƒ³ã‚’æ›´æ–°
    if (scene_) {
        scene_->Update();
    }
}


void SceneManager::Draw()
{
    // å®Ÿè¡Œä¸­ã‚·ãƒ¼ãƒ³ãŒå­˜åœ¨ã™ã‚‹å ´åˆã®ã¿æç”»
    if (scene_) {
        scene_->Draw();
    }
}

void SceneManager::Finalize()
{
    // æœ€å¾Œã®ã‚·ãƒ¼ãƒ³ã®çµ‚äº†å‡¦ç†
    // ä½¿ãˆã‚‹ã‚ˆã†ãªã‚‰
    if (scene_)
    {
        scene_->Finalize();
        delete scene_;
    }
}

void SceneManager::ChangeScene(const std::string& sceneName)
{
    assert(nextScene_ == nullptr);
    assert(sceneFactory_);

	// æ¬¡ã®ã‚·ãƒ¼ãƒ³ç”Ÿæˆ
	nextScene_ = sceneFactory_->CreateScene(sceneName);
}






============================================================
File Path: InsideScene/SceneManager.h
============================================================
#pragma once
#include "BaseScene.h"
#include "AbstractSceneFactory.h"
// ã‚·ãƒ¼ãƒ³ç®¡ç†ã‚¯ãƒ©ã‚¹
// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹
class SceneManager
{
public:
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	static SceneManager* GetInstance();
	static void Deletenstance();
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	SceneManager() = default;
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~SceneManager() = default;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã®ç„¡åŠ¹åŒ–
	/// </summary>
	/// <param name=""></param>
	SceneManager(SceneManager&) = delete;
	/// <summary>
	/// ä»£å…¥æ¼”ç®—å­ã®ç„¡åŠ¹åŒ–
	/// </summary>
	/// <param name=""></param>
	/// <returns></returns>
	SceneManager& operator=(SceneManager&) = delete;

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon"></param>
	void Update(DirectXCommon*dxCommon);
	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();

public:
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ã‚»ãƒƒãƒˆ
	/// </summary>
	/// <param name="sceneFactory"></param>
	void SetSceneFactory(AbstractSceneFactory* sceneFactory) { sceneFactory_ = sceneFactory; }
	/// <summary>
	/// ã‚·ãƒ¼ãƒ³å¤‰æ›´
	/// </summary>
	/// <param name="sceneName"></param>
	void ChangeScene(const std::string& sceneName);

private:
	// ä»Šã®ã‚·ãƒ¼ãƒ³
	BaseScene* scene_ = nullptr;
	// æ¬¡ã®ã‚·ãƒ¼ãƒ³
	BaseScene* nextScene_ = nullptr;

	// ã‚·ãƒ¼ãƒ³ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ // å€Ÿã‚Šç‰©
	AbstractSceneFactory* sceneFactory_ = nullptr;
	
};



============================================================
File Path: engine/2d/RenderTexture.cpp
============================================================
#include "RenderTexture.h"
#include "engine/base/DirectXCommon.h"
#include "engine/base/SrvManager.h"
#include <map>
RenderTexture::RenderTexture()
{
}
RenderTexture::~RenderTexture()
{
}
void RenderTexture::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, uint32_t width, uint32_t height, 
	DXGI_FORMAT format, const Vector4& clearColor)
{
	/// å¼•ãæ•°ã‚’æ¸¡ã™
	this->dxCommon_ = dxCommon;
	this->srvManager_ = srvManager;
	this->clearColor_ = clearColor;


	const Vector4 kRenderTargetClearValue = clearColor;
	textureResource = CreateRenderTextureResource(
		dxCommon_->GetDevice(),width, height,
		DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, kRenderTargetClearValue
	);

	rtvHeap = dxCommon_->CreateDescriptorHeap(
		D3D12_DESCRIPTOR_HEAP_TYPE_RTV, 1, false);
	rtvHandle = dxCommon_->GetCPUDescriptorHandle(rtvHeap, dxCommon_->GetDescriptorSizeRTV(), 0);


	dxCommon_->GetDevice()->CreateRenderTargetView(textureResource.Get(), nullptr, rtvHandle);


	srvIndex = srvManager_->Allocate();
	srvManager_->CreateSRVforTexture2D(srvIndex, textureResource.Get(), format, 1);

	currentState = D3D12_RESOURCE_STATE_RENDER_TARGET;

	CreateGraphicsPipeLine();
	CreateVertexBuffer();
	
}

Microsoft::WRL::ComPtr<ID3D12Resource> RenderTexture::CreateRenderTextureResource(Microsoft::WRL::ComPtr<ID3D12Device> device, uint32_t width, uint32_t height, DXGI_FORMAT format, const Vector4& clearColor)
{
	
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	resourceDesc.Width = width;
	resourceDesc.Height = height;
	resourceDesc.DepthOrArraySize = 1;
	resourceDesc.MipLevels = 1;
	resourceDesc.Format = format;
	resourceDesc.SampleDesc.Count = 1;
	resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_RENDER_TARGET;

	D3D12_HEAP_PROPERTIES heapProp{};
	heapProp.Type = D3D12_HEAP_TYPE_DEFAULT;

	D3D12_CLEAR_VALUE clear{};
	clear.Format = format;
	clear.Color[0] = clearColor.x;
	clear.Color[1] = clearColor.y;
	clear.Color[2] = clearColor.z;
	clear.Color[3] = clearColor.w;

	
	HRESULT hr = device->CreateCommittedResource(
		&heapProp,
		D3D12_HEAP_FLAG_NONE,
		&resourceDesc,
		D3D12_RESOURCE_STATE_RENDER_TARGET,
		&clear,
		IID_PPV_ARGS(&textureResource));
	assert(SUCCEEDED(hr));

	return textureResource;
}

void RenderTexture::BeginRender()
{
	if (currentState != D3D12_RESOURCE_STATE_RENDER_TARGET) {
		auto barrier = CD3DX12_RESOURCE_BARRIER::Transition(
			textureResource.Get(),
			currentState,
			D3D12_RESOURCE_STATE_RENDER_TARGET
		);
		dxCommon_->GetCommandList()->ResourceBarrier(1, &barrier);
		currentState = D3D12_RESOURCE_STATE_RENDER_TARGET;
	}

	// DSV ã®è¨­å®š
	D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle = dxCommon_->GetDSVHandle();
	dxCommon_->GetCommandList()->OMSetRenderTargets(1, &rtvHandle, false, &dsvHandle);

	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã¨ã‚·ã‚¶ãƒ¼è¨­å®š
	D3D12_VIEWPORT viewport{};
	viewport.TopLeftX = 0.0f;
	viewport.TopLeftY = 0.0f;
	viewport.Width = static_cast<float>(resourceDesc.Width);
	viewport.Height = static_cast<float>(resourceDesc.Height);
	viewport.MinDepth = 0.0f;
	viewport.MaxDepth = 1.0f;

	D3D12_RECT scissorRect{};
	scissorRect.left = 0;
	scissorRect.top = 0;
	scissorRect.right = static_cast<LONG>(resourceDesc.Width);
	scissorRect.bottom = static_cast<LONG>(resourceDesc.Height);

	dxCommon_->GetCommandList()->RSSetViewports(1, &viewport);
	dxCommon_->GetCommandList()->RSSetScissorRects(1, &scissorRect);

	// ã‚¯ãƒªã‚¢ã‚«ãƒ©ãƒ¼
	float  clearColor[4] = { clearColor_.x,clearColor_.y,clearColor_.z,clearColor_.w };
	dxCommon_->GetCommandList()->ClearRenderTargetView(
		rtvHandle,
		clearColor,
		0,
		nullptr
	);
}


void RenderTexture::EndRender()
{
	if (currentState != D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE) {
		auto barrier = CD3DX12_RESOURCE_BARRIER::Transition(
			textureResource.Get(),
			currentState,
			D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE
		);
		dxCommon_->GetCommandList()->ResourceBarrier(1, &barrier);
		currentState = D3D12_RESOURCE_STATE_PIXEL_SHADER_RESOURCE;
	}

}

D3D12_GPU_DESCRIPTOR_HANDLE RenderTexture::GetGPUHandle() const {
	return srvManager_->GetGPUDescriptorHandle(srvIndex);
}


void RenderTexture::Draw() {

	//// SRVãƒ’ãƒ¼ãƒ—ã‚’è¨­å®šï¼ˆãƒ«ãƒ¼ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«ç”¨ï¼‰
	//ID3D12DescriptorHeap* heaps[] = { srvManager_->GetSRVHeap().Get()};
	//dxCommon_->GetCommandList()->SetDescriptorHeaps(1, heaps);

	// PSO / RootSignature ã‚’ã‚»ãƒƒãƒˆ
	dxCommon_->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
	dxCommon_->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());

	// SRVã‚’ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã«ãƒã‚¤ãƒ³ãƒ‰ï¼ˆãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿0ã«SRVãƒ†ãƒ¼ãƒ–ãƒ«ï¼‰
	dxCommon_->GetCommandList()->SetGraphicsRootDescriptorTable(0, GetGPUHandle());

	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒãƒ­ã‚¸ãƒ¼ã‚’è¨­å®šï¼ˆä¸‰è§’å½¢ãƒªã‚¹ãƒˆï¼‰
	dxCommon_->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	dxCommon_->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã‚’ä½¿ã‚ãš3é ‚ç‚¹ã§å…¨ç”»é¢æç”»ï¼ˆVSã§SV_VertexIDä½¿ç”¨å‰æï¼‰
	dxCommon_->GetCommandList()->DrawInstanced(3, 1, 0, 0);
}




void RenderTexture::CreateGraphicsPipeLine() {

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	CreateRootSignature();

	// é ‚ç‚¹ã®ä½ç½®ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’è¨­å®š
	inputElementDescs[0].SemanticName = "POSITION";
	inputElementDescs[0].SemanticIndex = 0;
	inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã®åº§æ¨™
	inputElementDescs[1].SemanticName = "TEXCOORD";
	inputElementDescs[1].SemanticIndex = 0;
	inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	

	inputLayoutDescs.pInputElementDescs = nullptr;
	inputLayoutDescs.NumElements = 0;

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ›¸ãè¾¼ã¿ãƒã‚¹ã‚¯ã‚’è¨­å®šã€‚å…¨ã¦ã®è‰²ãƒãƒ£ãƒ³ãƒãƒ«ã«æ›¸ãè¾¼ã¿ã‚’è¨±å¯
	blendDesc.RenderTarget[0].RenderTargetWriteMask =
		D3D12_COLOR_WRITE_ENABLE_ALL;


	// ã‚«ãƒªãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®š
	rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
	// ãƒãƒªã‚´ãƒ³ã®ãƒ•ã‚£ãƒ«ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®šã€‚ãƒãƒªã‚´ãƒ³ã®å¡—ã‚Šæ½°ã—
	rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;

	//ã€€é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	vertexShaderBlob = dxCommon_->CompileShader(
		L"resources/shaders/Fullscreen.VS.hlsl", L"vs_6_0");
	assert(vertexShaderBlob != nullptr);
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	pixelShaderBlob = dxCommon_->CompileShader(
		L"resources/shaders/Grayscale.PS.hlsl", L"ps_6_0");
	assert(pixelShaderBlob != nullptr);


	//Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
	depthStencilDesc.DepthEnable = false;
	//æ›¸ãè¾¼ã¿ã—ã¾ã™
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
	//æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;



	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
	graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();
	// ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.InputLayout = { nullptr,0 };
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®è¨­å®š
	graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),vertexShaderBlob->GetBufferSize() };
	graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),pixelShaderBlob->GetBufferSize() };
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.BlendState = blendDesc;
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	graphicsPipelineStateDesc.RasterizerState = rasterizerDesc;
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ãƒãƒ­æ™‚ã®è¨­å®š
	graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	// DepthStencilã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_UNKNOWN;

	HRESULT hr = dxCommon_->GetDevice()->CreateGraphicsPipelineState(
		&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState));

	assert(SUCCEEDED(hr));
}

void RenderTexture::CreateRootSignature()
{
#pragma region RootParameter
	//RootSignatureä½œæˆ
	descriptionRootSignature.Flags =
		D3D12_ROOT_SIGNATURE_FLAG_NONE;
#pragma region DescriptorRange
	D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
	descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
	descriptorRange[0].NumDescriptors = 1;
	descriptorRange[0].BaseShaderRegister = 0;
	descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;
#pragma endregion

	//RootParameterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚ä»Šå›ã¯çµæœãŒï¼‘ã¤ã ã‘ãªã®ã§é•·ã•ï¼‘ã®é…åˆ—
	D3D12_ROOT_PARAMETER rootParam[1] = {};
	rootParam[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	rootParam[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParam[0].DescriptorTable.pDescriptorRanges = descriptorRange;
	rootParam[0].DescriptorTable.NumDescriptorRanges = 1;

	descriptionRootSignature.pParameters = rootParam;
	descriptionRootSignature.NumParameters = 1;
#pragma endregion



	D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
	staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;
	staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	//staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
	//staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;
	staticSamplers[0].ShaderRegister = 0;
	staticSamplers[0].RegisterSpace = 0;
	staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;

	descriptionRootSignature.pStaticSamplers = staticSamplers;
	descriptionRootSignature.NumStaticSamplers = 1;

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºçµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr <ID3DBlob> signatureBlob = nullptr;
	// ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç™ºç”Ÿã—ãŸå ´åˆã«æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr <ID3DBlob> errorBlob = nullptr;
	HRESULT hr = D3D12SerializeRootSignature(&descriptionRootSignature, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(hr)) {
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	hr = dxCommon_->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
	assert(SUCCEEDED(hr));

}

void RenderTexture::CreateVertexBuffer() {
	TextureVertex vertices[] = {
		{{-1.0f, -1.0f, 0.0f, 1.0f}, {0.0f, 1.0f}},
		{{-1.0f,  3.0f, 0.0f, 1.0f}, {0.0f, -1.0f}},
		{{ 3.0f, -1.0f, 0.0f, 1.0f}, {2.0f, 1.0f}},
	};

	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ä½œæˆï¼ˆUPLOADãƒ’ãƒ¼ãƒ—ï¼‰
	vertexBufferResource = dxCommon_->CreateBufferResource(sizeof(vertices));

	// Map ã—ã¦ã‹ã‚‰å®‰å…¨ã«ã‚³ãƒ”ãƒ¼
	void* mappedPtr = nullptr;
	HRESULT hr = vertexBufferResource->Map(0, nullptr, &mappedPtr);
	assert(SUCCEEDED(hr));
	memcpy(mappedPtr, vertices, sizeof(vertices));
	vertexBufferResource->Unmap(0, nullptr);

	// ãƒ“ãƒ¥ãƒ¼ã®è¨­å®š
	vertexBufferView.BufferLocation = vertexBufferResource->GetGPUVirtualAddress();
	vertexBufferView.SizeInBytes = sizeof(vertices);
	vertexBufferView.StrideInBytes = sizeof(TextureVertex);
}


============================================================
File Path: engine/2d/RenderTexture.h
============================================================
#pragma once
#include <d3d12.h>
#include <wrl.h>
#include "engine/math/MyMath.h"
#include "engine/base/Logger.h"
#include "engine/base/DirectXCommon.h"
#include "engine/base/SrvManager.h"

class DirectXCommon;
class SrvManager;
/// <summary>
/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¯ãƒ©ã‚¹
/// </summary>
class RenderTexture
{
public:
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	RenderTexture();

	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~RenderTexture();

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager, uint32_t width, uint32_t height, DXGI_FORMAT format, const Vector4& clearColor);

	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®é–‹å§‹
	/// </summary>
	void BeginRender();

	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®çµ‚äº†
	/// </summary>
	void EndRender();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();
	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> CreateRenderTextureResource(Microsoft::WRL::ComPtr<ID3D12Device>device, uint32_t width, uint32_t height, DXGI_FORMAT format, const Vector4& clearColor);
private:
	/// <summary>
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	/// </summary>
	void CreateGraphicsPipeLine();
	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	/// </summary>
	void CreateRootSignature();
	/// <summary>
	/// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	/// </summary>
	void CreateVertexBuffer();

public: // Getter, Setter
	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’å–å¾—
	/// </summary>
	D3D12_GPU_DESCRIPTOR_HANDLE GetGPUHandle() const;
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	/// DirectXCommonãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon_ = nullptr;
	/// SrvManagerãƒã‚¤ãƒ³ã‚¿
	SrvManager* srvManager_ = nullptr;

	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> texture;

	/// RTVãƒ’ãƒ¼ãƒ—
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> rtvHeap;
	/// RTVãƒãƒ³ãƒ‰ãƒ«
	D3D12_CPU_DESCRIPTOR_HANDLE rtvHandle;
	/// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	uint32_t srvIndex = 0;
	/// ã‚«ãƒ¬ãƒ³ãƒˆã‚¹ãƒ†ãƒ¼ãƒˆ
	D3D12_RESOURCE_STATES currentState = D3D12_RESOURCE_STATE_RENDER_TARGET;

	/// ã‚¯ãƒªã‚¢ã‚«ãƒ©ãƒ¼
	Vector4 clearColor_;

private:
	D3D12_INPUT_LAYOUT_DESC inputLayoutDescs{};
	D3D12_INPUT_ELEMENT_DESC inputElementDescs[2] = {};
	Microsoft::WRL::ComPtr<ID3D12RootSignature> rootSignature;
	/// ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ‡ã‚¹ã‚¯
	D3D12_BLEND_DESC blendDesc{};
	D3D12_RASTERIZER_DESC rasterizerDesc{};
	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob = nullptr;
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob = nullptr;
	// DepthStencilStateã®è¨­å®š
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};
	// RootSignatureä½œæˆ
	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ä½œæˆ
	Microsoft::WRL::ComPtr <ID3D12PipelineState> graphicsPipelineState = nullptr;
	// VertexBufferResource
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexBufferResource;
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView{};

	D3D12_RESOURCE_DESC resourceDesc{};

	Microsoft::WRL::ComPtr<ID3D12Resource> textureResource;
	 
};



============================================================
File Path: engine/2d/Sprite.cpp
============================================================
#include "Sprite.h"
#include "SpriteCommon.h"
#include "TextureManager.h"
void Sprite::Initialize( std::string textureFilePath)
{
	this->textureFilePath = textureFilePath;
	CreateVertexResourceData();
	CreateMaterialResource();
	CreateTransformationMatrixData();
	// å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
	TextureManager::GetInstance()->LoadTexture(textureFilePath);
	textureIndex = TextureManager::GetInstance()->GetSrvIndex(textureFilePath);
	transform = { {1.0f, 1.0f, 1.0f}, {0.0f, 0.0f, 0.0f}, {0.0f, 0.0f, 0.0f} };
	AdjustTextureSizee();
}

void Sprite::Update()
{
#pragma region é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®è¨­å®š
	float left = 0.0f - anchorPoint.x;
	float right = 1.0f - anchorPoint.x;
	float top = 0.0f - anchorPoint.y;
	float bottom = 1.0f - anchorPoint.y;

	// å·¦å³åè»¢
	if (isFlipX) {
		left = -left;
		right = -right;
	}

	// ä¸Šä¸‹åè»¢
	if (isFlipY) {
		top = -top;
		bottom = -bottom;
	}

	const DirectX::TexMetadata& metadata = TextureManager::GetInstance()->GetMetadata(textureFilePath);

	float texleft = textureLeftTop.x / metadata.width;
	float texright = (textureLeftTop.x + textureSize.x) / metadata.width;
	float textop = textureLeftTop.y / metadata.height;
	float texbottom = (textureLeftTop.y + textureSize.y) / metadata.height;

	// 1æšç›®ã®ä¸‰è§’å½¢
	// å·¦ä¸Š
	vertexData[0].position = { left, bottom, 0.0f, 1.0f };
	vertexData[0].texcoord = { texleft, texbottom };
	// å·¦ä¸‹
	vertexData[1].position = { left, top, 0.0f, 1.0f };
	vertexData[1].texcoord = { texleft, textop };
	//	å³ä¸‹
	vertexData[2].position = { right, bottom, 0.0f, 1.0f };
	vertexData[2].texcoord = { texright, texbottom };

	// 2æšç›®ã®ä¸‰è§’å½¢
	// å·¦ä¸Š
	vertexData[3].position = vertexData[1].position;
	vertexData[3].texcoord = vertexData[1].texcoord;
	// å³ä¸Š
	vertexData[4].position = { right, top, 0.0f, 1.0f };
	vertexData[4].texcoord = { texright, textop };
	// å³ä¸‹
	vertexData[5].position = vertexData[2].position;
	vertexData[5].texcoord = vertexData[2].texcoord;
#pragma endregion
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€(6å€‹åˆ†)
	for (int i = 0; i < 6; ++i) {
		vertexData[i].normal = { 0.0f, 0.0f, -1.0f };
	}


	// Transformæƒ…å ±ã‚’ä½œã‚‹

	transform.translate = { position.x, position.y, 0.0f };
	transform.rotate = { 0.0f, 0.0f, rotation };
	transform.scale = { size.x, size.y, 1.0f };
	// Transformã‹ã‚‰Worldè¡Œåˆ—ã‚’ä½œã‚‹
	Matrix4x4 worldMatrix = MakeAffineMatrix(transform.scale, transform.rotate, transform.translate);

	// ViewMatrixã‚’ä½œã£ã¦å˜ä½è¡Œåˆ—ã‚’ä»£å…¥
	Matrix4x4 viewMatrix = MakeIdentity4x4();

	// ProjectionMatrixã‚’ä½œã£ã¦å¹³è¡ŒæŠ•å½±è¡Œåˆ—ã‚’ä»£å…¥
	Matrix4x4 projectionMatrix = MakeOrthographicMatrix(0.0f, 0.0f, float(WinAPI::kClientWidth), float(WinAPI::kClientHeight), 0.0f, 100.0f);
	Matrix4x4 worldProjectionMatrix = Multiply(worldMatrix, Multiply(viewMatrix, projectionMatrix));

	// WVPè¡Œåˆ—ã‚’è¨ˆç®—
	transformationMatrix->WVP = worldProjectionMatrix;
	transformationMatrix->World = worldMatrix;
}





void Sprite::Draw()
{

	//Spriteã®æç”»æº–å‚™ã€‚Spriteã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
	SpriteCommon::GetInstance()->DrawSettingCommon();

	// VertexbufferViewã‚’è¨­å®š
	SpriteCommon::GetInstance()->GetDxCommon()->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);
	// IndexBufferViewã‚’è¨­å®š
	SpriteCommon::GetInstance()->GetDxCommon()->GetCommandList()->IASetIndexBuffer(&indexBufferView);
	// ãƒãƒ†ãƒªã‚¢ãƒ«CBufferã®å ´æ‰€ã‚’è¨­å®š
	SpriteCommon::GetInstance()->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());
	// åº§æ¨™å¤‰æ›è¡Œåˆ—CBufferã®å ´æ‰€ã‚’è¨­å®š
	SpriteCommon::GetInstance()->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(1, transformationMatrixResource->GetGPUVirtualAddress());
	// SRVã®DescriptorHeapã®å ´æ‰€ã‚’è¨­å®š
	SpriteCommon::GetInstance()->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(2, TextureManager::GetInstance()->GetSrvHandleGPU(textureFilePath));
	// æç”»
	//spriteCommon->GetDxCommon()->GetCommandList()->DrawInstanced(6, 1, 0, 0);
	SpriteCommon::GetInstance()->GetDxCommon()->GetCommandList()->DrawInstanced(6, 1, 0, 0);
	//spriteCommon->GetDxCommon()->GetCommandList()->DrawIndexedInstanced(6, 1, 0, 0, 0);
}

void Sprite::CreateVertexResourceData()
{

	// VertexResourceã‚’ä½œã‚‹
	vertexResource = SpriteCommon::GetInstance()->CreateSpriteVertexResource();
	// VertexBufferViewã‚’ä½œæˆã™ã‚‹(å€¤ã‚’è¨­å®šã™ã‚‹ã ã‘)
	vertexBufferView.BufferLocation = vertexResource->GetGPUVirtualAddress();
	// 6å€‹åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ã®ã§6å€
	vertexBufferView.SizeInBytes = sizeof(VertexData) * 6;
	// 1é ‚ç‚¹åˆ†ã®ã‚µã‚¤ã‚º
	vertexBufferView.StrideInBytes = sizeof(VertexData);

	// IndexResourceã‚’ä½œã‚‹
	indexResource = SpriteCommon::GetInstance()->CreateSpriteIndexResource();

	// IndexBufferViewã‚’ä½œæˆã™ã‚‹
	indexBufferView.BufferLocation = indexResource->GetGPUVirtualAddress();
	// 6å€‹åˆ†ã®ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ã®ã§6å€
	indexBufferView.SizeInBytes = sizeof(uint32_t) * 6;
	// 1é ‚ç‚¹åˆ†ã®ã‚µã‚¤ã‚º
	indexBufferView.Format = DXGI_FORMAT_R32_UINT;

	// IndexResourceã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦indexDataã«å‰²ã‚Šå½“ã¦ã‚‹
	indexData = nullptr;	// nullptrã‚’ä»£å…¥ã—ã¦ãŠã
	indexResource->Map(0, nullptr, reinterpret_cast<void**>(&indexData));	// ãƒãƒƒãƒ—ã™ã‚‹

	// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€(4ç‚¹åˆ†)
	indexData[0] = 0; indexData[1] = 1; indexData[2] = 2;
	indexData[3] = 1; indexData[4] = 3; indexData[5] = 2;

	// VertexResourceã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦vertexDataã«å‰²ã‚Šå½“ã¦ã‚‹
	vertexData = nullptr;	// nullptrã‚’ä»£å…¥ã—ã¦ãŠã
	vertexResource->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));	// ãƒãƒƒãƒ—ã™ã‚‹

}


void Sprite::CreateMaterialResource() {
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã™ã‚‹
	materialResource = SpriteCommon::GetInstance()->GetDxCommon()->CreateBufferResource(sizeof(Material));
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦materialã«å‰²ã‚Šå½“ã¦ã‚‹
	materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));	// ãƒãƒƒãƒ—ã™ã‚‹

	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	materialData->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	materialData->enableLighting = false;
	materialData->uvTransform = MakeIdentity4x4();
}

void Sprite::CreateTransformationMatrixData()
{
	// å¤‰æ›è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆã™ã‚‹
	transformationMatrixResource = SpriteCommon::GetInstance()->GetDxCommon()->CreateBufferResource(sizeof(TransformationMatrix));

	// å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦transformationMatrixã«å‰²ã‚Šå½“ã¦ã‚‹
	transformationMatrix = nullptr; // nullptrã‚’ä»£å…¥ã—ã¦ãŠã
	transformationMatrixResource->Map(0, nullptr, reinterpret_cast<void**>(&transformationMatrix)); // ãƒãƒƒãƒ—ã™ã‚‹

	//å˜ä½è¡Œåˆ—ã‚’æ›¸ãè¾¼ã‚“ã§ãŠã
	transformationMatrix->WVP = MakeIdentity4x4();
	transformationMatrix->World = MakeIdentity4x4();
}

void Sprite::AdjustTextureSizee()
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
	const DirectX::TexMetadata& metadata = TextureManager::GetInstance()->GetMetadata(textureFilePath);
	textureSize = { static_cast<float>(metadata.width),static_cast<float>(metadata.height) };
	// ç”»åƒã‚µã‚¤ã‚ºã‚’ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºã«åˆã‚ã›ã‚‹
	size = textureSize;
}



============================================================
File Path: engine/2d/Sprite.h
============================================================
#pragma once
#include "MyMath.h"
#include <d3d12.h>
#include <wrl.h>
#include "MakeMatrix.h"
class SpriteCommon;
/// <summary>
/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚¯ãƒ©ã‚¹
/// </summary>
class Sprite
{
public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize(std::string textureFilePath);
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

public:	// Getter/Setter
	/// <summary>
	/// åº§æ¨™å–å¾— / è¨­å®š
	/// </summary>
	/// <returns></returns>
	const Vector2& GetPosition()const { return position; }
	void SetPosition(const Vector2& position) { this->position = position; }
	/// <summary>
	/// å›è»¢å–å¾— / è¨­å®š
	/// </summary>
	float GetRotation()const { return rotation; }
	void SetRotation(float rotation) { this->rotation = rotation; }
	/// <summary>
	/// è‰²å–å¾— / è¨­å®š
	/// </summary>
	const Vector4& GetColor()const { return materialData->color; }
	void SetColor(const Vector4& color) { materialData->color = color; }
	/// <summary>
	/// ã‚µã‚¤ã‚ºå–å¾— / è¨­å®š
	/// </summary>
	const Vector2& GetSize()const { return size; }
	void SetSize(const Vector2& size) { this->size = size; }

	/// <summary>
	/// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆå–å¾— / è¨­å®š
	/// </summary>
	const Vector2& GetAnchorPoint()const { return anchorPoint; }
	void SetAnchorPoint(const Vector2& anchorPoint) { this->anchorPoint = anchorPoint; }

	/// <summary>
	/// FlipXå–å¾— / è¨­å®š
	/// </summary>
	bool GetFlipX()const { return isFlipX; }
	void SetFlipX(bool isFlipX) { this->isFlipX = isFlipX; }
	/// <summary>
	/// FlipYå–å¾— / è¨­å®š
	/// </summary>
	bool GetFlipY()const { return isFlipY; }
	void SetFlipY(bool isFlipY) { this->isFlipY = isFlipY; }
	/// <summary>
	/// TextureLeftTopå–å¾— / è¨­å®š
	/// </summary>
	/// <returns></returns>
	const Vector2& GetTextureLeftTop()const { return textureLeftTop; }
	void SetTextureLeftTop(const Vector2& textureLeftTop) { this->textureLeftTop = textureLeftTop; }
	/// <summary>
	/// TextureSizeå–å¾— / è¨­å®š
	/// </summary>
	const Vector2& GetTextureSize()const { return textureSize; }
	void SetTextureSize(const Vector2& textureSize) { this->textureSize = textureSize; }


private:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	/// </summary>
	void CreateVertexResourceData();
	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚½ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	/// </summary>
	void CreateMaterialResource();
	/// <summary>
	/// å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	/// </summary>
	void CreateTransformationMatrixData();
	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚µã‚¤ã‚ºèª¿æ•´
	/// </summary>
	void AdjustTextureSizee();

	//void DrawSetting();
private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	std::string textureFilePath;
	
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource> vertexResource;
	Microsoft::WRL::ComPtr <ID3D12Resource> indexResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	VertexData* vertexData = nullptr;
	uint32_t* indexData = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ä½¿ã„é“ã‚’è£œè¶³ã™ã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView{};
	D3D12_INDEX_BUFFER_VIEW indexBufferView{};

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource> materialResource = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’ç¤ºã™ãƒã‚¤ãƒ³ã‚¿
	Material* materialData = nullptr;

	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource>transformationMatrixResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’ç¤ºã™ãƒã‚¤ãƒ³ã‚¿
	TransformationMatrix* transformationMatrix = nullptr;

	// åº§æ¨™
	Vector2 position = { 0.0f,0.0f };
	float rotation = 0.0f;
	// è‰²ã¯materialDataã«æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã®ã§ãã¡ã‚‰ã‚’å‚ç…§
	Vector2 size = { 640.0f,360.0f };

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç•ªå·
	uint32_t textureIndex = 0;

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ 
	Transform transform;

	// ã‚¢ãƒ³ã‚«ãƒ¼ãƒã‚¤ãƒ³ãƒˆ
	Vector2 anchorPoint = { 0.0f,0.0f };
	// å·¦å³ä¸Šä¸‹ã®åè»¢ãƒ•ãƒ©ã‚°
	// å·¦å³ãƒ•ãƒªãƒƒãƒ—
	bool isFlipX = false;
	// ä¸Šä¸‹ãƒ•ãƒªãƒƒãƒ—
	bool isFlipY = false;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£å·¦ä¸Šåº§æ¨™
	Vector2 textureLeftTop = { 0.0f,0.0f };
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åˆ‡ã‚Šå‡ºã—ã‚µã‚¤ã‚º
	Vector2 textureSize = { 100.0f,100.0f };
};



============================================================
File Path: engine/2d/SpriteCommon.cpp
============================================================
#include "SpriteCommon.h"
#include "Logger.h"
#include "MyMath.h"
SpriteCommon* SpriteCommon::instance = nullptr;
SpriteCommon* SpriteCommon::GetInstance()
{
	if (instance == nullptr) {
		instance = new SpriteCommon();
	}
	return instance;
}

void SpriteCommon::Deletenstance()
{
	if (instance != nullptr) {
		delete instance;
		instance = nullptr;
	}
}

void SpriteCommon::Initialize(DirectXCommon* dxCommon)
{
	//å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
	dxCommon_ = dxCommon;
	CreateGraficsPipeLine();
}

void SpriteCommon::CreateRootSignatrue()
{
#pragma region RootParameter
	//RootSignatureä½œæˆ
	descriptionRootSignature.Flags =
		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
#pragma region DescriptorRange
	D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
	descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;//SRVã‚’ä½¿ã†
	descriptorRange[0].NumDescriptors = 1;//æ•°ã¯ï¼‘ã¤
	descriptorRange[0].BaseShaderRegister = 0;//0ã‹ã‚‰å§‹ã¾ã‚‹
	descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;//offsetã‚’è‡ªå‹•è¨ˆç®—

	


#pragma endregion
	
	//RootParamaterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚ä»Šå›ã¯çµæœãŒï¼‘ã¤ã ã‘ãªã®ã§é•·ã•ï¼‘ã®é…åˆ—
	D3D12_ROOT_PARAMETER rootParamaters[4] = {};
	rootParamaters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;//CBVã‚’ä½¿ã†
	rootParamaters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
	rootParamaters[0].Descriptor.ShaderRegister = 0;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼ã¨ãƒã‚¤ãƒ³ãƒ‰

	rootParamaters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;//
	rootParamaters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;//
	rootParamaters[1].Descriptor.ShaderRegister = 0;//

	rootParamaters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;//DescriptorTableã‚’ä½¿ã†
	rootParamaters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
	rootParamaters[2].DescriptorTable.pDescriptorRanges = descriptorRange;//Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
	rootParamaters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange);//Tableã§åˆ©ç”¨ã™ã‚‹æ•°

	rootParamaters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;	//CBVã§ä½¿ã†
	rootParamaters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;	//PixelShaderã§ä½¿ã†
	rootParamaters[3].Descriptor.ShaderRegister = 1;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼‘ã‚’ä½¿ã†

	

	descriptionRootSignature.pParameters = rootParamaters;//ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	descriptionRootSignature.NumParameters = _countof(rootParamaters);//
#pragma endregion



	D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
	staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;//ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿
	staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//0ï½1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ
	staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//
	staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//
	staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;//æ¯”è¼ƒã—ãªã„
	staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;//ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†
	staticSamplers[0].ShaderRegister = 0;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†
	staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†

	descriptionRootSignature.pStaticSamplers = staticSamplers;
	descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºçµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr <ID3DBlob> signatureBlob = nullptr;
	// ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç™ºç”Ÿã—ãŸå ´åˆã«æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr <ID3DBlob> errorBlob = nullptr;
	HRESULT hr = D3D12SerializeRootSignature(&descriptionRootSignature, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(hr)) {
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	hr = dxCommon_->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
	assert(SUCCEEDED(hr));
	
}

void SpriteCommon::InitializePixelShaderOutput()
{
	
	
}

void SpriteCommon::DrawSettingCommon()
{
	
	// RootSignatureã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‘ã©åˆ¥é€”è¨­å®šãŒå¿…è¦
	dxCommon_->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());

	dxCommon_->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());  // PSOã‚’è¨­å®š

	// å½¢çŠ¶ã‚’è¨­å®šã€‚PSOã«è¨­å®šã—ã¦ã„ã‚‹ã‚‚ã®ã¨ã¯ã¾ãŸåˆ¥ã€‚åŒã˜ã‚‚ã®ã‚’è¨­å®šã™ã‚‹ã¨è€ƒãˆã¦ãŠã‘ã°è‰¯ã„
	dxCommon_->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

}


void SpriteCommon::CreateGraficsPipeLine()
{
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	CreateRootSignatrue();

	// é ‚ç‚¹ã®ä½ç½®ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’è¨­å®š
	inputElementDescs[0].SemanticName = "POSITION";
	inputElementDescs[0].SemanticIndex = 0;
	inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã®åº§æ¨™
	inputElementDescs[1].SemanticName = "TEXCOORD";
	inputElementDescs[1].SemanticIndex = 0;
	inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	// æ³•ç·šãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’è¨­å®š
	inputElementDescs[2].SemanticName = "NORMAL";
	inputElementDescs[2].SemanticIndex = 0;
	inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputLayoutDescs.pInputElementDescs = inputElementDescs;
	inputLayoutDescs.NumElements = _countof(inputElementDescs);

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ›¸ãè¾¼ã¿ãƒã‚¹ã‚¯ã‚’è¨­å®šã€‚å…¨ã¦ã®è‰²ãƒãƒ£ãƒ³ãƒãƒ«ã«æ›¸ãè¾¼ã¿ã‚’è¨±å¯
	blendDesc.RenderTarget[0].RenderTargetWriteMask =
		D3D12_COLOR_WRITE_ENABLE_ALL;
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚’æœ‰åŠ¹åŒ–
	blendDesc.RenderTarget[0].BlendEnable = true;
	// åŠ ç®—åˆæˆ
	blendDesc.RenderTarget[0].SrcBlend = D3D12_BLEND_SRC_ALPHA;
	// æ¸›ç®—åˆæˆ
	blendDesc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_ALPHA;
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚ªãƒšãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã¯åŠ ç®—
	blendDesc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;

	// Î±å€¤è‡ªä½“ã®åˆæˆè¨­å®š
	blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;
	blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;
	blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;

	// ã‚«ãƒªãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®š
	rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
	// ãƒãƒªã‚´ãƒ³ã®ãƒ•ã‚£ãƒ«ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®šã€‚ãƒãƒªã‚´ãƒ³ã®å¡—ã‚Šæ½°ã—
	rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;

	//ã€€é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	vertexShaderBlob = dxCommon_->CompileShader(
		L"resources/shaders/Sprite.VS.hlsl", L"vs_6_0");
	assert(vertexShaderBlob != nullptr);
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	pixelShaderBlob = dxCommon_->CompileShader(
		L"resources/shaders/Sprite.PS.hlsl", L"ps_6_0");
	assert(pixelShaderBlob != nullptr);


	//Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
	depthStencilDesc.DepthEnable = true;
	//æ›¸ãè¾¼ã¿ã—ã¾ã™
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
	//æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;



	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
	graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();
	// ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.InputLayout = inputLayoutDescs;
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®è¨­å®š
	graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),vertexShaderBlob->GetBufferSize() };//
	graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),pixelShaderBlob->GetBufferSize() };//
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.BlendState = blendDesc;
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	graphicsPipelineStateDesc.RasterizerState = rasterizerDesc;
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ãƒãƒ­æ™‚ã®è¨­å®š
	graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	// DepthStencilã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
	
	HRESULT hr = dxCommon_->GetDevice()->CreateGraphicsPipelineState(
		&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState));

	assert(SUCCEEDED(hr));
}



Microsoft::WRL::ComPtr<ID3D12Resource>
SpriteCommon::CreateSpriteVertexResource()
{
	vertexResource = nullptr;
	vertexResource = dxCommon_->CreateBufferResource(sizeof(VertexData) * 6);
	return vertexResource;
}

Microsoft::WRL::ComPtr<ID3D12Resource>
SpriteCommon::CreateSpriteIndexResource()
{
	indexResource = nullptr;
	indexResource = dxCommon_->CreateBufferResource(sizeof(uint32_t) * 6);
	return indexResource;
}


============================================================
File Path: engine/2d/SpriteCommon.h
============================================================
#pragma once
#include "DirectXCommon.h"
/// <summary>
/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå…±é€šã‚¯ãƒ©ã‚¹
/// </summary>
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹
class SpriteCommon
{
public:	
	/// <summary>
	/// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	static SpriteCommon* GetInstance();
	/// <summary>
	/// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å‰Šé™¤
	/// </summary>
	static void Deletenstance();


public:		// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon"></param>
	void Initialize(DirectXCommon* dxCommon);

	/// <summary>
	/// å…±é€šæç”»è¨­å®š
	/// </summary>
	void DrawSettingCommon();
public:		//	Getter,Setter
	/// <summary>
	/// DirectXCommonå–å¾—é–¢æ•°
	/// </summary>
	DirectXCommon* GetDxCommon()const { return dxCommon_; }

public:	// Spriteã‚¯ãƒ©ã‚¹ã«å‘ã‘ãŸãƒ©ãƒƒãƒ‘ãƒ¼é–¢æ•°(wrapper function)
	/// <summary>
	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆé ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> CreateSpriteVertexResource();
	/// <summary>
	/// ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> CreateSpriteIndexResource();
private:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	/// </summary>
	void CreateRootSignatrue();

	/// <summary>
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	/// </summary>
	void CreateGraficsPipeLine();
	/// <summary>
	/// PSO
	/// </summary>
	void InitializePixelShaderOutput();
	

private:	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ç”¨ãƒ¡ãƒ³ãƒå¤‰æ•°ã¨é–¢æ•°
	/// <summary>
	/// ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	/// </summary>
	static SpriteCommon* instance;
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ã‚³ãƒ”ãƒ¼ç¦æ­¢
	/// </summary>
	SpriteCommon() = default;
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~SpriteCommon() = default;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ç¦æ­¢
	/// </summary>
	SpriteCommon(SpriteCommon&) = delete;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ç¦æ­¢
	/// </summary>
	SpriteCommon& operator=(SpriteCommon&) = delete;

private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// çµ¶å¯¾ã«new,deleteã—ãªã„
	DirectXCommon* dxCommon_;
	// RootSignatureä½œæˆ
	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
	// å…¥åŠ›ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨˜è¿°ã‚’è¨­å®š
	D3D12_INPUT_LAYOUT_DESC inputLayoutDescs{};
	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob = nullptr;
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob = nullptr;
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	D3D12_BLEND_DESC blendDesc{};
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ãƒ¼ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	D3D12_RASTERIZER_DESC rasterizerDesc{};
	// DepthStencilStateã®è¨­å®š
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	Microsoft::WRL::ComPtr <ID3D12RootSignature> rootSignature = nullptr;
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ä½œæˆ
	Microsoft::WRL::ComPtr <ID3D12PipelineState> graphicsPipelineState = nullptr;
	// å…¥åŠ›è¦ç´ ã®å®šç¾©é…åˆ—ã‚’åˆæœŸåŒ–
	D3D12_INPUT_ELEMENT_DESC inputElementDescs[3] = {};


private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	Microsoft::WRL::ComPtr<ID3D12Resource>vertexResource = nullptr;
	Microsoft::WRL::ComPtr<ID3D12Resource>indexResource = nullptr;

};



============================================================
File Path: engine/3d/Model.cpp
============================================================
#include "Model.h"
using namespace std;



void Model::Initialize(ModelCommon* modelCommon, const string& directorypath, const string& filename)
{
	// ModelCommonã®ãƒã‚¤ãƒ³ã‚¿ã‚’å¼•æ•°ã‹ã‚‰ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²
	this->modelCommon = modelCommon;
	// ãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
	modelData = LoadObjFile(directorypath, filename);
	// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	CreateVertexResourceData();
	// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ–
	CreateMaterialResource();
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£èª­ã¿è¾¼ã¿
	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½¿ç”¨ã™ã‚‹
	if(modelData.material.textureFilePath.empty()) {
		// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ä½¿ç”¨ã™ã‚‹
		modelData.material.textureFilePath = "Resources/texture/default.png";
	}
	// .objã®å‚ç…§ã—ã¦ã„ã‚‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
	TextureManager::GetInstance()->LoadTexture(modelData.material.textureFilePath);
	// èª­ã¿è¾¼ã‚“ã ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
	TextureManager::GetInstance()->GetSrvIndex(modelData.material.textureFilePath);
}

void Model::Draw()
{
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼ã‚’ã‚»ãƒƒãƒˆ
	modelCommon->GetDxCommon()->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ã‚»ãƒƒãƒˆ
	modelCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());
	// 
	modelCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(2,
		TextureManager::GetInstance()->GetSrvHandleGPU(modelData.material.textureFilePath));

	// ç’°å¢ƒãƒãƒƒãƒ—
	modelCommon->GetDxCommon()->GetCommandList()->SetGraphicsRootDescriptorTable(4,
		TextureManager::GetInstance()->GetSrvHandleGPU(cubeMapPath));


	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’ã‚»ãƒƒãƒˆ
	//modelCommon->GetDxCommon()->GetCommandList()->SetGraphicsRoot32BitConstant(3, modelData.material.textureIndex, 0);
	// æç”»
	modelCommon->GetDxCommon()->GetCommandList()->DrawInstanced(UINT(modelData.vertices.size()), 1, 0, 0);

}



ModelData Model::LoadObjFile(const std::string& directoryPath, const std::string& filename)
{

	// 1. å¿…è¦ãªå¤‰æ•°å®£è¨€
	ModelData modelData;			// æ§‹ç¯‰ã™ã‚‹ModelData
	vector<Vector4> positions;		// ä½ç½®
	vector<Vector3> normals;		// æ³•ç·š
	vector<Vector2> texcoords;		// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™
	string line;					// ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã‚“ã 1è¡Œã‚’æ ¼ç´

	// 2. ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	ifstream file(directoryPath + "/" + filename);
	assert(file.is_open());         // é–‹ã‘ãªã‹ã£ãŸã‚‰æ­¢ã‚ã‚‹

	while (getline(file, line)) {
		string identifier;
		istringstream s(line);
		s >> identifier; // å…ˆé ­ã®è­˜åˆ¥å­ã‚’èª­ã‚€

		// identifierã«å¿œã˜ãŸå‡¦ç†
		if (identifier == "v") {
			Vector4 position;
			s >> position.x >> position.y >> position.z;
			position.x *= -1;
			position.w = 1.0f;
			positions.push_back(position);
		}
		else if (identifier == "vt") {
			Vector2 texcoord;
			s >> texcoord.x >> texcoord.y;
			texcoord.y = 1.0f - texcoord.y;
			texcoords.push_back(texcoord);
		}
		else if (identifier == "vn") {
			Vector3 normal;
			s >> normal.x >> normal.y >> normal.z;
			normal.x *= -1;
			normals.push_back(normal);
		}
		else if (identifier == "f") {
			VertexData triangle[3];
			// é¢ã¯ä¸‰è§’å½¢é™å®šã€‚ãã®ä»–ã¯æœªå®šã€‚
			for (int32_t faceVertex = 0; faceVertex < 3; ++faceVertex) {
				string vertexDefinition;
				s >> vertexDefinition;
				// é ‚ç‚¹ã®è¦ç´ ã¸ã®Indexã¯ã€€ï¼»ä½ç½®/UV/æ³•ç·šï¼½ã€€ã§æ ¼ç´ã•ã‚Œã¦ã„ã‚‹ã®ã§åˆ†è§£ã—ã¦Indexã‚’å–å¾—ã™ã‚‹
				istringstream v(vertexDefinition);
				uint32_t elementIndices[3];
				for (int32_t element = 0; element < 3; ++element) {
					string index;
					getline(v, index, '/');      // åŒºåˆ‡ã‚Šã§ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã†ãƒèª­ã‚“ã§ã„ã
					elementIndices[element] = stoi(index);
				}
				// è¦ç´ ã¸ã®Indexã‹ã‚‰ã€å®Ÿéš›ã®è¦ç´ ã®å€¤ã‚’å–å¾—ã—ã¦ã€é ‚ç‚¹ã‚’æ§‹ç¯‰ã™ã‚‹
				Vector4 position = positions[elementIndices[0] - 1];
				Vector2 texcoord = texcoords[elementIndices[1] - 1];
				Vector3 normal = normals[elementIndices[2] - 1];

				triangle[faceVertex] = { position,texcoord,normal };
			}
			// é ‚ç‚¹ã‚’é€†é †ã™ã‚ã“ã¨ã§ã€å›ã‚Šé †ã‚’é€†ã«ã™ã‚‹
			modelData.vertices.push_back(triangle[2]);
			modelData.vertices.push_back(triangle[1]);
			modelData.vertices.push_back(triangle[0]);
		}
		else if (identifier == "mtllib") {
			std::string materialFilename;
			s >> materialFilename;
			modelData.material = LoadMaterialTempLateFile(directoryPath, materialFilename);
		}
	}
	return modelData;
}



MaterialData Model::LoadMaterialTempLateFile(const std::string& directoryPath, const std::string& filename)
{
	MaterialData materialData;	//æ§‹ç¯‰ã™ã‚‹MaterialData
	std::string line;			//ãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰èª­ã‚“ã ï¼‘è¡Œã‚’æ ¼ç´ã™ã‚‹ã‚‚ã®
	std::ifstream file(directoryPath + "/" + filename);//ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
	assert(file.is_open());		//é–‹ã‘ãªã‹ã£ãŸã‚‰æ­¢ã‚ã‚‹

	while (std::getline(file, line)) {
		std::string identifier;
		std::istringstream s(line);
		s >> identifier;
		//identifierã«å¿œã˜ãŸå‡¦ç†
		if (identifier == "map_Kd") {
			std::string textureFilename;
			s >> textureFilename;
			//é€£çµã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã«ã™ã‚‹
			materialData.textureFilePath = directoryPath + "/" + textureFilename;
		}
	}
	return materialData;
}

void Model::CreateVertexResourceData()
{
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	vertexResource = modelCommon->GetDxCommon()->CreateBufferResource(sizeof(VertexData) * modelData.vertices.size());
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€
	vertexResource->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));
	memcpy(vertexData, modelData.vertices.data(), sizeof(VertexData) * modelData.vertices.size());
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼ã‚’ä½œæˆ
	// ãƒªã‚½ãƒ¼ã‚¹ã®å…ˆé ­ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ä½¿ç”¨
	vertexBufferView.BufferLocation = vertexResource->GetGPUVirtualAddress();
	// ä½¿ç”¨ã™ã‚‹ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºã¯é ‚ç‚¹ã®ã‚µã‚¤ã‚º
	vertexBufferView.SizeInBytes = UINT(sizeof(VertexData) * modelData.vertices.size());
	vertexBufferView.StrideInBytes = sizeof(VertexData);
	//æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
	vertexResource->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));
	//é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚½ãƒ¼ã‚¹ã«ã‚³ãƒ”ãƒ¼
	memcpy(vertexData, modelData.vertices.data(), sizeof(VertexData) * modelData.vertices.size());
}

void Model::CreateMaterialResource()
{
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	materialResource = modelCommon->GetDxCommon()->CreateBufferResource(sizeof(Material));
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦materialDataã«å‰²ã‚Šå½“ã¦ã‚‹
	materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	materialData->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	materialData->enableLighting = 0;
	materialData->uvTransform = MakeIdentity4x4();

}


============================================================
File Path: engine/3d/Model.h
============================================================
#pragma once
#include "ModelCommon.h"
#include "Math.h"
#include "TextureManager.h"
#include <string>
#include <vector>
#include <fstream>
#include <cassert>
#include <wrl.h>
#include <d3d12.h>
#include <numbers>
#include "MakeMatrix.h"
#include "MyMath.h"
using namespace std;
/// <summary>
/// 3Dãƒ¢ãƒ‡ãƒ«ã‚¯ãƒ©ã‚¹
/// </summary>
class Model
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="modelCommon"></param>
	/// <param name="directorypath"></param>
	/// <param name="filename"></param>
	void Initialize(ModelCommon* modelCommon,const string& directorypath,const string&filename);
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();

	/// <summary>
	/// OBJãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="directoryPath"></param>
	/// <param name="filename"></param>
	/// <returns></returns>
	ModelData LoadObjFile(const std::string& directoryPath, const std::string& filename);
public: // Getter / Setter
	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	/// </summary>
	ModelData GetModelData()const { return modelData; }
	/// <summary>
	/// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ã®å–å¾—
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> GetVertexResource()const { return vertexResource; }
	/// <summary>
	/// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã®å–å¾—
	/// </summary>
	D3D12_VERTEX_BUFFER_VIEW GetVertexBufferView()const { return vertexBufferView; }
	/// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ«ã‚½ãƒ¼ã‚¹ã®å–å¾—
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> GetMaterialResource()const { return materialResource; }
	/// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®å–å¾—
	/// </summary>
	Material* GetMaterialData()const { return materialData; }
private: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã®èª­ã¿è¾¼ã¿
	/// </summary>
	MaterialData LoadMaterialTempLateFile(const std::string& directoryPath, const std::string& filename);
	/// <summary>
	/// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	/// </summary>
	void CreateVertexResourceData();
	/// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆ
	/// </summary>
	void CreateMaterialResource();

private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ModelCommon
	ModelCommon* modelCommon = nullptr;
	// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
	ModelData modelData;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ä½¿ã„é“ã‚’è£œè¶³ã™ã‚‹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView{};
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	VertexData* vertexData = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> materialResource;
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿
	Material* materialData = nullptr;

	std::string cubeMapPath = "resources/rostock_laage_airport_4k.dds";
};



============================================================
File Path: engine/3d/ModelCommon.cpp
============================================================
#include "ModelCommon.h"



ModelCommon::ModelCommon()
{
}

ModelCommon::~ModelCommon()
{
}

void ModelCommon::Initialize(DirectXCommon* dxCommon)
{
	//å¼•æ•°ã§å—ã‘å–ã£ã¦ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨˜éŒ²ã™ã‚‹
	this->dxCommon_ = dxCommon;
}


============================================================
File Path: engine/3d/ModelCommon.h
============================================================
#pragma once
#include "DirectXCommon.h"
/// <summary>
/// 3Dãƒ¢ãƒ‡ãƒ«å…±é€šéƒ¨
/// </summary>
class ModelCommon
{
public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	ModelCommon();
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~ModelCommon();
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon"></param>
	void Initialize(DirectXCommon* dxCommon);
	/// <summary>
	/// å…±é€šæç”»è¨­å®š
	/// </summary>
	void DrawSettingCommon();
public:	// Getter/Setter
	// DirectXCommon
	DirectXCommon* GetDxCommon()const { return dxCommon_; }
private:
	// çµ¶å¯¾ã«new,deleteã—ãªã„
	DirectXCommon* dxCommon_;

};



============================================================
File Path: engine/3d/ModelManager.cpp
============================================================
#include "ModelManager.h"

ModelManager* ModelManager::instance = nullptr;

ModelManager* ModelManager::GetInstance()
{
	if (instance == nullptr)
	{
		instance = new ModelManager();
	}
	return instance;
}

void ModelManager::Finalize()
{
	models.clear();

	delete modelCommon;
	modelCommon = nullptr;

	delete instance;
	instance = nullptr;
}

void ModelManager::Initialize(DirectXCommon* dxCommon)
{
	modelCommon = new ModelCommon();
	modelCommon->Initialize(dxCommon);
}

void ModelManager::LoadModel(const string& filePath)
{
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢
	if (models.contains(filePath))
	{
		// èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰æ—©æœŸãƒªã‚¿ãƒ¼ãƒ³
		return;
	}
	// ãƒ¢ãƒ‡ãƒ«ã®ç”Ÿæˆã¨ãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿ã€åˆæœŸåŒ–
	unique_ptr<Model>model = make_unique<Model>();
	model->Initialize(modelCommon, "resources", filePath);

	// ãƒ¢ãƒ‡ãƒ«ãƒªã‚¹ãƒˆã«è¿½åŠ 
	//models[filePath] = move(model);
	models.insert(make_pair(filePath, move(model)));
}

Model* ModelManager::FindModel(const string& filePath)
{
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢
	if (models.contains(filePath))
	{
		// èª­ã¿è¾¼ã¿ãƒ¢ãƒ‡ãƒ«ã‚’æˆ»ã‚Šå€¤ã¨ã—ã¦è¿”ã™
		return models.at(filePath).get();
	}
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ã§ãªã„å ´åˆã¯nullptrã‚’è¿”ã™
	return nullptr;
}


============================================================
File Path: engine/3d/ModelManager.h
============================================================
#pragma once
#include "ModelCommon.h"
#include "Math.h"
#include "TextureManager.h"
#include <string>
#include <vector>
#include <fstream>
#include "Model.h"
#include <map>
using namespace std;
/// <summary>
/// 3Dãƒ¢ãƒ‡ãƒ«ç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
class ModelManager
{
public: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	static ModelManager* GetInstance();
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å‰Šé™¤
	/// </summary>
	void Finalize();

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon"></param>
	void Initialize(DirectXCommon* dxCommon);
	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿
	/// </summary>
	/// <param name="filePath"></param>
	void LoadModel(const string& filePath);
public: // Getter/Setter
	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ã®æ¤œç´¢
	/// </summary>
	/// <param name="filePath"></param>
	/// <returns></returns>
	Model* FindModel(const string& filePath);

private: // ãƒ¡ãƒ³ãƒå¤‰æ•°ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	/// </summary>
	static ModelManager* instance;
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	ModelManager() = default;
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~ModelManager() = default;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ç„¡åŠ¹åŒ–
	/// </summary>
	/// <param name=""></param>
	ModelManager(ModelManager&) = delete;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ä»£å…¥æ¼”ç®—å­ç„¡åŠ¹åŒ–
	/// </summary>
	ModelManager& operator=(ModelManager&) = delete;
private: // ãƒ¡ãƒ³ãƒå¤‰æ•°
	ModelCommon* modelCommon = nullptr;
	// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚¹ãƒˆ
	map<string, unique_ptr<Model>> models;

};



============================================================
File Path: engine/3d/Object3D.cpp
============================================================
#include "Object3D.h"
#include "Object3DCommon.h"
#include <fstream>
#include <sstream>
#include <cassert>
#include "MakeMatrix.h"
#include "ModelManager.h"
using namespace std;
void Object3D::Initialize()
{

	this->camera = Object3DCommon::GetInstance()->GetDefaultCamera();

	CreateTransformationMatrixData();
	CreateDirectionalLightResource();
	// ã‚«ãƒ¡ãƒ©ãƒãƒƒãƒ•ã‚¡ã‚’ç”Ÿæˆ
	CreateCameraResource();

	// Transformã®åˆæœŸåŒ–
	transform = { { 1.0f, 1.0f, 1.0f },{ 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f  } };
}

void Object3D::Update()
{
	Matrix4x4 worldMatrix = MakeAffineMatrix(transform.scale, transform.rotate, transform.translate);
	Matrix4x4 worldViewProjection;
	if (camera) {
		const Matrix4x4& viewProjectionMatrix = camera->GetViewProjectionMatrix();
		worldViewProjection = Multiply(worldMatrix, viewProjectionMatrix);
	} else {
		worldViewProjection = worldMatrix;
	}
	wvpData->WVP = worldViewProjection;
	wvpData->World = worldMatrix;
}

void Object3D::Draw() {

	// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»æº–å‚™ã€‚3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®æç”»ã«å…±é€šã®ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
	Object3DCommon::GetInstance()->DrawSettingCommon();

	Object3DCommon::GetInstance()->GetDxCommon()->GetCommandList()->
		SetGraphicsRootConstantBufferView(1, wvpResource->GetGPUVirtualAddress());
	Object3DCommon::GetInstance()->GetDxCommon()->GetCommandList()->
		SetGraphicsRootConstantBufferView(3, directionalLightResource->GetGPUVirtualAddress());
	Object3DCommon::GetInstance()->GetDxCommon()->GetCommandList()->
		SetGraphicsRootConstantBufferView(5, cameraResource->GetGPUVirtualAddress());


	// é€šå¸¸ã®ãƒ¢ãƒ‡ãƒ«æç”»
	model->Draw();

}

void Object3D::Create(Model* model)
{
	assert(model); // ãƒ¢ãƒ‡ãƒ«ãŒnullptrã§ãªã„ã“ã¨ã‚’ç¢ºèª

	this->model = model;

	// ã‚«ãƒ¡ãƒ©ã‚’å–å¾—
	this->camera = Object3DCommon::GetInstance()->GetDefaultCamera();

	// å¤‰æ›è¡Œåˆ—ãƒãƒƒãƒ•ã‚¡ã‚’ç”Ÿæˆ
	CreateTransformationMatrixData();

	// å…‰æºãƒãƒƒãƒ•ã‚¡ã‚’ç”Ÿæˆ
	CreateDirectionalLightResource();

	// ã‚«ãƒ¡ãƒ©ãƒãƒƒãƒ•ã‚¡ã‚’ç”Ÿæˆ
	CreateCameraResource();


	// åˆæœŸTransform
	transform = {
		{ 1.0f, 1.0f, 1.0f },   // scale
		{ 0.0f, 0.0f, 0.0f },   // rotate
		{ 0.0f, 0.0f, 0.0f }    // translate
	};
}



void Object3D::SetModel(const std::string& filePath)
{
	// ãƒ¢ãƒ‡ãƒ«ã‚’æ¤œç´¢ã—ã¦ã‚»ãƒƒãƒˆã™ã‚‹
	model = ModelManager::GetInstance()->FindModel(filePath);
}





void Object3D::CreateTransformationMatrixData()
{
	// å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	wvpResource = Object3DCommon::GetInstance()->GetDxCommon()->
		CreateBufferResource(sizeof(TransformationMatrix));
	// å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹
	wvpResource->Map(0, nullptr, reinterpret_cast<void**>(&wvpData));
	// å¤‰æ›è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	wvpData->WVP = MakeIdentity4x4();
	wvpData->World = MakeIdentity4x4();

}

void Object3D::CreateDirectionalLightResource()
{
	// å¹³è¡Œå…‰æºãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	directionalLightResource = Object3DCommon::GetInstance()->GetDxCommon()->
		CreateBufferResource(sizeof(DirectionalLight));
	// å¹³è¡Œå…‰æºãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦directionalLightDataã«å‰²ã‚Šå½“ã¦ã‚‹
	directionalLightResource->Map(0, nullptr, reinterpret_cast<void**>(&directionalLightData));
	// å¹³è¡Œå…‰æºãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ– / ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
	// ãƒ©ã‚¤ãƒˆã®è‰²
	directionalLightData->color = { 1.0f, 1.0f, 1.0f, 1.0f };
	// ãƒ©ã‚¤ãƒˆã®å‘ã
	directionalLightData->direction = { 0.0f, -1.0f, 0.0f };
	// è¼åº¦
	directionalLightData->intensity = 1.0f;
}

void Object3D::CreateCameraResource()
{
	// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆ
	cameraResource = Object3DCommon::GetInstance()->GetDxCommon()->
		CreateBufferResource(sizeof(CameraForGPU));
	// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹ã«ãƒ‡ãƒ¼ã‚¿ã‚’æ›¸ãè¾¼ã‚€ãŸã‚ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦cameraForGpuDataã«å‰²ã‚Šå½“ã¦ã‚‹
	cameraResource->Map(0, nullptr, reinterpret_cast<void**>(&cameraForGpuData));
	// ã‚«ãƒ¡ãƒ©ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	cameraForGpuData->worldPosition = { 0.0f,4.0f,-10.0f };


}



============================================================
File Path: engine/3d/Object3D.h
============================================================
#pragma once
#include "Math.h"
#include <string>
#include <d3d12.h>
#include <vector>
#include <wrl.h>
#include "Model.h"
#include "Game/Camera/Camera.h"

// ãƒªãƒ³ã‚°çŠ¶ã®é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿æ§‹é€ ä½“
struct RingVertex {
	Vector4 position;
	Vector3 normal;
	Vector2 uv;
};
/// <summary>
/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚¯ãƒ©ã‚¹
/// </summary>
class Object3D
{

public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();
	/// <summary>
	/// æ›´æ–°
	/// </summary>
	void Update();
	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();


	/// <summary>
	///  ãƒ¬ãƒ™ãƒ«ãƒ­ãƒ¼ãƒ€ãƒ¼ãƒ¢ãƒ‡ãƒ«ç”Ÿæˆ
	/// </summary>
	void Create(Model* model);

public:	// Getter/Setter
	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ã®ã‚»ãƒƒãƒˆ
	/// </summary>
	void SetCamera(Camera* camera) { this->camera = camera; }
	/// <summary>
	/// Model å‹ã®ãƒã‚¤ãƒ³ã‚¿ã‚’ãƒ¡ãƒ³ãƒå¤‰æ•°ã«è¨­å®šã—ã¾ã™ã€‚
	/// </summary>
	void SetModel(Model* model) { this->model = model; }
	/// <summary>
	/// ãƒ¢ãƒ‡ãƒ«ã®èª­ã¿è¾¼ã¿ã¨è¨­å®š
	/// </summary>
	void SetModel(const std::string& filePath);
	/// <summary>
	/// ã‚¹ã‚±ãƒ¼ãƒ«ã®è¨­å®š
	/// </summary>
	void SetScale(const Vector3& scale) { transform.scale = scale; }
	/// <summary>
	/// å›è»¢ã®è¨­å®š
	/// </summary>
	void SetRotate(const Vector3& rotate) { transform.rotate = rotate; }
	/// <summary>
	/// å¹³è¡Œç§»å‹•ã®è¨­å®š
	/// </summary>
	void SetTranslate(const Vector3& translate) { transform.translate = translate; }
	/// <summary>
	/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®è¨­å®š
	/// </summary>
	void SetTransform(const Transform& transform) { this->transform = transform; }

	/// <summary>
	/// ã‚¹ã‚±ãƒ¼ãƒ«ã®å–å¾—
	/// </summary>
	const Vector3 GetScale()const { return transform.scale; }
	/// <summary>
	/// å›è»¢ã®å–å¾—
	/// </summary>
	const Vector3 GetRotate()const { return transform.rotate; }
	/// <summary>
	/// å¹³è¡Œç§»å‹•ã®å–å¾—
	/// </summary>
	const Vector3 GetTranslate()const { return transform.translate; }
	/// <summary>
	/// ãƒˆãƒ©ãƒ³ã‚¹ãƒ•ã‚©ãƒ¼ãƒ ã®å–å¾—
	/// </summary>
	const Transform& GetTransform()const { return transform; }
private: // ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åº§æ¨™å¤‰æ›è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ã®ä½œæˆ
	/// </summary>
	void CreateTransformationMatrixData();
	/// <summary>
	/// å¹³è¡Œå…‰æºãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆ
	/// </summary>
	void CreateDirectionalLightResource();
	/// <summary>
	/// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹ã®ä½œæˆ
	/// </summary>
	void CreateCameraResource();


private:// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ã‚«ãƒ¡ãƒ©
	Camera* camera = nullptr;
	// ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
	Model* model = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ / åº§æ¨™å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> wvpResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	TransformationMatrix* wvpData = nullptr;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ / å¹³è¡Œå…‰æºãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> directionalLightResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	DirectionalLight* directionalLightData = nullptr;

	// Transform
	Transform transform;


	Microsoft::WRL::ComPtr<ID3D12Resource>vertexBuffer;
	Microsoft::WRL::ComPtr<ID3D12Resource>indexBuffer;
	D3D12_VERTEX_BUFFER_VIEW vbView{};
	D3D12_INDEX_BUFFER_VIEW ibView{};
	uint32_t indexCount = 0;

	// ã‚«ãƒ¡ãƒ©ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> cameraResource;
	CameraForGPU* cameraForGpuData = nullptr;
};



============================================================
File Path: engine/3d/Object3DCommon.cpp
============================================================
#include "Object3DCommon.h"
#include "Logger.h"
Object3DCommon* Object3DCommon::instance = nullptr;


void Object3DCommon::Initialize(DirectXCommon* dxCommon)
{
	dxCommon_ = dxCommon;
	CreateGraphicsPipeLine();
}

void Object3DCommon::DrawSettingCommon()
{
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚»ãƒƒãƒˆ
	dxCommon_->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ãƒ—ãƒ©ã‚¤ãƒ³ã®ã‚»ãƒƒãƒˆ
	dxCommon_->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒãƒ­ã‚¸ãƒ¼ã®ã‚»ãƒƒãƒˆ
	dxCommon_->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
}


void Object3DCommon::CreateRootSignature()
{
#pragma region RootParameter
	//RootSignatureä½œæˆ
	descriptionRootSignature.Flags =
		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
#pragma region DescriptorRange
	D3D12_DESCRIPTOR_RANGE descriptorRange = {};
	descriptorRange.BaseShaderRegister = 0;//0ã‹ã‚‰å§‹ã¾ã‚‹
	descriptorRange.NumDescriptors = 1;//æ•°ã¯ï¼‘ã¤
	descriptorRange.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;//SRVã‚’ä½¿ã†
	descriptorRange.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;//offsetã‚’è‡ªå‹•è¨ˆç®—

	// ç’°å¢ƒãƒãƒƒãƒ—
	D3D12_DESCRIPTOR_RANGE descriptorRangeSkyBox = {};
	descriptorRangeSkyBox.BaseShaderRegister = 1;
	descriptorRangeSkyBox.NumDescriptors = 1;
	descriptorRangeSkyBox.RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV;
	descriptorRangeSkyBox.OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND;//offsetã‚’è‡ªå‹•è¨ˆç®—

	#pragma endregion

	//RootParamaterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚ä»Šå›ã¯çµæœãŒï¼‘ã¤ã ã‘ãªã®ã§é•·ã•ï¼‘ã®é…åˆ—
	D3D12_ROOT_PARAMETER rootParamaters[6] = {};
	rootParamaters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;//CBVã‚’ä½¿ã†
	rootParamaters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
	rootParamaters[0].Descriptor.ShaderRegister = 0;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼ã¨ãƒã‚¤ãƒ³ãƒ‰

	rootParamaters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;//
	rootParamaters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;//
	rootParamaters[1].Descriptor.ShaderRegister = 0;//

	rootParamaters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;//DescriptorTableã‚’ä½¿ã†
	rootParamaters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
	rootParamaters[2].DescriptorTable.pDescriptorRanges = &descriptorRange;//Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
	rootParamaters[2].DescriptorTable.NumDescriptorRanges = 1;//Tableã§åˆ©ç”¨ã™ã‚‹æ•°

	rootParamaters[3].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;	//CBVã§ä½¿ã†
	rootParamaters[3].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;	//PixelShaderã§ä½¿ã†
	rootParamaters[3].Descriptor.ShaderRegister = 1;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·ï¼‘ã‚’ä½¿ã†

	// ç’°å¢ƒãƒãƒƒãƒ—
	rootParamaters[4].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;//DescriptorTableã‚’ä½¿ã†
	rootParamaters[4].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†
	rootParamaters[4].DescriptorTable.pDescriptorRanges = &descriptorRangeSkyBox;//Tableã®ä¸­èº«ã®é…åˆ—ã‚’æŒ‡å®š
	rootParamaters[4].DescriptorTable.NumDescriptorRanges = 1;//Tableã§åˆ©ç”¨ã™ã‚‹æ•°

	//ã‚«ãƒ¡ãƒ©
	rootParamaters[5].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParamaters[5].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParamaters[5].Descriptor.ShaderRegister = 2;
	
	descriptionRootSignature.pParameters = rootParamaters;//ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿é…åˆ—ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	descriptionRootSignature.NumParameters = _countof(rootParamaters);//
#pragma endregion



	D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
	staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR;//ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿
	staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//0ï½1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ
	staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//
	staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;//
	staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;//æ¯”è¼ƒã—ãªã„
	staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX;//ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†
	staticSamplers[0].ShaderRegister = 0;//ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†
	staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;//PixelShaderã§ä½¿ã†

	descriptionRootSignature.pStaticSamplers = staticSamplers;
	descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºçµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr <ID3DBlob> signatureBlob = nullptr;
	// ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒç™ºç”Ÿã—ãŸå ´åˆã«æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr <ID3DBlob> errorBlob = nullptr;
	HRESULT hr = D3D12SerializeRootSignature(&descriptionRootSignature, D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(hr)) {
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	hr = dxCommon_->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(), signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
	assert(SUCCEEDED(hr));

}

void Object3DCommon::CreateGraphicsPipeLine()
{
	CreateRootSignature();

	// é ‚ç‚¹ã®ä½ç½®ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’è¨­å®š
	inputElementDescs[0].SemanticName = "POSITION";
	inputElementDescs[0].SemanticIndex = 0;
	inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£åº§æ¨™ãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã®åº§æ¨™
	inputElementDescs[1].SemanticName = "TEXCOORD";
	inputElementDescs[1].SemanticIndex = 0;
	inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	// æ³•ç·šãƒ‡ãƒ¼ã‚¿ã‚’è¡¨ã™ã‚»ãƒãƒ³ãƒ†ã‚£ã‚¯ã‚¹ã‚’è¨­å®š
	inputElementDescs[2].SemanticName = "NORMAL";
	inputElementDescs[2].SemanticIndex = 0;
	inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputLayoutDescs.pInputElementDescs = inputElementDescs;
	inputLayoutDescs.NumElements = _countof(inputElementDescs);

	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®æ›¸ãè¾¼ã¿ãƒã‚¹ã‚¯ã‚’è¨­å®šã€‚å…¨ã¦ã®è‰²ãƒãƒ£ãƒ³ãƒãƒ«ã«æ›¸ãè¾¼ã¿ã‚’è¨±å¯
	blendDesc.RenderTarget[0].RenderTargetWriteMask =
		D3D12_COLOR_WRITE_ENABLE_ALL;


	// ã‚«ãƒªãƒ³ã‚°ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®š
	rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
	// ãƒãƒªã‚´ãƒ³ã®ãƒ•ã‚£ãƒ«ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®šã€‚ãƒãƒªã‚´ãƒ³ã®å¡—ã‚Šæ½°ã—
	rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;

	//ã€€é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	vertexShaderBlob = dxCommon_->CompileShader(
		L"resources/shaders/Object3D.VS.hlsl", L"vs_6_0");
	assert(vertexShaderBlob != nullptr);
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	pixelShaderBlob = dxCommon_->CompileShader(
		L"resources/shaders/Object3D.PS.hlsl", L"ps_6_0");
	assert(pixelShaderBlob != nullptr);


	//Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
	depthStencilDesc.DepthEnable = true;
	//æ›¸ãè¾¼ã¿ã—ã¾ã™
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ALL;
	//æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;

#pragma region GraphicsPipelineState

	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ‡ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’è¨­å®š
	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};
	graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();
	// ã‚¤ãƒ³ãƒ—ãƒƒãƒˆãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.InputLayout = inputLayoutDescs;
	// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®è¨­å®š
	graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),vertexShaderBlob->GetBufferSize() };//
	graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),pixelShaderBlob->GetBufferSize() };//
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.BlendState = blendDesc;
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ã®è¨­å®š
	graphicsPipelineStateDesc.RasterizerState = rasterizerDesc;
	// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã®è¨­å®š
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	// ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ã¨ãƒãƒ­æ™‚ã®è¨­å®š
	graphicsPipelineStateDesc.PrimitiveTopologyType = D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	// DepthStencilã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
	HRESULT hr = dxCommon_->GetDevice()->CreateGraphicsPipelineState(
		&graphicsPipelineStateDesc, IID_PPV_ARGS(&graphicsPipelineState));
	assert(SUCCEEDED(hr));
#pragma endregion

}



Object3DCommon* Object3DCommon::GetInstance() {
	if (instance == nullptr) {
		instance = new Object3DCommon();
	}
	return instance;
}

void Object3DCommon::DeleteInstance() {
	delete instance;
	instance = nullptr;
}

============================================================
File Path: engine/3d/Object3DCommon.h
============================================================
#pragma once
#include "DirectXCommon.h"
#include "Game/Camera/Camera.h"
/// <summary>
/// 3Dã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå…±é€šéƒ¨
/// </summary>
class Object3DCommon
{
public:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize(DirectXCommon* dxCommon);
	/// <summary>
	/// å…±é€šæç”»è¨­å®š
	/// </summary>
	void DrawSettingCommon();
public:	// Getter/Setter
	/// <summary>
	/// DirectXCommonã®å–å¾—
	/// </summary>
	DirectXCommon* GetDxCommon()const { return dxCommon_; }
	/// <summary>
	/// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã®è¨­å®š
	/// </summary>
	void SetDefaultCamera(Camera* camera) { this->defaultCamera = camera; }
	/// <summary>
	/// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚«ãƒ¡ãƒ©ã®å–å¾—
	/// </summary>
	Camera* GetDefaultCamera()const { return defaultCamera; }
private:	// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ä½œæˆ
	/// </summary>
	void CreateRootSignature();
	/// <summary>
	///ã€€ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ä½œæˆ
	/// </summary>
	void CreateGraphicsPipeLine();

private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// ã‚«ãƒ¡ãƒ©
	Camera* defaultCamera = nullptr;
	// çµ¶å¯¾ã«new,deleteã—ãªã„
	DirectXCommon* dxCommon_;
	// RootSignatureä½œæˆ
	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
	// å…¥åŠ›ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨˜è¿°ã‚’è¨­å®š
	D3D12_INPUT_LAYOUT_DESC inputLayoutDescs{};
	// é ‚ç‚¹ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob = nullptr;
	// ãƒ”ã‚¯ã‚»ãƒ«ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœã‚’æ ¼ç´ã™ã‚‹Blob
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob = nullptr;
	// ãƒ–ãƒ¬ãƒ³ãƒ‰ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	D3D12_BLEND_DESC blendDesc{};
	// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ãƒ¼ã‚¹ãƒ†ãƒ¼ãƒˆã®è¨­å®š
	D3D12_RASTERIZER_DESC rasterizerDesc{};
	// DepthStencilStateã®è¨­å®š
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};
	// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	Microsoft::WRL::ComPtr <ID3D12RootSignature> rootSignature = nullptr;
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã®ä½œæˆ
	Microsoft::WRL::ComPtr <ID3D12PipelineState> graphicsPipelineState = nullptr;
	// å…¥åŠ›è¦ç´ ã®å®šç¾©é…åˆ—ã‚’åˆæœŸåŒ–
	D3D12_INPUT_ELEMENT_DESC inputElementDescs[3] = {};

public:
	static Object3DCommon* GetInstance();
	static void DeleteInstance();

private:
	Object3DCommon() = default;
	~Object3DCommon() = default;

	Object3DCommon(const Object3DCommon&) = delete;
	Object3DCommon& operator=(const Object3DCommon&) = delete;

	static Object3DCommon* instance;
};



============================================================
File Path: engine/3d/SkyBox/SkyBox.cpp
============================================================
#include "SkyBox.h"
#include <Logger.h>
#include "MakeMatrix.h"
#include "TextureManager.h"
#include "Object3DCommon.h"

void SkyBox::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager)
{
	this->dxCommon = dxCommon;
	this->srvManager = srvManager;
	this->camera = Object3DCommon::GetInstance()->GetDefaultCamera();
	TextureManager::GetInstance()->LoadTexture("resources/rostock_laage_airport_4k.dds");
	modelData.material.textureFilePath = "resources/rostock_laage_airport_4k.dds";
	/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	CreatePipeline();
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	CreateRootSignature();
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	SetGraphicsPipeline();
	/// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®é ‚ç‚¹ç”Ÿæˆ
	CreateVertexData();
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ–
	InitializeMaterial();
	/// 
	CreateTransformationMatrix();
}

void SkyBox::Update()
{
	// ã‚«ãƒ¡ãƒ©ã®ãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã¨ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³è¡Œåˆ—ã‚’å–å¾—
	const Matrix4x4& viewMatrix = camera->GetViewMatrix();
	const Matrix4x4& projectionMatrix = camera->GetProjectionMatrix();

	// å›è»¢ã¯ãã®ã¾ã¾ã€ä½ç½®ã ã‘ã‚’ç„¡è¦–ã—ãŸãƒ“ãƒ¥ãƒ¼è¡Œåˆ—ã‚’ä½œæˆ
	Matrix4x4 viewNoTranslation = viewMatrix;
	viewNoTranslation.m[3][0] = 0.0f;
	viewNoTranslation.m[3][1] = 0.0f;
	viewNoTranslation.m[3][2] = 0.0f;

	// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ç”¨ã®ãƒ¯ãƒ¼ãƒ«ãƒ‰è¡Œåˆ—ï¼ˆã‚¹ã‚±ãƒ¼ãƒ«ã®ã¿ã€ä½ç½®ã‚‚å›è»¢ã‚‚ãªã—ï¼‰
	Matrix4x4 worldMatrix = MakeScaleMatrix({ 1.0f, 1.0f, 1.0f });

	// WVPè¡Œåˆ—ã‚’æ§‹ç¯‰ï¼ˆè¦–ç‚¹å›ºå®šï¼‰
	Matrix4x4 viewProj = Multiply(viewNoTranslation, projectionMatrix);
	Matrix4x4 worldViewProjection = Multiply(worldMatrix, viewProj);

	wvpData->WVP = worldViewProjection;
	wvpData->World = worldMatrix;
}



void SkyBox::Draw()
{
	/// ã‚³ãƒãƒ³ãƒ‰ : ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã‚’è¨­å®š
	dxCommon->GetCommandList()->SetGraphicsRootSignature(rootSignature.Get());
	/// ã‚³ãƒãƒ³ãƒ‰ : ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚¹ãƒ†ãƒ¼ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¨­å®š
	dxCommon->GetCommandList()->SetPipelineState(graphicsPipelineState.Get());
	/// ã‚³ãƒãƒ³ãƒ‰ : ãƒ—ãƒªãƒŸãƒ†ã‚£ãƒ–ãƒˆãƒ­ãƒã‚¸(æç”»å½¢çŠ¶)ã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetPrimitiveTopology(D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST);
	/// ã‚³ãƒãƒ³ãƒ‰ : VertexBufferViewã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetVertexBuffers(0, 1, &vertexBufferView);
	/// ã‚³ãƒãƒ³ãƒ‰ : ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒãƒƒãƒ•ã‚¡ãƒ“ãƒ¥ãƒ¼ã‚’è¨­å®š
	dxCommon->GetCommandList()->IASetIndexBuffer(&indexBufferView);
	/// ã‚³ãƒãƒ³ãƒ‰ : ãƒãƒ†ãƒªã‚¢ãƒ«ã®å®šæ•°ãƒãƒƒãƒ•ã‚¡ã‚’è¨­å®š
	dxCommon->GetCommandList()->SetGraphicsRootConstantBufferView(0, materialResource->GetGPUVirtualAddress());
	///
	dxCommon->GetCommandList()->SetGraphicsRootConstantBufferView(1, wvpResource->GetGPUVirtualAddress());
	
	D3D12_GPU_DESCRIPTOR_HANDLE textureHandle =
		TextureManager::GetInstance()->GetSrvHandleGPU(modelData.material.textureFilePath);
	/// ã‚³ãƒãƒ³ãƒ‰ : ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ“ãƒ¥ãƒ¼ã‚’è¨­å®š
	dxCommon->GetCommandList()->SetGraphicsRootDescriptorTable(2,textureHandle);
	/// ã‚³ãƒãƒ³ãƒ‰ : æç”»
	//dxCommon->GetCommandList()->DrawInstanced(UINT(modelData.indices.size()), 1, 0, 0);
	dxCommon->GetCommandList()->DrawIndexedInstanced(UINT(modelData.indices.size()), 1, 0, 0, 0);
	
}

void SkyBox::CreatePipeline()
{
	// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	CreateRootSignature();
	// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	SetGraphicsPipeline();
}

void SkyBox::CreateRootSignature() {
	D3D12_DESCRIPTOR_RANGE descriptorRange[1] = {};
	//D3D12_DESCRIPTOR_RANGE descriptorRangeInstancing[1] = {};
	descriptorRange[0].BaseShaderRegister = 0; // 0ã‹ã‚‰å§‹ã¾ã‚‹
	descriptorRange[0].NumDescriptors = 1; // æ•°ã¯1ã¤
	descriptorRange[0].RangeType = D3D12_DESCRIPTOR_RANGE_TYPE_SRV; // SRV
	descriptorRange[0].OffsetInDescriptorsFromTableStart = D3D12_DESCRIPTOR_RANGE_OFFSET_APPEND; // Offsetã‚’è‡ªå‹•è¨ˆç®—

	// 1. RootSignatureã®ä½œæˆ
	descriptionRootSignature.Flags =
		D3D12_ROOT_SIGNATURE_FLAG_ALLOW_INPUT_ASSEMBLER_INPUT_LAYOUT;
	// RootParameterä½œæˆã€‚è¤‡æ•°è¨­å®šã§ãã‚‹ã®ã§é…åˆ—ã€‚
	// 0.Material
	rootParameters[0].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters[0].Descriptor.ShaderRegister = 0;

	// 1. TransformMatrix
	rootParameters[1].ParameterType = D3D12_ROOT_PARAMETER_TYPE_CBV;
	rootParameters[1].ShaderVisibility = D3D12_SHADER_VISIBILITY_VERTEX;
	rootParameters[1].Descriptor.ShaderRegister = 1;

	// 2.Texture
	rootParameters[2].ParameterType = D3D12_ROOT_PARAMETER_TYPE_DESCRIPTOR_TABLE;
	rootParameters[2].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL;
	rootParameters[2].DescriptorTable.pDescriptorRanges = descriptorRange;
	rootParameters[2].DescriptorTable.NumDescriptorRanges = _countof(descriptorRange);

	descriptionRootSignature.pParameters = rootParameters;
	descriptionRootSignature.NumParameters = _countof(rootParameters);

	// Samplerã®è¨­å®š
	staticSamplers[0].Filter = D3D12_FILTER_MIN_MAG_MIP_LINEAR; // ãƒã‚¤ãƒªãƒ‹ã‚¢ãƒ•ã‚£ãƒ«ã‚¿
	staticSamplers[0].AddressU = D3D12_TEXTURE_ADDRESS_MODE_WRAP; // 0~1ã®ç¯„å›²å¤–ã‚’ãƒªãƒ”ãƒ¼ãƒˆ
	staticSamplers[0].AddressV = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
	staticSamplers[0].AddressW = D3D12_TEXTURE_ADDRESS_MODE_WRAP;
	staticSamplers[0].ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER; // æ¯”è¼ƒã—ãªã„
	staticSamplers[0].MaxLOD = D3D12_FLOAT32_MAX; // ã‚ã‚Šã£ãŸã‘ã®Mipmapã‚’ä½¿ã†
	staticSamplers[0].ShaderRegister = 0; // ãƒ¬ã‚¸ã‚¹ã‚¿ç•ªå·0ã‚’ä½¿ã†
	staticSamplers[0].ShaderVisibility = D3D12_SHADER_VISIBILITY_PIXEL; // PixelShaderã§ä½¿ã†
	descriptionRootSignature.pStaticSamplers = staticSamplers;
	descriptionRootSignature.NumStaticSamplers = _countof(staticSamplers);

	// ã‚·ãƒªã‚¢ãƒ©ã‚¤ã‚ºã—ã¦ãƒã‚¤ãƒŠãƒªã«ã™ã‚‹
	Microsoft::WRL::ComPtr<ID3DBlob> signatureBlob = nullptr;
	Microsoft::WRL::ComPtr<ID3DBlob> errorBlob = nullptr;
	HRESULT hr = D3D12SerializeRootSignature(&descriptionRootSignature,
		D3D_ROOT_SIGNATURE_VERSION_1, &signatureBlob, &errorBlob);
	if (FAILED(hr)) {
		Logger::Log(reinterpret_cast<char*>(errorBlob->GetBufferPointer()));
		assert(false);
	}
	// ãƒã‚¤ãƒŠãƒªã‚’å…ƒã«ç”Ÿæˆ

	hr = dxCommon->GetDevice()->CreateRootSignature(0, signatureBlob->GetBufferPointer(),
		signatureBlob->GetBufferSize(), IID_PPV_ARGS(&rootSignature));
	assert(SUCCEEDED(hr));



	// 2. InputLayoutã®è¨­å®š
	inputElementDescs[0].SemanticName = "POSITION";
	inputElementDescs[0].SemanticIndex = 0;
	inputElementDescs[0].Format = DXGI_FORMAT_R32G32B32A32_FLOAT;
	inputElementDescs[0].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs[1].SemanticName = "TEXCOORD";
	inputElementDescs[1].SemanticIndex = 0;
	inputElementDescs[1].Format = DXGI_FORMAT_R32G32_FLOAT;
	inputElementDescs[1].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;

	inputElementDescs[2].SemanticName = "NORMAL";
	inputElementDescs[2].SemanticIndex = 0;
	inputElementDescs[2].Format = DXGI_FORMAT_R32G32B32_FLOAT;
	inputElementDescs[2].AlignedByteOffset = D3D12_APPEND_ALIGNED_ELEMENT;
	inputLayoutDesc.pInputElementDescs = inputElementDescs;
	inputLayoutDesc.NumElements = _countof(inputElementDescs);

	// 3. BlendDtateã®è¨­å®š
	blendDesc.RenderTarget[0].RenderTargetWriteMask = D3D12_COLOR_WRITE_ENABLE_ALL;
	blendDesc.RenderTarget[0].BlendEnable = true;

	SetBlendMode(blendDesc, blendMode);
	currentBlendMode = BlendMode::kBlendModeAdd;  // ç¾åœ¨ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰
	// Î±å€¤ã®ãƒ–ãƒ¬ãƒ³ãƒ‰
	blendDesc.RenderTarget[0].SrcBlendAlpha = D3D12_BLEND_ONE;
	blendDesc.RenderTarget[0].BlendOpAlpha = D3D12_BLEND_OP_ADD;
	blendDesc.RenderTarget[0].DestBlendAlpha = D3D12_BLEND_ZERO;
	// RasterrizerStateã®è¨­å®š
	// ã‚«ãƒªãƒ³ã‚°ãªã—
	rasterizerDesc.CullMode = D3D12_CULL_MODE_NONE;
	// å¡—ã‚Šã¤ã¶ã—ãƒ¢ãƒ¼ãƒ‰
	rasterizerDesc.FillMode = D3D12_FILL_MODE_SOLID;
	// 4. Shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	vertexShaderBlob = dxCommon->CompileShader(L"resources/shaders/SkyBox.VS.hlsl",
		L"vs_6_0");
	assert(vertexShaderBlob != nullptr);
	pixelShaderBlob = dxCommon->CompileShader(L"resources/shaders/SkyBox.PS.hlsl",
		L"ps_6_0");
	assert(pixelShaderBlob != nullptr);

	// DepthStencilStateã®è¨­å®š
	// Depthã®æ©Ÿèƒ½ã‚’æœ‰åŠ¹åŒ–ã™ã‚‹
	depthStencilDesc.DepthEnable = true;
	//æ›¸ãè¾¼ã¿ã—ã¾ã™
	depthStencilDesc.DepthWriteMask = D3D12_DEPTH_WRITE_MASK_ZERO;
	//æ¯”è¼ƒé–¢æ•°ã¯LessEqualã€‚ã¤ã¾ã‚Šã€è¿‘ã‘ã‚Œã°æç”»ã•ã‚Œã‚‹
	depthStencilDesc.DepthFunc = D3D12_COMPARISON_FUNC_LESS_EQUAL;
}

void SkyBox::SetGraphicsPipeline()
{
	graphicsPipelineStateDesc.pRootSignature = rootSignature.Get();
	graphicsPipelineStateDesc.InputLayout = inputLayoutDesc;
	graphicsPipelineStateDesc.VS = { vertexShaderBlob->GetBufferPointer(),
										vertexShaderBlob->GetBufferSize() };
	graphicsPipelineStateDesc.PS = { pixelShaderBlob->GetBufferPointer(),
										pixelShaderBlob->GetBufferSize() };
	graphicsPipelineStateDesc.BlendState = blendDesc;
	graphicsPipelineStateDesc.RasterizerState = rasterizerDesc;
	// Depthstencitã®è¨­å®š
	graphicsPipelineStateDesc.DepthStencilState = depthStencilDesc;
	graphicsPipelineStateDesc.DSVFormat = DXGI_FORMAT_D24_UNORM_S8_UINT;
	// æ›¸ãè¾¼ã‚€RTVã®æƒ…å ±
	graphicsPipelineStateDesc.NumRenderTargets = 1;
	graphicsPipelineStateDesc.RTVFormats[0] = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	// åˆ©ç”¨ã™ã‚‹ãƒˆãƒãƒ­ã‚¸ï¼ˆå½¢çŠ¶ï¼‰ã®ã‚¿ã‚¤ãƒ—.ä¸‰è§’å½¢
	graphicsPipelineStateDesc.PrimitiveTopologyType =
		D3D12_PRIMITIVE_TOPOLOGY_TYPE_TRIANGLE;
	// ã©ã®ã‚ˆã†ã«ç”»é¢ã«è‰²ã‚’æ‰“ã¡è¾¼ã‚€ã®ã‹è¨­å®šï¼ˆæ°—ã«ã—ãªãã¦è‰¯ã„ï¼‰
	graphicsPipelineStateDesc.SampleDesc.Count = 1;
	graphicsPipelineStateDesc.SampleMask = D3D12_DEFAULT_SAMPLE_MASK;
	// å®Ÿéš›ã«ç”Ÿæˆ
	HRESULT hr = dxCommon->GetDevice()->CreateGraphicsPipelineState(&graphicsPipelineStateDesc,
		IID_PPV_ARGS(&graphicsPipelineState));
	assert(SUCCEEDED(hr));
}

void SkyBox::CreateVertexBufferView() {

	vertexResource = dxCommon->CreateBufferResource(sizeof(VertexData) * modelData.vertices.size());
	// é ‚ç‚¹ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼
	vertexBufferView.BufferLocation = vertexResource->GetGPUVirtualAddress();
	// 1é ‚ç‚¹åˆ†ã®ã‚µã‚¤ã‚º
	vertexBufferView.StrideInBytes = sizeof(VertexData);
	// é ‚ç‚¹æ•°
	vertexBufferView.SizeInBytes = UINT(sizeof(VertexData) * modelData.vertices.size());
	// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿ / ãƒãƒƒãƒ—
	vertexResource->Map(0, nullptr, reinterpret_cast<void**>(&vertexData));
	// ãƒ‡ãƒ¼ã‚¿ã®æ›¸ãè¾¼ã¿
	memcpy(vertexData, modelData.vertices.data(), sizeof(VertexData) * modelData.vertices.size());

}

void SkyBox::InitializeMaterial()
{
	// ãƒªã‚½ãƒ¼ã‚¹ç”Ÿæˆ
	materialResource = dxCommon->CreateBufferResource(sizeof(Material));
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã«æ›¸ãè¾¼ã¿
	materialResource->Map(0, nullptr, reinterpret_cast<void**>(&materialData));
	// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	materialData->color = Vector4(1.0f, 1.0f, 1.0f, 1.0f);
	materialData->enableLighting = true;
	materialData->uvTransform = MakeIdentity4x4();
}

void SkyBox::CreateVertexData()
{
	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼ˆå„é¢ï¼š2ä¸‰è§’å½¢ï¼6ã¤ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ï¼‰
	indices = {
		// å„é¢ã”ã¨ã«2æšã®ä¸‰è§’å½¢ (6ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹)
		0, 1, 2,  2, 1, 3,   // å³é¢
		4, 5, 6,  6, 5, 7,   // å·¦é¢
		8, 9, 10, 10, 9,11,  // å‰é¢
		12,13,14, 14,13,15,  // å¾Œé¢
		16,17,18, 18,17,19,  // ä¸Šé¢
		20,21,22, 22,21,23   // ä¸‹é¢
	};

	modelData.indices = indices;


	// å³é¢ (+X) / æç”»index [0,1,2] [2,1,3]
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, -1.0f, 1.0f}, .texcoord = {1.0f, 0.0f}, .normal = {1, 0, 0} });
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, 1.0f, 1.0f},  .texcoord = {1.0f, 1.0f}, .normal = {1, 0, 0} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, -1.0f, 1.0f}, .texcoord = {0.0f, 0.0f}, .normal = {1, 0, 0} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, 1.0f, 1.0f},  .texcoord = {0.0f, 1.0f}, .normal = {1, 0, 0} });

	// å·¦é¢ (-X) / æç”»index [4,5,6] [6,5,7]
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, 1.0f, 1.0f},  .texcoord = {1.0f, 0.0f}, .normal = {-1, 0, 0} });
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, -1.0f, 1.0f}, .texcoord = {1.0f, 1.0f}, .normal = {-1, 0, 0} });
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, 1.0f, 1.0f}, .texcoord = {0.0f, 0.0f}, .normal = {-1, 0, 0} });
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, -1.0f, 1.0f},.texcoord = {0.0f, 1.0f}, .normal = {-1, 0, 0} });

	// å‰é¢ (+Z) / æç”»index [8,9,10] [10,9,11]
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, 1.0f, 1.0f},  .texcoord = {1.0f, 0.0f}, .normal = {0, 0, 1} });
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, 1.0f, 1.0f},   .texcoord = {1.0f, 1.0f}, .normal = {0, 0, 1} });
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, 1.0f, 1.0f}, .texcoord = {0.0f, 0.0f}, .normal = {0, 0, 1} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, 1.0f, 1.0f},  .texcoord = {0.0f, 1.0f}, .normal = {0, 0, 1} });

	// å¾Œé¢ (-Z) / æç”»index [12,13,14] [14,13,15]
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, -1.0f, 1.0f},  .texcoord = {1.0f, 0.0f}, .normal = {0, 0, -1} });
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, -1.0f, 1.0f}, .texcoord = {1.0f, 1.0f}, .normal = {0, 0, -1} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, -1.0f, 1.0f}, .texcoord = {0.0f, 0.0f}, .normal = {0, 0, -1} });
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, -1.0f, 1.0f},.texcoord = {0.0f, 1.0f}, .normal = {0, 0, -1} });

	// ä¸Šé¢ (+Y) / æç”»index [16,17,18] [18,17,19]
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, -1.0f, 1.0f}, .texcoord = {0.0f, 0.0f}, .normal = {0, 1, 0} });
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, -1.0f, 1.0f},  .texcoord = {0.0f, 1.0f}, .normal = {0, 1, 0} });
	modelData.vertices.push_back({ .position = {-1.0f, 1.0f, 1.0f, 1.0f},  .texcoord = {1.0f, 0.0f}, .normal = {0, 1, 0} });
	modelData.vertices.push_back({ .position = {1.0f, 1.0f, 1.0f, 1.0f},   .texcoord = {1.0f, 1.0f}, .normal = {0, 1, 0} });

	// ä¸‹é¢ (-Y) / æç”»index [20,21,22] [22,21,23]
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, 1.0f, 1.0f}, .texcoord = {0.0f, 0.0f}, .normal = {0, -1, 0} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, 1.0f, 1.0f},  .texcoord = {0.0f, 1.0f}, .normal = {0, -1, 0} });
	modelData.vertices.push_back({ .position = {-1.0f, -1.0f, -1.0f, 1.0f},.texcoord = {1.0f, 0.0f}, .normal = {0, -1, 0} });
	modelData.vertices.push_back({ .position = {1.0f, -1.0f, -1.0f, 1.0f}, .texcoord = {1.0f, 1.0f}, .normal = {0, -1, 0} });

	CreateVertexBufferView();
	CreateIndexBufferView();
}


void SkyBox::SetBlendMode(D3D12_BLEND_DESC& desc, BlendMode mode)
{
	switch (mode)
	{
	case kBlendModeAdd:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;
		break;
	case kBlendModeSubtract:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_REV_SUBTRACT;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ONE;
		break;
	case kBlendModeMultiply:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_DEST_COLOR;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_ZERO;
		break;
	case kBlendModeScreen:
		desc.RenderTarget[0].SrcBlend = D3D12_BLEND_ONE;
		desc.RenderTarget[0].BlendOp = D3D12_BLEND_OP_ADD;
		desc.RenderTarget[0].DestBlend = D3D12_BLEND_INV_SRC_COLOR;
		break;
	default:
		assert(false);
		break;
	}
}

void SkyBox::CreateTransformationMatrix()
{
	// å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹ã‚’ä½œæˆ
	wvpResource =Object3DCommon::GetInstance()->GetDxCommon()->
		CreateBufferResource(sizeof(TransformationMatrix));
	// å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹
	wvpResource->Map(0, nullptr, reinterpret_cast<void**>(&wvpData));
	// å¤‰æ›è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ã®åˆæœŸåŒ–
	wvpData->WVP = MakeIdentity4x4();
	wvpData->World = MakeIdentity4x4();
}

void SkyBox::CreateIndexBufferView() {

	// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒªã‚½ãƒ¼ã‚¹ä½œæˆ
	indexResource = dxCommon->CreateBufferResource(sizeof(uint32_t) * modelData.indices.size());

	// IndexBufferView è¨­å®š
	indexBufferView.BufferLocation = indexResource->GetGPUVirtualAddress();
	indexBufferView.SizeInBytes = UINT(sizeof(uint32_t) * modelData.indices.size());
	indexBufferView.Format = DXGI_FORMAT_R32_UINT;

	// ãƒãƒƒãƒ—ã—ã¦ãƒ‡ãƒ¼ã‚¿æ›¸ãè¾¼ã¿
	uint32_t* indexData = nullptr;
	indexResource->Map(0, nullptr, reinterpret_cast<void**>(&indexData));
	memcpy(indexData, modelData.indices.data(), sizeof(uint32_t) * modelData.indices.size());
}


============================================================
File Path: engine/3d/SkyBox/SkyBox.h
============================================================
#pragma once
#include "engine/math/MyMath.h"
#include "engine/base/DirectXCommon.h"
#include "engine/base/SrvManager.h"
#include "Game/Camera/camera.h"
/// <summary>
/// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã‚¯ãƒ©ã‚¹
/// </summary>
class SkyBox
{
private:
	/// <summary>
	/// ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ç”Ÿæˆ
	/// </summary>
	void CreatePipeline();

	/// <summary>
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£ã®ç”Ÿæˆ
	/// </summary>
	void CreateRootSignature();

	/// <summary>
	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®è¨­å®š
	/// </summary>
	void SetGraphicsPipeline();

	/// <summary>
	/// ãƒãƒƒãƒ•ã‚¡ãƒ¼ãƒ“ãƒ¥ãƒ¼ã®ä½œæˆ
	/// </summary>
	void CreateVertexBufferView();
	/// <summary>
	/// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®é ‚ç‚¹ç”Ÿæˆ
	/// </summary>
	void CreateVertexData();

	/// <summary>
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ã®åˆæœŸåŒ–
	/// </summary>
	void InitializeMaterial();

	/// <summary>
	/// ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š
	/// </summary>
	void SetBlendMode(D3D12_BLEND_DESC& desc, BlendMode mode);

	/// <summary>
	/// è¡Œåˆ—ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
	/// </summary>
	void CreateTransformationMatrix();

	/// <summary>
	/// ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ãƒ‡ãƒ¼ã‚¿ã®ç”Ÿæˆ
	/// </summary>
	void CreateIndexBufferView();
public:
	/// <summary>
	/// åˆæœŸåŒ–å‡¦ç†
	/// </summary>
	void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager);
	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	/// æç”»å‡¦ç†
	/// </summary>
	void Draw();
private:
	///  ãƒ¢ãƒ‡ãƒ«ãƒ‡ãƒ¼ã‚¿
	ModelData modelData;


	// Initialize
	/// DxCommonã®ãƒã‚¤ãƒ³ã‚¿
	DirectXCommon* dxCommon = nullptr;
	/// SRVãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã®ãƒã‚¤ãƒ³ã‚¿
	SrvManager* srvManager = nullptr;

	// CreateRootSignature
	D3D12_ROOT_SIGNATURE_DESC descriptionRootSignature{};
	/// ãƒ«ãƒ¼ãƒˆãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãƒ¼
	D3D12_ROOT_PARAMETER rootParameters[3] = {};
	/// ã‚µãƒ³ãƒ—ãƒ©ãƒ¼
	D3D12_STATIC_SAMPLER_DESC staticSamplers[1] = {};
	/// å…¥åŠ›ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®è¨­å®š
	D3D12_INPUT_ELEMENT_DESC inputElementDescs[3];
	/// ãƒ«ãƒ¼ãƒˆã‚·ã‚°ãƒãƒãƒ£
	Microsoft::WRL::ComPtr<ID3D12RootSignature> rootSignature = nullptr;
	/// å…¥åŠ›ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
	D3D12_INPUT_LAYOUT_DESC inputLayoutDesc{};

	/// ãƒ–ãƒ¬ãƒ³ãƒ‰
	D3D12_BLEND_DESC blendDesc{};
	BlendMode blendMode = BlendMode::kBlendModeAdd;
	BlendMode currentBlendMode = BlendMode::kBlendModeAdd;  // ç¾åœ¨ã®ãƒ–ãƒ¬ãƒ³ãƒ‰ãƒ¢ãƒ¼ãƒ‰

	/// ãƒ©ã‚¹ã‚¿ãƒ©ã‚¤ã‚¶ãƒ¼
	D3D12_RASTERIZER_DESC rasterizerDesc{};

	/// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ãƒã‚¤ãƒŠãƒª
	Microsoft::WRL::ComPtr<IDxcBlob> vertexShaderBlob = nullptr;
	Microsoft::WRL::ComPtr<IDxcBlob> pixelShaderBlob = nullptr;

	/// æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«
	D3D12_DEPTH_STENCIL_DESC depthStencilDesc{};

	/// ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚¹ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³
	Microsoft::WRL::ComPtr<ID3D12PipelineState> graphicsPipelineState = nullptr;
	D3D12_GRAPHICS_PIPELINE_STATE_DESC graphicsPipelineStateDesc{};

	// CreateVertexBufferView
	D3D12_VERTEX_BUFFER_VIEW vertexBufferView{};
	/// é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexResource = nullptr;
	/// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿
	VertexData* vertexData = nullptr;

	// InitializeMaterial
	Microsoft::WRL::ComPtr<ID3D12Resource> materialResource = nullptr;
	/// ãƒãƒ†ãƒªã‚¢ãƒ«ãƒ‡ãƒ¼ã‚¿
	Material* materialData = nullptr;

	// CreateTransformationMatrix
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ / åº§æ¨™å¤‰æ›è¡Œåˆ—ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Resource> wvpResource;
	// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹å†…ã®ãƒ‡ãƒ¼ã‚¿ã‚’æŒ‡ã™ãƒã‚¤ãƒ³ã‚¿
	TransformationMatrix* wvpData = nullptr;

	/// é ‚ç‚¹ãƒ‡ãƒ¼ã‚¿ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ 
	std::vector<uint32_t> indices;
	Microsoft::WRL::ComPtr<ID3D12Resource> indexResource;
	D3D12_INDEX_BUFFER_VIEW indexBufferView{};

	/// ã‚«ãƒ¡ãƒ©å¼•æ•°
	Camera* camera = nullptr;
public:

	/// <summary>
	/// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> skyBoxTexture = nullptr;
	/// <summary>
	/// ã‚¹ã‚«ã‚¤ãƒœãƒƒã‚¯ã‚¹ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ“ãƒ¥ãƒ¼
	/// </summary>
	D3D12_GPU_DESCRIPTOR_HANDLE skyBoxTextureView = {};
};



============================================================
File Path: engine/Audio/Audio.cpp
============================================================
#include "Audio.h"
#include <xaudio2.h> 
#include <cassert>
Audio* Audio::instance = nullptr;
Audio* Audio::GetInstance()
{
	if (instance == nullptr)
	{
		instance = new Audio();
	}
	return instance;
}

void Audio::DeleteInstance()
{
	if (instance != nullptr)
	{
		delete instance;
		instance = nullptr;
	}
}

void Audio::Initialize()
{
	HRESULT hr;
	hr = XAudio2Create(&xaudio2_, 0, XAUDIO2_DEFAULT_PROCESSOR);
	hr = xaudio2_->CreateMasteringVoice(&masterVoice);
}

SoundData Audio::LoadWave(const char* filename)
{
    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‹ã
    std::ifstream file(filename, std::ios_base::binary);
    // ãƒ•ã‚¡ã‚¤ãƒ«ãŒé–‹ã‘ãªã‹ã£ãŸã‚‰æ¤œå‡º
    assert(file.is_open());
    // RIFFãƒ˜ãƒƒãƒ€ãƒ¼ã‚’èª­ã¿è¾¼ã‚€
    RIFFHeader riff;
    file.read((char*)&riff, sizeof(riff));
    // ãƒ•ã‚¡ã‚¤ãƒ«ãŒRIFFã‹ãƒã‚§ãƒƒã‚¯
    assert(strncmp(riff.chunk.chunkID, "RIFF", 4) == 0);
    // ã‚¿ã‚¤ãƒ—ãŒWAVEã‹ãƒã‚§ãƒƒã‚¯
    assert(strncmp(riff.type, "WAVE", 4) == 0);

    // ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆãƒãƒ£ãƒ³ã‚¯ã‚’èª­ã¿è¾¼ã‚€
    FormartChunk fmt;
    file.read((char*)&fmt, sizeof(ChunkHeader));
    assert(strncmp(fmt.chunk.chunkID, "fmt ", 4) == 0);
    // ãƒãƒ£ãƒ³ã‚¯æœ¬ä½“ã®èª­ã¿è¾¼ã¿
    assert(fmt.chunk.chunkSize <= sizeof(fmt.format));
    file.read((char*)&fmt.format, fmt.chunk.chunkSize);

    // ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒ³ã‚¯ã‚’æ¢ã—ã¦èª­ã¿è¾¼ã‚€
    ChunkHeader data;
    while (file.read((char*)&data, sizeof(data)))
    {
        if (strncmp(data.chunkID, "data", 4) == 0)
        {
            break;
        }
        // èª­ã¿å–ã‚Šä½ç½®ã‚’æ¬¡ã®ãƒãƒ£ãƒ³ã‚¯ã«ç§»å‹•
        file.seekg(data.chunkSize, std::ios_base::cur);
    }
    assert(strncmp(data.chunkID, "data", 4) == 0);

    // ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒ³ã‚¯ã®ãƒ‡ãƒ¼ã‚¿éƒ¨ã®èª­ã¿è¾¼ã¿
    char* pBuffer = new char[data.chunkSize];
    file.read(pBuffer, data.chunkSize);

    // ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é–‰ã˜ã‚‹
    file.close();

    // ãƒ‡ãƒ¼ã‚¿ã®è¨­å®š
    SoundData soundData;
    soundData.wfex = fmt.format;
    soundData.pBuffer = reinterpret_cast<BYTE*>(pBuffer);
    soundData.bufferSize = data.chunkSize;

    return soundData;
}


void Audio::SoundUnload(SoundData* soundData)
{
	// ãƒãƒƒãƒ•ã‚¡ã®è§£æ”¾
	delete[] soundData->pBuffer;
	soundData->pBuffer = 0;
	soundData->bufferSize = 0;
	soundData->wfex = {};

}

void Audio::SoundPlayWave(IXAudio2* xAudio2, const SoundData& soundData)
{
	HRESULT hr;
	// ã‚½ãƒ¼ã‚¹ãƒœã‚¤ã‚¹ã®ä½œæˆ
	IXAudio2SourceVoice* sourceVoice = nullptr;
	hr = xAudio2->CreateSourceVoice(&sourceVoice, reinterpret_cast<const WAVEFORMATEX*>(&soundData.wfex));
	assert(SUCCEEDED(hr));
	

	// å†ç”Ÿã™ã‚‹ãƒ‡ãƒ¼ã‚¿ã®è¨­å®š
	XAUDIO2_BUFFER buffer = {};
	buffer.AudioBytes = soundData.bufferSize;
	buffer.pAudioData = soundData.pBuffer;
	buffer.Flags = XAUDIO2_END_OF_STREAM;
		
	// å†ç”Ÿ
	hr = sourceVoice->SubmitSourceBuffer(&buffer);
	hr = sourceVoice->Start();
}



============================================================
File Path: engine/Audio/Audio.h
============================================================
#pragma once
#include <xaudio2.h>
#pragma comment(lib, "xaudio2.lib")
#include <fstream>
#include <wrl.h>

/// <summary>
/// ã‚µã‚¦ãƒ³ãƒ‰ç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
/// <remarks>
/// XAudio2ã‚’ç”¨ã„ã¦ã‚µã‚¦ãƒ³ãƒ‰ã‚’ç®¡ç†ã™ã‚‹ã‚¯ãƒ©ã‚¹
/// </remarks>


struct ChunkHeader
{
	char chunkID[4];
	uint32_t chunkSize;
};
struct RIFFHeader
{
	ChunkHeader chunk;
	char type[4];
};
struct FormartChunk {
	ChunkHeader chunk;
	WAVEFORMATEX format;
};
struct SoundData {
	// æ³¢å½¢ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	WAVEFORMATEX wfex;
	// ãƒãƒƒãƒ•ã‚¡ã®å…ˆé ­ã‚¢ãƒ‰ãƒ¬ã‚¹
	BYTE* pBuffer;
	// ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚º
	unsigned int bufferSize;
};
class Audio
{
public:
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	static Audio* GetInstance();
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å‰Šé™¤
	/// </summary>
	static void DeleteInstance();
	
private:
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	/// </summary>
	static Audio* instance;
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	Audio() = default;
	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~Audio() = default;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ä»£å…¥æ¼”ç®—å­ã®ç¦æ­¢
	/// </summary>
	Audio(Audio&) = delete;
	/// <summary>
	/// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ä»£å…¥æ¼”ç®—å­ã®ç¦æ­¢
	/// </summary>
	Audio& operator=(Audio&) = delete;


public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();
	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰ã®èª­ã¿è¾¼ã¿
	/// </summary>
	SoundData LoadWave(const char* filename);
	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰ã®è§£æ”¾
	///ã€€</summary>
	void SoundUnload(SoundData* soundData);
	/// <summary>
	/// ã‚µã‚¦ãƒ³ãƒ‰ã®å†ç”Ÿ
	///ã€€</summary>
	void SoundPlayWave(IXAudio2* xAudio2, const SoundData& soundData);

public:
	/// <summary>
	/// XAudio2ã®å–å¾—
	/// </summary>
	IXAudio2* GetXAudio2() const { return xaudio2_.Get(); }

private:
	/// XAudio2
	Microsoft::WRL::ComPtr<IXAudio2> xaudio2_;
	// â†“ã®å‹ã«ã¯Release()ãŒç„¡ã„ã®ã§ã€ComPtrã‚’ä½¿ã‚ãªã„
	IXAudio2MasteringVoice* masterVoice;
};


============================================================
File Path: engine/base/D3DResourceLeakChecker.cpp
============================================================
#include "D3DResourceLeakChecker.h"
#include <dxgidebug.h>
#include <d3d12.h>
#include <dxgi1_6.h>
#include <wrl.h>

D3DResourceLeakChecker::~D3DResourceLeakChecker() {

	//ãƒªã‚½ãƒ¼ã‚¹ãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚¯
	Microsoft::WRL::ComPtr<IDXGIDebug1> debug;
	if (SUCCEEDED(DXGIGetDebugInterface1(0, IID_PPV_ARGS(&debug)))) {
		debug->ReportLiveObjects(DXGI_DEBUG_ALL, DXGI_DEBUG_RLO_ALL);
		debug->ReportLiveObjects(DXGI_DEBUG_APP, DXGI_DEBUG_RLO_ALL);
		debug->ReportLiveObjects(DXGI_DEBUG_D3D12, DXGI_DEBUG_RLO_ALL);
	}
}

============================================================
File Path: engine/base/D3DResourceLeakChecker.h
============================================================
#pragma once

/// <summary>
/// D3Dãƒªã‚½ãƒ¼ã‚¹ãƒªãƒ¼ã‚¯ãƒã‚§ãƒƒã‚«ãƒ¼
/// </summary>
/// <remarks>
/// D3Dãƒªã‚½ãƒ¼ã‚¹ã®ãƒªãƒ¼ã‚¯ã‚’æ¤œå‡ºã™ã‚‹
/// </remarks>
class D3DResourceLeakChecker
{
public:

	/// <summary>
	/// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	~D3DResourceLeakChecker();


};



============================================================
File Path: engine/base/DirectXCommon.cpp
============================================================
#include "DirectXCommon.h"
#include <cassert>
#include <format>
#include <string>
#include <thread>
#include "Logger.h"
#include "StringUtility.h"
#ifdef USE_IMGUI
#include "externals/imgui/imgui.h"
#include "externals/imgui/imgui_impl_dx12.h"
#include "externals/imgui/imgui_impl_win32.h"
#endif

#pragma comment(lib,"d3d12.lib")
#pragma comment(lib,"dxgi.lib")
#pragma comment(lib,"dxcompiler.lib")
#pragma comment(lib,"dxguid.lib")

using namespace Microsoft::WRL;
using namespace Logger;




DirectXCommon::DirectXCommon()
{
}
void DirectXCommon::Initialize(WinAPI* winAPI)
{
	// NULLæ¤œå‡º
	assert(winAPI);
	// FPSå›ºå®šåˆæœŸåŒ–
	InitializeFixFPS();

	//å€Ÿã‚Šã¦ããŸWinAPIã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¨˜éŒ²
	this->winAPI_ = winAPI;
	//ãƒ‡ãƒã‚¤ã‚¹ã®ç”Ÿæˆ
	InitDevice();
	//ã‚³ãƒãƒ³ãƒ‰é–¢é€£ã®åˆæœŸåŒ–
	InitCommand();
	//ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³ã®ç”Ÿæˆ
	CreateSwapChain();
	//å„ç¨®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	CreateDescriptorHeaps();
	//ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
	InitRenderTargetView();
	//æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
	InitDepthStencilView();
	//ãƒ•ã‚§ãƒ³ã‚¹ã®åˆæœŸåŒ–
	InitFence();
	//ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆçŸ©å½¢ã®åˆæœŸåŒ–
	InitViewportRect();
	//ã‚·ã‚¶ãƒªãƒ³ã‚°çŸ©å½¢ã®åˆæœŸåŒ–
	InitScissorRect();
	// imguiã®åˆæœŸåŒ–
	//InitImGui();

	//DXCã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ç”Ÿæˆ
	CreateDXCCompiler();


}

void DirectXCommon::InitCommand()
{
#pragma region commandAllocator
	//ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã‚’èµ·å‹•ã™ã‚‹
	HRESULT hr = device->CreateCommandAllocator(D3D12_COMMAND_LIST_TYPE_DIRECT, IID_PPV_ARGS(&commandAllocator));
	//ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã®ç”ŸæˆãŒä¸Šæ‰‹ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region CommandList
	hr = device->CreateCommandList(0, D3D12_COMMAND_LIST_TYPE_DIRECT, commandAllocator.Get(), nullptr, IID_PPV_ARGS(commandList.GetAddressOf()));
	//ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ç”ŸæˆãŒä¸Šæ‰‹ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region CommandQueue
	//ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã‚’ç”Ÿæˆã™ã‚‹
	D3D12_COMMAND_QUEUE_DESC commandQueueDesc{};
	hr = device->CreateCommandQueue(&commandQueueDesc, IID_PPV_ARGS(&commandQueue));
	//ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã®ç”ŸæˆãŒä¸Šæ‰‹ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
#pragma endregion
}

void DirectXCommon::InitDevice()
{
	HRESULT hr;

#pragma region ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚ªãƒ³
	Microsoft::WRL::ComPtr < ID3D12Debug1> debugController = nullptr;
	if (SUCCEEDED(D3D12GetDebugInterface(IID_PPV_ARGS(&debugController)))) {
		debugController->EnableDebugLayer();
		debugController->SetEnableGPUBasedValidation(TRUE);
	}
#pragma endregion
#pragma region DXGIFactoryã®ç”Ÿæˆ
	//DXGIãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼ã®ç”Ÿæˆ

	//HRESULTã¯Windowsç³»ã®ã‚¨ãƒ©ãƒ¼ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚Š
	//é–¢æ•°ãŒæˆåŠŸã—ãŸã‹å‹•ã‹ã‚’SUCCEEDEDãƒã‚¯ãƒ­åˆ¤å®šã§ãã‚‹
	hr = CreateDXGIFactory(IID_PPV_ARGS(&dxgiFactory));//IID_PPV_ARGSã¯å¼•æ•°ã‚’ä¸€ã¤ã«ã—ã¦ãã‚Œã‚‹ãŠã¾ã˜ãªã„
	//åˆæœŸåŒ–ã®æ ¹æœ¬çš„ãªéƒ¨åˆ†ã§ã‚¨ãƒ©ãƒ¼ãŒå‡ºãŸå ´åˆã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ ãŒé–“é•ã£ã¦ã„ã‚‹ã‹ã€
	//ã©ã†ã«ã‚‚ã§ããªã„å ´åˆãŒå¤šã„ã®ã§assertã«ã—ã¦ãŠã
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼
	Microsoft::WRL::ComPtr<IDXGIAdapter4> useAdapter = nullptr;
	//è‰¯ã„é †ã«ã‚¢ãƒ€ãƒ—ã‚¿ã‚’é ¼ã‚€
	for (UINT i = 0; dxgiFactory->EnumAdapterByGpuPreference(i,
		DXGI_GPU_PREFERENCE_HIGH_PERFORMANCE, IID_PPV_ARGS(useAdapter.GetAddressOf())) !=
		DXGI_ERROR_NOT_FOUND; ++i) {
		//ã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã®æƒ…å ±ã‚’å–å¾—ã™ã‚‹
		DXGI_ADAPTER_DESC3 adapterDesc{};
		hr = useAdapter->GetDesc3(&adapterDesc);
		assert(SUCCEEDED(hr));//å–å¾—ã§ããªã„ã®ã¯ä¸€å¤§äº‹
		//ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¢ãƒ€ãƒ—ã‚¿ã§ç„¡ã‘ã‚Œã°æ¡ç”¨
		if (!(adapterDesc.Flags & DXGI_ADAPTER_FLAG3_SOFTWARE)) {
			//æ¡ç”¨ã—ãŸã‚¢ãƒ€ãƒ—ã‚¿ã‚ã®æƒ…å ±ã‚’ãƒ­ã‚°ã«å‡ºåŠ› wstringãªã®ã§æ³¨æ„
			Log(StringUtility::ConvertString(std::format(L"Use Adapter:{}\n", adapterDesc.Description)));
			break;
		}
		useAdapter.Reset();//ã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢ã‚¢ãƒ€ãƒ—ã‚¿ã®å ´åˆã¯è¦³ãªã‹ã£ãŸã“ã¨ã«ã™ã‚‹
	}
	assert(useAdapter != nullptr);//é©åˆ‡ãªã‚¢ãƒ€ãƒ—ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã‹ã£ãŸã‚‰èµ·å‹•ã§ããªã„

#pragma endregion
#pragma region Deviceã®ç”Ÿæˆ
	_putenv("D3D12_ENABLE_LEAK_TRACKING=1");
	//æ©Ÿèƒ½ãƒ¬ãƒ™ãƒ«ã¨ãƒ­ã‚°å‡ºåŠ›ç”¨ã®æ–‡å­—åˆ—
	D3D_FEATURE_LEVEL featureLevels[] = {
		D3D_FEATURE_LEVEL_12_2,D3D_FEATURE_LEVEL_12_1,D3D_FEATURE_LEVEL_12_0
	};
	const char* featureLevelStrings[] = { "12.2","12.1","12.0" };
	//é«˜ã„é †ã«ç”Ÿæˆã§ãã‚‹ã‹è©¦ã—ã¦ã„ã
	for (size_t i = 0; i < _countof(featureLevels); ++i) {
		//æ¡ç”¨ã—ãŸã‚¢ãƒ€ãƒ—ã‚¿ãƒ¼ã§ãƒ‡ãƒã‚¤ã‚¹ã‚’ç”Ÿæˆ
		hr = D3D12CreateDevice(useAdapter.Get(),
			featureLevels[i],
			IID_PPV_ARGS(&device));
		//æŒ‡å®šã—ãŸæ©Ÿèƒ½ãƒ¬ãƒ™ãƒ«ã§ãƒ‡ãƒã‚¤ã‚¹ãŒç”Ÿæˆã•ã‚ŒãŸã‹ã‚’ç¢ºèª
		if (SUCCEEDED(hr)) {
			//ç”Ÿæˆã§ããŸã®ã§ãƒ­ã‚°å‡ºåŠ›ã‚’è¡Œã£ã¦ãƒ«ãƒ¼ãƒ—ã‚’æŠœã‘ã‚‹
			Log(std::format("FeatureLevels : {}\n", featureLevelStrings[i]));
			break;
		}
	}
	//ãƒ‡ãƒã‚¤ã‚¹ã®ç”ŸæˆãŒä¸Šæ‰‹ãã„ã‹ãªã‹ã£ãŸã®ã§ç”Ÿæˆã§ããªã„
	assert(device != nullptr);
	Log("Complete create D3D12Device!!!\n");


#pragma endregion
#pragma region ã‚¨ãƒ©ãƒ¼æ™‚ã«ãƒ–ãƒ¬ã‚¤ã‚¯
#ifdef _DEBUG // ã‚¨ãƒ©ãƒ¼æ™‚ã«ãƒ–ãƒ¬ãƒ¼ã‚¯ã‚’ç™ºç”Ÿã•ã›ã‚‹è¨­å®š
	Microsoft::WRL::ComPtr<ID3D12InfoQueue> infoQueue;
	if (SUCCEEDED(device.As(&infoQueue))) {
		//ã‚„ã°ã„ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_CORRUPTION, true);
		//ã‚¨ãƒ©ãƒ¼æ™‚ã«æ­¢ã¾ã‚‹
		infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_ERROR, true);
		//è­¦å‘Šæ™‚ã«æ­¢ã¾ã‚‹
		//infoQueue->SetBreakOnSeverity(D3D12_MESSAGE_SEVERITY_WARNING, true);
		D3D12_MESSAGE_ID denyIds[] = {
			//
			D3D12_MESSAGE_ID_RESOURCE_BARRIER_INVALID_COMMAND_LIST_TYPE
		};
		//Windows11ã§ã®DXGIãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨DX12ãƒ‡ãƒãƒƒã‚°ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›¸äº’ä½œç”¨ãƒã‚°ã«ã‚ˆã‚‹ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
		D3D12_MESSAGE_SEVERITY severities[] = { D3D12_MESSAGE_SEVERITY_INFO };
		D3D12_INFO_QUEUE_FILTER filter{};
		filter.DenyList.NumIDs = _countof(denyIds);
		filter.DenyList.pIDList = denyIds;
		filter.DenyList.NumSeverities = _countof(severities);
		filter.DenyList.pSeverityList = severities;
		//æŠ‘åˆ¶ã™ã‚‹ãƒ¬ãƒ™ãƒ«
		infoQueue->PushStorageFilter(&filter);
	}
#endif  _DEBUG
#pragma endregion



}

void DirectXCommon::CreateSwapChain()
{
#pragma region ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³ã®ç”Ÿæˆ
	swapChainDesc.Width = WinAPI::kClientWidth;		//ç”»é¢ã®å¹…ã€€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’åŒã˜ã‚‚ã®ã«ã—ã¦ãŠã
	swapChainDesc.Height = WinAPI::kClientHeight;	//ç”»é¢ã®é«˜ã•ã€€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆç”ºåŸŸã‚’åŒã˜ã‚‚ã®ã«ã—ã¦ãŠã
	swapChainDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;//
	swapChainDesc.SampleDesc.Count = 1;//è‰²ã®å½¢å¼
	swapChainDesc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;//ãƒãƒ«ãƒã‚µãƒ³ãƒ—ãƒ«ã—ãªã„
	swapChainDesc.BufferCount = 2;//ãƒ€ãƒ–ãƒ«ãƒãƒƒãƒ•ã‚¡
	swapChainDesc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;//ãƒ¢ãƒ‹ã‚¿ã«å†™ã—ãŸã‚‰ä¸­èº«ã‚’ç ´å£Š
	//ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼ã€ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«ã€è¨­å®šã‚’æ¸¡ã—ã¦ç”Ÿæˆã™ã‚‹
	HRESULT hr = dxgiFactory->CreateSwapChainForHwnd(commandQueue.Get(), winAPI_->GetHwnd(), &swapChainDesc, nullptr, nullptr, reinterpret_cast<IDXGISwapChain1**>(swapChain.GetAddressOf()));
	//ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ãƒ¼ãƒ³ã®ç”ŸæˆãŒä¸Šæ‰‹ãã„ã‹ãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
#pragma endregion


}

Microsoft::WRL::ComPtr<ID3D12Resource> DirectXCommon::CreateDepthBuffer(Microsoft::WRL::ComPtr<ID3D12Device> device, int32_t width, int32_t height)
{
	// ç”Ÿæˆã™ã‚‹Resourceã®è¨­å®š
	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Width = width;										// Textureã®ã¯å¹…
	resourceDesc.Height = height;									// Textureã®é«˜ã•
	resourceDesc.MipLevels = 1;										// mipmapã®æ•°
	resourceDesc.DepthOrArraySize = 1;								//å¥¥è¡Œã or é…åˆ—Textureã®é…åˆ—æ•°
	resourceDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;			// Depthstencilã¨ã—ã¦åˆ©ç”¨å¯èƒ½ãªãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
	resourceDesc.SampleDesc.Count = 1;								//ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚«ã‚¦ãƒ³ãƒˆã€‚1å›ºå®šã€‚
	resourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_TEXTURE2D;
	//2æ¬¡å…ƒ
	resourceDesc.Flags = D3D12_RESOURCE_FLAG_ALLOW_DEPTH_STENCIL;	// DepthStencilã¨ã—ã¦ä½¿ã†é€šçŸ¥
	//.åˆ©ç”¨ã™ã‚‹Heapã®è¨­å®š
	D3D12_HEAP_PROPERTIES heapProperties{};
	heapProperties.Type = D3D12_HEAP_TYPE_DEFAULT;					// VRAMä¸Šã«ä½œã‚‹

	// æ·±åº¦å€¤ã®ã‚¯ãƒªã‚¢è¨­å®š
	D3D12_CLEAR_VALUE depthClearValue{};
	depthClearValue.DepthStencil.Depth = 1.0f;						// 1.0f (æœ€å¤§å€¤)ã€€ã§ã‚¯ãƒªã‚¢
	depthClearValue.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;			// ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã€‚Resourceã¨åˆã‚ã›ã‚‹

	// Resourceã®ç”Ÿæˆ

	HRESULT hr = device->CreateCommittedResource(
		&heapProperties, // Heapã®è¨­å®š
		D3D12_HEAP_FLAG_NONE,//Heapã®ç‰¹æ®Šãªè¨­å®šã€‚ç‰¹ã«ãªã—ã€‚
		&resourceDesc,// Resourceã®è¨­å®š
		D3D12_RESOURCE_STATE_DEPTH_WRITE,//æ·±åº¦å€¤ã‚’æ›¸ãè¾¼ã‚€çŠ¶æ…‹ã«ã—ã¦ãŠã
		&depthClearValue,// clearæœ€é©å€¤
		IID_PPV_ARGS(&resource));//ä½œæˆã™ã‚‹Resourceãƒã‚¤ãƒ³ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	assert(SUCCEEDED(hr));

	return resource;
}
ComPtr <ID3D12DescriptorHeap>
DirectXCommon::CreateDescriptorHeap(
	D3D12_DESCRIPTOR_HEAP_TYPE heapType,
	UINT numDescriptors,
	bool shaderVisible)
{
	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> descriptorHeap;
	D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDesc{};
	descriptorHeapDesc.Type = heapType;//ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼
	descriptorHeapDesc.NumDescriptors = numDescriptors;//ãƒ€ãƒ–ãƒ«ãƒãƒƒãƒ•ã‚¡ç”¨ã«ï¼’ã¤ã€‚å¤šãã¦ã‚‚ã‹ã¾ã‚ãªã„
	descriptorHeapDesc.Flags = shaderVisible ? D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE : D3D12_DESCRIPTOR_HEAP_FLAG_NONE;
	HRESULT hr = device->CreateDescriptorHeap(&descriptorHeapDesc, IID_PPV_ARGS(&descriptorHeap));//
	//ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ãŒã¤ãã‚Œãªã‹ã£ãŸã®ã§èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
	return descriptorHeap;
}

void DirectXCommon::CreateDescriptorHeaps()
{
	//descriptorSizeSRV = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);
	descriptorSizeRTV = device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
	//dsv
#pragma region DescriptorHEAPã®ç”Ÿæˆ
	rtvDescriptorHeap = CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_RTV, 2, false);
	//srvDescriptorHeap = CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, kMaxSRVCount, true);
	// DSVç”¨ã®ãƒ’ãƒ¼ãƒ—ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®æ•°ã¯ï¼‘ã€‚DSVã¯Shaderå†…ã§è§¦ã‚‹ã‚‚ã®ã§ã¯ãªã„ã®ã§ã€ShaderVisibleã¯false
	dsvDescriptorHeap = CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_DSV, 1, false);
#pragma endregion

}

void DirectXCommon::InitRenderTargetView()
{
	//ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³ã‹ã‚‰ãƒªã‚½ãƒ¼ã‚¹ã‚’å¼•ã£å¼µã£ã¦ãã‚‹
	HRESULT hr = swapChain->GetBuffer(0, IID_PPV_ARGS(&swapChainResources[0]));
	//ä¸Šæ‰‹ãå–å¾—ã§ããªã‘ã‚Œã°èµ·å‹•ã§ããªã„
	assert(SUCCEEDED(hr));
	hr = swapChain->GetBuffer(1, IID_PPV_ARGS(&swapChainResources[1]));
	assert(SUCCEEDED(hr));


	rtvDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM_SRGB;
	rtvDesc.ViewDimension = D3D12_RTV_DIMENSION_TEXTURE2D;

	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã®å…ˆé ­ã‚’å–å¾—ã™ã‚‹
	D3D12_CPU_DESCRIPTOR_HANDLE rtvStartHandle = rtvDescriptorHeap->GetCPUDescriptorHandleForHeapStart();


	for (uint32_t i = 0; i < 2; ++i) {
		rtvHandles[i] = rtvStartHandle;

		device->CreateRenderTargetView(swapChainResources[i].Get(), &rtvDesc, rtvHandles[i]);
		rtvStartHandle.ptr += device->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_RTV);
	}
}

D3D12_CPU_DESCRIPTOR_HANDLE DirectXCommon::GetCPUDescriptorHandle(const Microsoft::WRL::ComPtr<ID3D12DescriptorHeap>& descriptorHeap, uint32_t descriptorSize, uint32_t index)
{
	D3D12_CPU_DESCRIPTOR_HANDLE handleCPU = descriptorHeap->GetCPUDescriptorHandleForHeapStart();
	handleCPU.ptr += (descriptorSize * index);
	return handleCPU;
}
D3D12_GPU_DESCRIPTOR_HANDLE DirectXCommon::GetGPUDescriptorHandle(const Microsoft::WRL::ComPtr<ID3D12DescriptorHeap>& descriptorHeap, uint32_t descriptorSize, uint32_t index)
{
	D3D12_GPU_DESCRIPTOR_HANDLE handleGPU = descriptorHeap->GetGPUDescriptorHandleForHeapStart();
	handleGPU.ptr += (descriptorSize * index);
	return handleGPU;
}



void DirectXCommon::PreDraw()
{
#pragma region ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ç•ªå·å–å¾—
	// ã“ã“ã‹ã‚‰æ›¸ãè¾¼ã‚€ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
	backBufferIndex = swapChain->GetCurrentBackBufferIndex();
#pragma endregion

#pragma region ãƒªã‚½ãƒ¼ã‚¹ãƒãƒªã‚¢ã®è¨­å®š

	// ä»Šå›ã®ãƒãƒªã‚¢ã¯ Transition
	barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	// Noneã«ã—ã¦ãŠã
	barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	// ãƒãƒªã‚¢ã‚’å¼µã‚‹å¯¾è±¡ã®ãƒªã‚½ãƒ¼ã‚¹ã€‚ç¾åœ¨ã®ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã«å¯¾ã—ã¦è¡Œã†
	barrier.Transition.pResource = swapChainResources[backBufferIndex].Get();
	// é·ç§»å‰ï¼ˆç¾åœ¨ï¼‰ã® ResourceStart
	barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_PRESENT;
	// é·ç§»å¾Œã® ResourceStart
	barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_RENDER_TARGET;
	// TransitionBarrier ã‚’å¼µã‚‹
	commandList->ResourceBarrier(1, &barrier);
#pragma endregion 

#pragma region RTVã¨DSVã®è¨­å®š
	// æç”»å…ˆã®RTVã¨DSVã‚’æŒ‡å®šã™ã‚‹
	D3D12_CPU_DESCRIPTOR_HANDLE dsvHandle = dsvDescriptorHeap->GetCPUDescriptorHandleForHeapStart();

	commandList->OMSetRenderTargets(1, &rtvHandles[backBufferIndex], false, &dsvHandle);
#pragma endregion

#pragma region ç”»é¢å…¨ä½“ã®æ·±åº¦ã‚’ã‚¯ãƒªã‚¢
	// æŒ‡å®šã—ãŸæ·±åº¦ã§ç”»é¢å…¨ä½“ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹
	commandList->ClearDepthStencilView(dsvHandle, D3D12_CLEAR_FLAG_DEPTH, 1.0f, 0, 0, nullptr);
#pragma endregion

#pragma region ç”»é¢å…¨ä½“ã®è‰²ã‚’ã‚¯ãƒªã‚¢
	// æŒ‡å®šã—ãŸè‰²ã§ç”»é¢å…¨ä½“ã‚’ã‚¯ãƒªã‚¢ã™ã‚‹
	float clearColor[] = { 0.1f, 0.25f, 0.5f, 1.0f };  // é’ã£ã½ã„è‰²ã€‚RGBAã®é †
	commandList->ClearRenderTargetView(rtvHandles[backBufferIndex], clearColor, 0, nullptr);
#pragma endregion

#pragma region ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆé ˜åŸŸã®è¨­å®š
	commandList->RSSetViewports(1, &viewport);			// Viewportã‚’è¨­å®š
#pragma endregion

#pragma region ã‚·ã‚¶ãƒ¼çŸ©å½¢ã®è¨­å®š
	commandList->RSSetScissorRects(1, &scissorRect);	// Scissorã‚’è¨­å®š
#pragma endregion
}

void DirectXCommon::PostDraw()
{
	backBufferIndex = swapChain->GetCurrentBackBufferIndex();
#pragma region ãƒªã‚½ãƒ¼ã‚¹ãƒãƒªã‚¢ã§è¡¨ç¤ºå½¢æ…‹ã«å¤‰æ›´
	// ç”»é¢ã«æãå‡¦ç†ã¯ã™ã¹ã¦çµ‚ã‚ã‚Šã€ç”»é¢ã«æ˜ ã™ã®ã§ã€çŠ¶æ…‹ã‚’é·ç§»
		// ä»Šå›ã¯ RenderTarget ã‹ã‚‰ Present ã«ã™ã‚‹
	barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_RENDER_TARGET;
	barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_PRESENT;
	// TransitionBarrier ã‚’ã¯å¼µã‚‹
	commandList->ResourceBarrier(1, &barrier);
#pragma endregion
#pragma region ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚³ãƒãƒ³ãƒ‰ã‚’ã‚¯ãƒ­ãƒ¼ã‚º
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å†…å®¹ã‚’ç¢ºå®šã•ã›ã‚‹ã€‚ã™ã¹ã¦ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚“ã§ã‹ã‚‰ Close ã™ã‚‹ã“ã¨
	HRESULT hr = commandList->Close();
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region GPUã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œ
	//GPUã«ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å®Ÿè¡Œã‚’è¡Œã‚ã›ã‚‹
	ID3D12CommandList* commandLists[] = { commandList.Get() };
	commandQueue->ExecuteCommandLists(1, commandLists);
#pragma endregion
#pragma region GPUç”»é¢ã®äº¤æ›ã‚’é€šçŸ¥
	//GPUã¨OSã«ç”»é¢ã®äº¤æ¸‰ã‚’è¡Œã†ã‚ˆã†ã«é€šçŸ¥ã™ã‚‹
	swapChain->Present(1, 0);
#pragma endregion
#pragma region Fenceã®å€¤ã‚’æ›´æ–°
	//Fenceã®å€¤ã‚’æ›´æ–°
	fenceValue++;
	//GPUãŒã“ã“ã¾ã§ãŸã©ã‚Šç€ã„ãŸæ™‚ã«ã€Fenceã®å€¤ã‚’æŒ‡å®šã—ãŸå€¤ã«ä»£å…¥ã™ã‚‹ã‚ˆã†ã«Signalã‚’é€ã‚‹
	commandQueue->Signal(fence.Get(), fenceValue);
#pragma endregion
#pragma region ã‚³ãƒãƒ³ãƒ‰å®Œäº†å¾…ã¡
	// Fenceã®å€¤ãŒæŒ‡å®šã—ãŸSignalå€¤ã«ãŸã©ã‚Šç€ã„ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹
		//GetCompletedValueã®åˆæœŸå€¤ã¯Fenceä½œæˆæ™‚ã«æ¸¡ã—ãŸåˆæœŸå€¤
	if (fence->GetCompletedValue() < fenceValue) {
		//æŒ‡å®šã—ãŸSignalã«ãŸã©ã‚Šç€ã„ã¦ã„ãªã„ã®ã§ã€ãŸã©ã‚Šç€ãã¾ã§å¾…ã¤ã‚ˆã†ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®šã™ã‚‹
		fence->SetEventOnCompletion(fenceValue, fenceEvent);
		//ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¾…ã¤
		WaitForSingleObject(fenceEvent, INFINITE);
	}
#pragma endregion

	// FPSå›ºå®š
	UpdateFixFPS();

#pragma region ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã®ãƒªã‚»ãƒƒãƒˆ
	//æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ç”¨ã®ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’æº–å‚™
	hr = commandAllocator->Reset();
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒªã‚»ãƒƒãƒˆ
	hr = commandList->Reset(commandAllocator.Get(), nullptr);
	assert(SUCCEEDED(hr));
#pragma endregion



}

void DirectXCommon::WaitCommand()
{

#pragma region ã‚°ãƒ©ãƒ•ã‚£ãƒƒã‚¯ã‚³ãƒãƒ³ãƒ‰ã‚’ã‚¯ãƒ­ãƒ¼ã‚º
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å†…å®¹ã‚’ç¢ºå®šã•ã›ã‚‹ã€‚ã™ã¹ã¦ã®ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚“ã§ã‹ã‚‰ Close ã™ã‚‹ã“ã¨
	HRESULT hr = commandList->Close();
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region GPUã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œ
	//GPUã«ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®å®Ÿè¡Œã‚’è¡Œã‚ã›ã‚‹
	ID3D12CommandList* commandLists[] = { commandList.Get() };
	commandQueue->ExecuteCommandLists(1, commandLists);
#pragma endregion

#pragma region Fenceã®å€¤ã‚’æ›´æ–°
	//Fenceã®å€¤ã‚’æ›´æ–°
	fenceValue++;
	//GPUãŒã“ã“ã¾ã§ãŸã©ã‚Šç€ã„ãŸæ™‚ã«ã€Fenceã®å€¤ã‚’æŒ‡å®šã—ãŸå€¤ã«ä»£å…¥ã™ã‚‹ã‚ˆã†ã«Signalã‚’é€ã‚‹
	commandQueue->Signal(fence.Get(), fenceValue);
#pragma endregion
#pragma region ã‚³ãƒãƒ³ãƒ‰å®Œäº†å¾…ã¡
	// Fenceã®å€¤ãŒæŒ‡å®šã—ãŸSignalå€¤ã«ãŸã©ã‚Šç€ã„ã¦ã„ã‚‹ã‹ç¢ºèªã™ã‚‹
		//GetCompletedValueã®åˆæœŸå€¤ã¯Fenceä½œæˆæ™‚ã«æ¸¡ã—ãŸåˆæœŸå€¤
	if (fence->GetCompletedValue() < fenceValue) {
		//æŒ‡å®šã—ãŸSignalã«ãŸã©ã‚Šç€ã„ã¦ã„ãªã„ã®ã§ã€ãŸã©ã‚Šç€ãã¾ã§å¾…ã¤ã‚ˆã†ã«ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¨­å®šã™ã‚‹
		fence->SetEventOnCompletion(fenceValue, fenceEvent);
		//ã‚¤ãƒ™ãƒ³ãƒˆã‚’å¾…ã¤
		WaitForSingleObject(fenceEvent, INFINITE);
	}
#pragma endregion
#pragma region ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼ã®ãƒªã‚»ãƒƒãƒˆ
	//æ¬¡ã®ãƒ•ãƒ¬ãƒ¼ãƒ ç”¨ã®ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã‚’æº–å‚™
	hr = commandAllocator->Reset();
	assert(SUCCEEDED(hr));
#pragma endregion
#pragma region ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆã®ãƒªã‚»ãƒƒãƒˆ
	hr = commandList->Reset(commandAllocator.Get(), nullptr);
	assert(SUCCEEDED(hr));
#pragma endregion



}

//D3D12_CPU_DESCRIPTOR_HANDLE DirectXCommon::GetSRVCPUDescriptorHandle(uint32_t index)
//{
//	return GetCPUDescriptorHandle(srvDescriptorHeap, descriptorSizeSRV, index);
//}

//D3D12_GPU_DESCRIPTOR_HANDLE DirectXCommon::GetSRVGPUDescriptorHandle(uint32_t index)
//{
//	return GetGPUDescriptorHandle(srvDescriptorHeap, descriptorSizeSRV, index);
//}

void DirectXCommon::InitDepthStencilView()
{

	D3D12_DEPTH_STENCIL_VIEW_DESC dsvDesc{};
	dsvDesc.Format = DXGI_FORMAT_D24_UNORM_S8_UINT;//Format.åŸºæœ¬çš„ã«ã¯Resourceã«åˆã‚ã›ã‚‹
	dsvDesc.ViewDimension = D3D12_DSV_DIMENSION_TEXTURE2D;//2dTexture

	Microsoft::WRL::ComPtr <ID3D12Resource> depthStencilResource;
	depthStencilResource = CreateDepthBuffer(device, WinAPI::kClientWidth, WinAPI::kClientHeight);
	//DSVã®è¨­å®š									 

	//DSVHeapã®å…ˆé ­ã«DSVã‚’ã¤ãã‚‹
	device->CreateDepthStencilView(depthStencilResource.Get(), &dsvDesc, dsvDescriptorHeap->GetCPUDescriptorHandleForHeapStart());

}

void DirectXCommon::InitFence()
{
	HRESULT hr = device->CreateFence(fenceValue, D3D12_FENCE_FLAG_NONE, IID_PPV_ARGS(fence.GetAddressOf()));
	assert(SUCCEEDED(hr));


	assert(fenceEvent != nullptr);
}

void DirectXCommon::InitViewportRect()
{
	// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆçŸ©å½¢ã®è¨­å®š
	viewport.Width = WinAPI::kClientWidth;
	viewport.Height = WinAPI::kClientHeight;
	viewport.TopLeftX = 0.0f;
	viewport.TopLeftY = 0.0f;
	viewport.MinDepth = 0.0f;
	viewport.MaxDepth = 1.0f;
}

void DirectXCommon::InitScissorRect()
{

	scissorRect.left = 0;
	scissorRect.right = WinAPI::kClientWidth;
	scissorRect.top = 0;
	scissorRect.bottom = WinAPI::kClientHeight;
}

void DirectXCommon::CreateDXCCompiler()
{

	// DXCãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ã®ç”Ÿæˆ
	HRESULT hr = DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(dxcUtils.GetAddressOf()));
	assert(SUCCEEDED(hr));
	// DXCã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ç”Ÿæˆ
	hr = DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(dxcCompiler.GetAddressOf()));
	assert(SUCCEEDED(hr));

	// ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ãƒ©ã®ç”Ÿæˆ
	// ç¾æ™‚ç‚¹ã§includeã¯ã—ãªã„ãŒã€includeã«å¯¾å¿œã™ã‚‹ãŸã‚ã®è¨­å®šã‚’è¡Œã£ã¦ãŠã
	hr = dxcUtils->CreateDefaultIncludeHandler(includeHandler.GetAddressOf());
	assert(SUCCEEDED(hr));

}

void DirectXCommon::InitImGui()
{
	////Imguiã®åˆæœŸåŒ–
	//IMGUI_CHECKVERSION();
	//ImGui::CreateContext();
	//ImGui::StyleColorsDark();
	//ImGui_ImplWin32_Init(winAPI_->GetHwnd());
	//ImGui_ImplDX12_Init(device.Get(), swapChainDesc.BufferCount, rtvDesc.Format, srvDescriptorHeap.Get(),
	//	srvDescriptorHeap->GetCPUDescriptorHandleForHeapStart(), srvDescriptorHeap->GetGPUDescriptorHandleForHeapStart());


}


Microsoft::WRL::ComPtr<IDxcBlob> DirectXCommon::CompileShader(
	const std::wstring& filePath, const wchar_t* profile)
{
	// ã“ã‚Œã‹ã‚‰ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹æ—¨ã‚’ãƒ­ã‚°ã«å‡ºã™
	Log(ConvertString(std::format(L"Begin CompileShader, profile:{}\n", filePath, profile)));

	// hlslãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
	Microsoft::WRL::ComPtr<IDxcBlobEncoding> shaderSource = nullptr;
	HRESULT hr = dxcUtils->LoadFile(filePath.c_str(), nullptr, &shaderSource);
	// èª­ã‚ãªã‹ã£ãŸã‚‰æ­¢ã‚ã‚‹
	assert(SUCCEEDED(hr));

	// èª­ã¿è¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«ã®å†…å®¹ã‚’è¨­å®šã™ã‚‹
	DxcBuffer shaderSourceBuffer;
	shaderSourceBuffer.Ptr = shaderSource->GetBufferPointer();
	shaderSourceBuffer.Size = shaderSource->GetBufferSize();
	shaderSourceBuffer.Encoding = DXC_CP_UTF8; // UTFã®æ–‡å­—ã‚³ãƒ¼ãƒ‰ã§ã‚ã‚‹ã“ã¨ã‚’é€šçŸ¥

	LPCWSTR arguments[] = {
		filePath.c_str(), // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¯¾è±¡ã®hlslãƒ•ã‚¡ã‚¤ãƒ«å
		L"-E", L"main", // ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã®æŒ‡å®šã€‚åŸºæœ¬çš„ã«mainä»¥å¤–ã«ã¯ã—ãªã„
		L"-T", profile, // Shader Profileã®è¨­å®š
		L"-Zi", L"-Qembed_debug", // ãƒ‡ãƒãƒƒã‚°ç”¨ã®æƒ…å ±ã‚’åŸ‹ã‚è¾¼ã‚€
		L"-Od", // æœ€é©åŒ–ã‚’å¤–ã—ã¦ãŠã
		L"-Zpr", // ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã¯è¡Œå„ªå…ˆ
	};

	// å®Ÿéš›ã«Shaderã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã™ã‚‹
	Microsoft::WRL::ComPtr<IDxcResult> shaderResult = nullptr;
	hr = dxcCompiler->Compile(
		&shaderSourceBuffer, // èª­ã¿è¾¼ã‚“ã ãƒ•ã‚¡ã‚¤ãƒ«
		arguments, // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³
		_countof(arguments), // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚ªãƒ—ã‚·ãƒ§ãƒ³ã®æ•°
		includeHandler.Get(), // includeãŒå«ã¾ã‚ŒãŸè«¸ã€…
		IID_PPV_ARGS(&shaderResult) // ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«çµæœ
	);
	// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼ã§ã¯ãªãdxcãŒèµ·å‹•ã§ããªã„ãªã©è‡´å‘½çš„ãªçŠ¶æ³
	assert(SUCCEEDED(hr));

	Microsoft::WRL::ComPtr<IDxcBlobUtf8> shaderError = nullptr;
	shaderResult->GetOutput(DXC_OUT_ERRORS, IID_PPV_ARGS(&shaderError), nullptr);
	if (shaderError != nullptr && shaderError->GetStringLength() != 0) {
		Log(shaderError->GetStringPointer());
		assert(false);
	}

	Microsoft::WRL::ComPtr<IDxcBlob> shaderBlob = nullptr;
	hr = shaderResult->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&shaderBlob), nullptr);
	assert(SUCCEEDED(hr));

	return shaderBlob;
}




std::wstring DirectXCommon::ConvertString(const std::string& str)
{
	if (str.empty()) {
		return std::wstring();
	}

	auto sizeNeeded = MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), NULL, 0);
	if (sizeNeeded == 0) {
		return std::wstring();
	}
	std::wstring result(sizeNeeded, 0);
	MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), &result[0], sizeNeeded);
	return result;
}

std::string DirectXCommon::ConvertString(const std::wstring& str)
{
	if (str.empty()) {
		return std::string();
	}

	auto sizeNeeded = WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), NULL, 0, NULL, NULL);
	if (sizeNeeded == 0) {
		return std::string();
	}
	std::string result(sizeNeeded, 0);
	WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), result.data(), sizeNeeded, NULL, NULL);
	return result;
}

Microsoft::WRL::ComPtr<ID3D12Resource>
DirectXCommon::CreateBufferResource(size_t sizeInBytes)
{
	//é ‚ç‚¹ãƒªã‚½ãƒ¼ã‚¹ç”¨ã®ãƒ’ãƒ¼ãƒ—è¨­å®š
	D3D12_HEAP_PROPERTIES uploadHeapProperties{};
	uploadHeapProperties.Type = D3D12_HEAP_TYPE_UPLOAD;//
	//ã€€ãƒªã‚½ãƒ¼ã‚¹ã®è¨­å®š
	D3D12_RESOURCE_DESC vertexResourceDesc{};
	// ãƒªã‚½ãƒ¼ã‚¹ã®æ¬¡å…ƒã‚’ãƒãƒƒãƒ•ã‚¡ã«è¨­å®š
	vertexResourceDesc.Dimension = D3D12_RESOURCE_DIMENSION_BUFFER;
	// ãƒãƒƒãƒ•ã‚¡ã‚µã‚¤ã‚ºã®æŒ‡å®š
	vertexResourceDesc.Width = sizeInBytes;

	vertexResourceDesc.Height = 1;				// ãƒãƒƒãƒ•ã‚¡ã®ã‚µã‚¤ã‚ºã¯å¸¸ã«ï¼‘
	vertexResourceDesc.DepthOrArraySize = 1;	// æ·±ã•ã¾ãŸã¯é…åˆ—ã‚µã‚¤ã‚ºã®ï¼‘
	vertexResourceDesc.MipLevels = 1;			// ãƒŸãƒƒãƒ—ãƒ¬ãƒ™ãƒ«
	vertexResourceDesc.SampleDesc.Count = 1;	// ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°æ•°

	vertexResourceDesc.Layout = D3D12_TEXTURE_LAYOUT_ROW_MAJOR;
	//ã€€ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	Microsoft::WRL::ComPtr<ID3D12Resource> vertexResource = nullptr;
	HRESULT hr = device->CreateCommittedResource(&uploadHeapProperties, D3D12_HEAP_FLAG_NONE,
		&vertexResourceDesc, D3D12_RESOURCE_STATE_GENERIC_READ, nullptr, IID_PPV_ARGS(&vertexResource));
	assert(SUCCEEDED(hr));
	return vertexResource;
}

Microsoft::WRL::ComPtr<ID3D12Resource> DirectXCommon::CreateTextureResource(const DirectX::TexMetadata& metadata)
{
	// 1. metadataã‚’åŸºã«Resourceã®è¨­å®š
	D3D12_RESOURCE_DESC resourceDesc{};
	resourceDesc.Width = static_cast<UINT>(metadata.width); // Textureã®å¹…
	resourceDesc.Height = static_cast<UINT>(metadata.height); // Textureã®é«˜ã•
	resourceDesc.MipLevels = static_cast<UINT16>(metadata.mipLevels); // mipmapã®æ•°
	resourceDesc.DepthOrArraySize = static_cast<UINT16>(metadata.arraySize); // å¥¥è¡Œoré…åˆ—Textureã®é…åˆ—æ•°
	resourceDesc.Format = metadata.format; // Textureã®Format
	resourceDesc.SampleDesc.Count = 1; // ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°ã‚«ã‚¦ãƒ³ãƒˆ1å›ºå®š
	resourceDesc.Dimension = static_cast<D3D12_RESOURCE_DIMENSION>(metadata.dimension); // Textureã®æ¬¡å…ƒæ•°ã€‚æ™®æ®µä½¿ã£ã¦ã„ã‚‹ã®ã¯2æ¬¡å…ƒ

	// 2. åˆ©ç”¨ã™ã‚‹Heapã®è¨­å®š
	D3D12_HEAP_PROPERTIES heapProperties{};
	heapProperties.Type = D3D12_HEAP_TYPE_DEFAULT; // ç´°ã‹ã„è¨­å®šã‚’è¡Œã†

	// 3. Resourceã‚’ç”Ÿæˆã™ã‚‹
	Microsoft::WRL::ComPtr<ID3D12Resource> resource = nullptr;
	HRESULT hr = device->CreateCommittedResource(
		&heapProperties,				// Heapã®è¨­å®š
		D3D12_HEAP_FLAG_NONE,			// Heapã®ç‰¹æ®Šãªè¨­å®š,ç‰¹ã«ãªã—
		&resourceDesc,					// Resourceã®è¨­å®š
		D3D12_RESOURCE_STATE_COPY_DEST, // ãƒ‡ãƒ¼ã‚¿è»¢é€ã•ã‚Œã‚‹è¨­å®š
		nullptr,						// Clearæœ€é©å€¤ ä½¿ã‚ãªã„ã®ã§nullptr
		IID_PPV_ARGS(&resource)			// ä½œæˆã™ã‚‹Resourceãƒã‚¤ãƒ³ã‚¿ã¸ã®ãƒã‚¤ãƒ³ã‚¿
	);

	assert(SUCCEEDED(hr));
	return resource;
}

Microsoft::WRL::ComPtr<ID3D12Resource> DirectXCommon::UploadTextureData(Microsoft::WRL::ComPtr<ID3D12Resource> texture, const DirectX::ScratchImage& mipImages)
{
	std::vector<D3D12_SUBRESOURCE_DATA> subresources;
	DirectX::PrepareUpload(device.Get(), mipImages.GetImages(), mipImages.GetImageCount(), mipImages.GetMetadata(), subresources);
	uint64_t intermediateSize = GetRequiredIntermediateSize(texture.Get(), 0, static_cast<UINT>(subresources.size()));
	Microsoft::WRL::ComPtr<ID3D12Resource> intermediateResource = CreateBufferResource(intermediateSize);
	UpdateSubresources(commandList.Get(), texture.Get(), intermediateResource.Get(), 0, 0, static_cast<UINT>(subresources.size()), subresources.data());

	// Textureã¸ã®è»¢é€å¾Œã¯åˆ©ç”¨ã§ãã‚‹ã‚ˆã†ã€D3D12_RESOURCE_STATE_COPY_DESTã‹ã‚‰D3D12_RESOURCE_STATE_GENERIC_READã¸ResourceStateã‚’å¤‰æ›´ã™ã‚‹
	D3D12_RESOURCE_BARRIER barrier{};
	barrier.Type = D3D12_RESOURCE_BARRIER_TYPE_TRANSITION;
	barrier.Flags = D3D12_RESOURCE_BARRIER_FLAG_NONE;
	barrier.Transition.pResource = texture.Get();
	barrier.Transition.Subresource = D3D12_RESOURCE_BARRIER_ALL_SUBRESOURCES;
	barrier.Transition.StateBefore = D3D12_RESOURCE_STATE_COPY_DEST;
	barrier.Transition.StateAfter = D3D12_RESOURCE_STATE_GENERIC_READ;
	commandList->ResourceBarrier(1, &barrier);

	return intermediateResource;
}

void DirectXCommon::InitializeFixFPS()
{
	// ç¾åœ°æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹
	reference_ = std::chrono::steady_clock::now();
}

void DirectXCommon::UpdateFixFPS()
{
	// 1/60ç§’ã´ã£ãŸã‚Šã®æ™‚é–“
	const std::chrono::microseconds kMinTime(uint64_t(1000000.0f / 60.0f));
	// 1/60ç§’ã‚ˆã‚Šã‚ãšã‹ã«çŸ­ã„æ™‚é–“
	const std::chrono::microseconds kMinCheckTime(uint64_t(1000000.0f / 65.0f));

	// ç¾åœ°æ™‚é–“ã‚’å–å¾—ã™ã‚‹
	std::chrono::steady_clock::time_point now = std::chrono::steady_clock::now();
	// å‰å›è¨˜éŒ²ã‹ã‚‰ã®çµŒéæ™‚é–“ã‚’å–å¾—ã™ã‚‹
	std::chrono::microseconds elapsed =
		std::chrono::duration_cast<std::chrono::microseconds>(now - reference_);

	// 1/60ç§’ (ã‚ˆã‚Šã‚ãšã‹ã«çŸ­ã„æ™‚é–“)ç›¾å±…ãªã„å ´åˆ
	if (elapsed < kMinCheckTime) {
		// 1/60ç§’çµŒéã™ã‚‹ã¾ã§å¾®å°ãªã‚¹ãƒªãƒ¼ãƒ—ã‚’ç¹°ã‚Šè¿”ã™
		while (std::chrono::steady_clock::now() - reference_ < kMinTime) {
			// 1ãƒã‚¤ã‚¯ãƒ­ç§’ãƒªã‚½ãƒ¼ã‚¹
			std::this_thread::sleep_for(std::chrono::microseconds(1));
		}
	}
	// ç¾åœ¨ã®æ™‚é–“ã‚’è¨˜éŒ²ã™ã‚‹
	reference_ = std::chrono::steady_clock::now();

}



============================================================
File Path: engine/base/DirectXCommon.h
============================================================
#pragma once
#include <d3d12.h>
#include <dxgi1_6.h>
#include <wrl.h>
#include <array>
#include <dxcapi.h>
#include <chrono>
#include "WinAPI.h"
#include <cstdlib>
#include"../externals/DirectXTex/DirectXTex.h"
#include"../externals/DirectXTex/d3dx12.h"


/// <summary>
/// DirectXåŸºç›¤ã‚¯ãƒ©ã‚¹
/// </summary>
/// <remarks>
/// DirectX12ã®åˆæœŸåŒ–ã€æç”»å‰å¾Œå‡¦ç†ã‚’è¡Œã†
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹
/// </remarks>

// DirectXåŸºç›¤
class DirectXCommon
{
public:


	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// <summary>
	DirectXCommon();
	/// <summary>
	///åˆæœŸåŒ–
	/// <summary>
	void Initialize(WinAPI* winAPI);
	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	void PreDraw();

	/// <summary>
	/// æç”»å¾Œå‡¦ç†
	/// </summary>
	void PostDraw();

	/// <summary>
	/// ã‚³ãƒãƒ³ãƒ‰ã®å®Ÿè¡Œ
	/// </summary>
	void WaitCommand();

	/// <summary>
	/// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«
	/// </summary>
	Microsoft::WRL::ComPtr<IDxcBlob> CompileShader(
		const std::wstring& filePath,
		const wchar_t* profile);

	/// <summary>
	/// ãƒãƒƒãƒ•ã‚¡ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource>
		CreateBufferResource(size_t sizeInBytes);

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource>CreateTextureResource(const DirectX::TexMetadata& metadata);

	/// <summary>
	/// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ä½œæˆé–¢æ•°
	/// </summary>
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap>  CreateDescriptorHeap(
		D3D12_DESCRIPTOR_HEAP_TYPE heapType,
		UINT numDescriptors,
		bool shaderVisible);
public:		// Getter,Setter
	/// <summary>
	/// ãƒ‡ãƒã‚¤ã‚¹å–å¾—é–¢æ•°
	/// </summary>
	ID3D12Device* GetDevice() const { return device.Get(); }
	ID3D12GraphicsCommandList* GetCommandList()const { return commandList.Get(); }
	/// <summary>
	/// DxcUtilså–å¾—é–¢æ•°
	/// </summary>
	Microsoft::WRL::ComPtr <IDxcUtils>
		GetDxcUtils()const { return dxcUtils; }

	/// <summary>
	/// DxcCompilerå–å¾—é–¢æ•°
	/// </summary>
	Microsoft::WRL::ComPtr<IDxcCompiler3>
		GetDxcCompiler()const { return dxcCompiler; }

	/// <summary>
	/// ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ãƒ©å–å¾—é–¢æ•°
	/// </summary>
	Microsoft::WRL::ComPtr<IDxcIncludeHandler>
		GetIncludeHandler()const { return includeHandler; }

	/// <summary>
	/// srvDescriptorHeapå–å¾—é–¢æ•°
	/// </summary>
	/*Microsoft::WRL::ComPtr <ID3D12DescriptorHeap>
		GetSrvDescriptorHeap()const { return srvDescriptorHeap; }*/

	/// <summary>
	/// æŒ‡å®šç•ªå·ã®CPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	static D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(const Microsoft::WRL::ComPtr<ID3D12DescriptorHeap>& descriptorHeap, uint32_t descriptorSize, uint32_t index);
	/// <summary>
	/// æŒ‡å®šç•ªå·ã®GPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	static D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(const Microsoft::WRL::ComPtr<ID3D12DescriptorHeap>& descriptorHeap, uint32_t descriptorSize, uint32_t index);

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®è»¢é€
	/// [[nodiscard]]ã¨ã¯ã€æˆ»ã‚Šå€¤ãŒç„¡è¦–ã•ã‚Œã‚‹ã¨è­¦å‘Šã‚’å‡ºã™
	/// </summary>
	[[nodiscard]]
	Microsoft::WRL::ComPtr<ID3D12Resource> UploadTextureData
	(Microsoft::WRL::ComPtr<ID3D12Resource> texture, const DirectX::ScratchImage& mipImages);

	/// <summary>
	/// SRVã®æŒ‡å®šç•ªå·ã®CPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	//D3D12_CPU_DESCRIPTOR_HANDLE GetSRVCPUDescriptorHandle(uint32_t index);

	/// <summary>
	/// SRVã®æŒ‡å®šç•ªå·ã®GPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—ã™ã‚‹
	/// </summary>
	//D3D12_GPU_DESCRIPTOR_HANDLE GetSRVGPUDescriptorHandle(uint32_t index);

	/// <summary>
	/// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®æ•°ã‚’å–å¾—
	/// </summary>
	size_t GetBackBufferCount() const { return backBufferIndex; }

	/// <summary>
	/// RTVã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚ºã‚’å–å¾—
	/// </summary>
	uint32_t GetDescriptorSizeRTV() const { return descriptorSizeRTV; }

	/// <summary>
	/// ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
	/// </summary>
	D3D12_CPU_DESCRIPTOR_HANDLE GetDSVHandle()const { return dsvDescriptorHeap->GetCPUDescriptorHandleForHeapStart(); }

private:	// å†…éƒ¨å‡¦ç†å°‚ç”¨é–¢æ•°
	/// <summary>
	/// ã‚³ãƒãƒ³ãƒ‰é–¢é€£ã®åˆæœŸåŒ–
	/// </summary>
	void InitCommand();

	/// <summary>
	/// ãƒ‡ãƒã‚¤ã‚¹ã®åˆæœŸåŒ–
	/// </summary>
	void InitDevice();

	/// <summary>
	/// SwapChainã®ç”Ÿæˆ
	/// </summary>
	void CreateSwapChain();

	/// <summary>
	/// æ·±åº¦ãƒãƒƒãƒ•ã‚¡ã®ç”Ÿæˆ
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12Resource> CreateDepthBuffer(Microsoft::WRL::ComPtr<ID3D12Device> device, int32_t width, int32_t height);

	/// <summary>
	/// å„ç¨®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	/// </summary>
	void CreateDescriptorHeaps();

	/// <summary>
	/// ãƒ¬ãƒ³ãƒ€ãƒ¼ã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
	/// </summary>
	void InitRenderTargetView();

	/// <summary>
	/// æ·±åº¦ã‚¹ãƒ†ãƒ³ã‚·ãƒ«ãƒ“ãƒ¥ãƒ¼ã®åˆæœŸåŒ–
	/// </summary>
	void InitDepthStencilView();

	/// <summary>
	/// ãƒ•ã‚§ãƒ³ã‚¹ã®ç”Ÿæˆ
	/// </summary>
	void InitFence();

	/// <summary>
	/// ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆçŸ©å½¢ã®åˆæœŸåŒ–
	/// </summary>
	void InitViewportRect();

	/// <summary>
	/// ã‚·ã‚¶ãƒªãƒ³ã‚°çŸ©å½¢ã®åˆæœŸåŒ–
	/// </summary>
	void InitScissorRect();

	/// <summary>
	/// DXCã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã®ç”Ÿæˆ
	/// </summary>
	void CreateDXCCompiler();

	/// <summary>
	/// ImGuiã®åˆæœŸåŒ–
	/// </summary>
	void InitImGui();

	/// <summary>
	/// ã‚·ã‚§ãƒ¼ãƒ€ãƒ¼ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«é–¢æ•°
	/// </summary>
	static std::wstring ConvertString(const std::string& str);
	static std::string ConvertString(const std::wstring& str);

	/// <summary>
	/// FPSå›ºå®šåˆæœŸåŒ–
	/// </summary>
	void InitializeFixFPS();

	/// <summary>
	/// FPSå›ºå®šæ›´æ–°
	/// </summary>
	void UpdateFixFPS();


private:
	// WindowsAPI
	WinAPI* winAPI_ = nullptr;

private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	// DirectX12ãƒ‡ãƒã‚¤ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Device> device;
	// DXGIãƒ•ã‚¡ã‚¯ãƒˆãƒª
	Microsoft::WRL::ComPtr<IDXGIFactory7> dxgiFactory;
	// ã‚³ãƒãƒ³ãƒ‰ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼
	Microsoft::WRL::ComPtr <ID3D12CommandAllocator> commandAllocator;
	// ã‚³ãƒãƒ³ãƒ‰ãƒªã‚¹ãƒˆ
	Microsoft::WRL::ComPtr<ID3D12GraphicsCommandList> commandList;
	// ã‚³ãƒãƒ³ãƒ‰ã‚­ãƒ¥ãƒ¼
	Microsoft::WRL::ComPtr <ID3D12CommandQueue> commandQueue;
	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³ã®ç”Ÿæˆ
	DXGI_SWAP_CHAIN_DESC1 swapChainDesc{};
	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³
	Microsoft::WRL::ComPtr<IDXGISwapChain4> swapChain;
	// ã‚¹ãƒ¯ãƒƒãƒ—ãƒã‚§ã‚¤ãƒ³ãƒªã‚½ãƒ¼ã‚¹
	std::array<Microsoft::WRL::ComPtr<ID3D12Resource>, 2> swapChainResources;
	// ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	Microsoft::WRL::ComPtr <ID3D12Resource> resource;
	// RTVã®è¨­å®š
	D3D12_RENDER_TARGET_VIEW_DESC rtvDesc{};
	// å„ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ã®ãƒ¡ãƒ³ãƒå¤‰æ•°
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> rtvDescriptorHeap;
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> dsvDescriptorHeap;
	// RTVãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º
	uint32_t descriptorSizeRTV;

	// ç”Ÿæˆã®æˆæœç‰©ã€ãƒ•ã‚§ãƒ³ã‚¹
	Microsoft::WRL::ComPtr<ID3D12Fence> fence = nullptr;
	//ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆçŸ©å½¢ã®è¨­å®šä¿å­˜ç”¨ãƒ¡ãƒ³ãƒå¤‰æ•°
	D3D12_VIEWPORT viewport{};
	// dxcCompilerã‚’åˆæœŸåŒ–
	Microsoft::WRL::ComPtr<IDxcUtils> dxcUtils = nullptr;
	Microsoft::WRL::ComPtr<IDxcCompiler3> dxcCompiler = nullptr;
	// ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ãƒ‰ãƒãƒ³ãƒ‰ãƒ©
	Microsoft::WRL::ComPtr<IDxcIncludeHandler> includeHandler = nullptr;
	// TransitionBarrier ã®è¨­å®š
	D3D12_RESOURCE_BARRIER barrier{};
	// RTVã‚’2ã¤ä½œã‚‹ã®ã§ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚’2ã¤ç”¨æ„
	std::array<D3D12_CPU_DESCRIPTOR_HANDLE, 2> rtvHandles;
	// Fenceã®Signalã‚’å¾…ã¤ãŸã‚ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä½œæˆã™ã‚‹
	HANDLE fenceEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	// ã‚·ã‚¶ãƒªãƒ³ã‚°çŸ©å½¢ã®è¨­å®š
	D3D12_RECT scissorRect{};
	// åˆæœŸå€¤0ã§Fenceã‚’ä½œæˆ
	uint64_t fenceValue = 0;
	// ã“ã“ã‹ã‚‰æ›¸ãè¾¼ã‚€ãƒãƒƒã‚¯ãƒãƒƒãƒ•ã‚¡ã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å–å¾—
	UINT backBufferIndex = 2;
	// æ·±åº¦ãƒªã‚½ãƒ¼ã‚¹
	Microsoft::WRL::ComPtr <ID3D12Resource> depthStencilResource;
	// è¨˜éŒ²æ™‚é–“(FPSå›ºå®šç”¨)
	std::chrono::steady_clock::time_point reference_;


};



============================================================
File Path: engine/base/ImGuiManager.cpp
============================================================
#include "ImGuiManager.h"
#include "externals/imgui/imgui_impl_win32.h"
#include "externals/imgui/imgui_impl_dx12.h"

#ifdef USE_IMGUI
void ImGuiManager::Initialize(WinAPI* winAPI, DirectXCommon* dxCommon)
{
	// å¼•æ•°ã®nullptrãƒã‚§ãƒƒã‚¯
	assert(dxCommon);
	dxCommon_ = dxCommon;
	// ImGuiã®ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆ
	ImGui::CreateContext();
	// ImGuiã®ã‚¹ã‚¿ã‚¤ãƒ«ã‚’è¨­å®š
	ImGui::StyleColorsDark();
	// ImGuiã®Win32ã®åˆæœŸåŒ–
	ImGui_ImplWin32_Init(winAPI->GetHwnd());

	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—è¨­å®š
	D3D12_DESCRIPTOR_HEAP_DESC desc = {};
	desc.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
	desc.NumDescriptors = 1;
	desc.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;
	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’ç”Ÿæˆ
	HRESULT result = dxCommon->GetDevice()->CreateDescriptorHeap(&desc, IID_PPV_ARGS(&srvHeap_));
	assert(SUCCEEDED(result));

	// DirectX12ç”¨åˆæœŸåŒ–
	ImGui_ImplDX12_Init(
		// ãƒ‡ãƒã‚¤ã‚¹
		dxCommon->GetDevice(),
		// ãƒãƒƒãƒ•ã‚¡æ•° / å‹ãŒåˆã†ã‚ˆã†ã«ã‚­ãƒ£ã‚¹ãƒˆ
		static_cast<int>(dxCommon->GetBackBufferCount()),
		// RTVã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ / RTVã®è¨­å®šã¨ä¸€è‡´ã•ã›ã‚‹ / SRVãƒ’ãƒ¼ãƒ—
		DXGI_FORMAT_R8G8B8A8_UNORM_SRGB, srvHeap_.Get(),
		// ImGuiã«å‰²ã‚Šå½“ã¦ã‚‹SRVã®ãƒ’ãƒ¼ãƒ—ãƒãƒ³ãƒ‰ãƒ« / SRVã®ç”Ÿæˆã¯ImGuiå´ãŒã‚„ã£ã¦ãã‚Œã‚‹
		srvHeap_->GetCPUDescriptorHandleForHeapStart(),
		// ImGuiã«å‰²ã‚Šå½“ã¦ã‚‹SRVã®ãƒ’ãƒ¼ãƒ—ãƒãƒ³ãƒ‰ãƒ« / GPUå´ã®ãƒ’ãƒ¼ãƒ—ãƒãƒ³ãƒ‰ãƒ«
		srvHeap_->GetGPUDescriptorHandleForHeapStart()
	);
	//ImGuiIO& io = ImGui::GetIO();
	//io.ConfigFlags |= ImGuiConfigFlags_DockingEnable; // ãƒ‰ãƒƒã‚­ãƒ³ã‚°ã‚’æœ‰åŠ¹ã«ã™ã‚‹
}

void ImGuiManager::Finalize()
{
	// ImGuiã®çµ‚äº†å‡¦ç†
	ImGui_ImplDX12_Shutdown();
	ImGui_ImplWin32_Shutdown();
	ImGui::DestroyContext();

	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã‚’è§£æ”¾
	srvHeap_.Reset();
}

void ImGuiManager::Begin()
{
	// ImGuiã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’é–‹å§‹
	ImGui_ImplDX12_NewFrame();
	ImGui_ImplWin32_NewFrame();
	ImGui::NewFrame();
}

void ImGuiManager::End()
{
	
	// ImGuiã®ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’çµ‚äº†
	ImGui::Render();
}

void ImGuiManager::Draw()
{
	ID3D12GraphicsCommandList* commandList = dxCommon_->GetCommandList();
	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®é…åˆ—ã‚’ã‚»ãƒƒãƒˆã™ã‚‹ã‚³ãƒãƒ³ãƒ‰
	ID3D12DescriptorHeap* ppHeaps[] = { srvHeap_.Get() };
	commandList->SetDescriptorHeaps(_countof(ppHeaps), ppHeaps);
	// ImGuiã®æç”»ã‚³ãƒãƒ³ãƒ‰ã‚’ç©ã‚€
	ImGui_ImplDX12_RenderDrawData(ImGui::GetDrawData(), commandList);
}

#endif

============================================================
File Path: engine/base/ImGuiManager.h
============================================================
#pragma once
#include <d3d12.h>
#ifdef USE_IMGUI
#include "externals/imgui/imgui.h"
#endif
#include "engine/base/WinAPI.h" 
#include "engine/base/DirectXCommon.h"

/// <summary>
/// ImGuiç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
/// <remarks>
/// ImGuiã®åˆæœŸåŒ–ã€æç”»ã‚’è¡Œã†
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹
/// </remarks>

class ImGuiManager
{

public:
#ifdef USE_IMGUI
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize(WinAPI*winAPI,DirectXCommon*dxCommon);

	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize(); 
	
	/// <summary>
	/// ImGuiå—ä»˜é–‹å§‹
	/// <summary>
	void Begin();

	/// <summary>
	/// ImGuiå—ä»˜çµ‚äº†
	/// <summary>
	void End();

	/// <summary>
	/// æç”»
	/// </summary>
	void Draw();
#endif
private:
	DirectXCommon* dxCommon_ = nullptr;
	
	Microsoft::WRL::ComPtr<ID3D12Device> device = nullptr;
	
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> srvHeap_ = nullptr;


};


============================================================
File Path: engine/base/Input.cpp
============================================================
#include "Input.h"
#include <cassert>
#pragma comment(lib,"dinput8.lib")
#pragma comment(lib,"dxguid.lib")

Input* Input::instance = nullptr;
Input* Input::GetInstance()
{
	if (instance == nullptr)
	{
		instance = new Input();
	}
	return instance;
}

void Input::DeleteInstance()
{
	if (instance != nullptr)
	{
		delete instance;
		instance = nullptr;
	}
}

void Input::Initialize(WinAPI *winAPI)
{
	//å€Ÿã‚Šã¦ããŸWinAPIã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’è¨˜éŒ²
	this->winAPI = winAPI;
	//DirectInputã®åˆæœŸåŒ–
	HRESULT result = DirectInput8Create(
		winAPI->GetHInstance(), DIRECTINPUT_VERSION, IID_IDirectInput8,
		(void**)&directInput, nullptr);
	assert(SUCCEEDED(result));
	//ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ãƒ‡ãƒã‚¤ã‚¹ã®ä½œæˆ
	result = directInput->CreateDevice(GUID_SysKeyboard, &keyboard, NULL);
	assert(SUCCEEDED(result));

	//å…¥åŠ›ãƒ‡ãƒ¼ã‚¿å½¢å¼ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetDataFormat(&c_dfDIKeyboard);
	assert(SUCCEEDED(result));

	//æ’ä»–åˆ¶å¾¡ã®ãƒ¬ãƒ™ãƒ«ã®ã‚»ãƒƒãƒˆ
	result = keyboard->SetCooperativeLevel(winAPI->GetHwnd(), DISCL_FOREGROUND | DISCL_NONEXCLUSIVE | DISCL_NOWINKEY);
	assert(SUCCEEDED(result));
}

void Input::Update()
{
	HRESULT result;
	//å‰å›ã®ã‚­ãƒ¼å…¥åŠ›ã‚’ä¿å­˜
	memcpy(keyPre, key, sizeof(key));
	if (TriggerKey(DIK_1)) {
		OutputDebugStringA("Hit_1\n");
	}
	////å…¨ã‚­ãƒ¼ã®å…¥åŠ›çŠ¶æ…‹ã‚’å–å¾—ã™ã‚‹
	result = keyboard->Acquire();
	result = keyboard->GetDeviceState(sizeof(key), key);

}
bool Input::RereseKey(BYTE keyNumber)
{
	// å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã§æŠ¼ã•ã‚Œã¦ã„ã¦ã€ä»Šãƒ•ãƒ¬ãƒ¼ãƒ ã§æŠ¼ã•ã‚Œã¦ã„ãªã„å ´åˆ
	return (keyPre[keyNumber] != 0) && (key[keyNumber] == 0);
	return false;
}
bool Input::PushKey(BYTE keyNumber)
{
	//æŒ‡å®šã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ã„ã‚Œã°trueã‚’è¿”ã™
	 // ä»Šãƒ•ãƒ¬ãƒ¼ãƒ ã§ã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹å ´åˆ
	return key[keyNumber] != 0;
}
bool Input::TriggerKey(BYTE keyNumber)
{
	// å‰ãƒ•ãƒ¬ãƒ¼ãƒ ã§æŠ¼ã•ã‚Œã¦ãŠã‚‰ãšã€ä»Šãƒ•ãƒ¬ãƒ¼ãƒ ã§æŠ¼ã•ã‚Œã¦ã„ã‚‹å ´åˆ
	return (keyPre[keyNumber] == 0) && (key[keyNumber] != 0);
}


============================================================
File Path: engine/base/Input.h
============================================================
#pragma once
#define DIRECTINPUT_VERSION		0x0800	//DirectInputã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³æŒ‡å®š
#include <dinput.h>
#include <stdint.h>
#include <Windows.h>
#include <wrl.h>
#include "WinAPI.h"

/// <summary>
/// å…¥åŠ›ã‚¯ãƒ©ã‚¹
/// </summary>
/// <remarks>
/// DirectInputã‚’ä½¿ç”¨ã—ã¦ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ã‚’ç®¡ç†ã™ã‚‹
/// </remarks>
class Input
{
public:
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	/// <returns></returns>
	static Input* GetInstance();
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è§£æ”¾
	/// </summary>
	static void DeleteInstance();
private:
	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
	static Input* instance;
	// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	Input() = default;
	// ãƒ‡ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	~Input() = default;
	// ã‚³ãƒ”ãƒ¼ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ãƒ»ä»£å…¥æ¼”ç®—å­å‰Šé™¤
	Input(Input&) = delete;
	Input& operator=(Input&) = delete;

public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="winAPI"></param>
	void Initialize(WinAPI*winAPI);

	/// <summary>
	/// æ›´æ–°å‡¦ç†
	/// </summary>
	void Update();

	/// <summary>
	///ç‰¹å®šã®ã‚­ãƒ¼ãŒè©±ã•ã‚ŒãŸç¬é–“ã‚’åˆ¤å®š
	/// </summary>
	/// <param name="keyNumber"></param>
	bool RereseKey(BYTE keyNumber);

	/// <summary>
	///ã‚­ãƒ¼ãŒæŠ¼ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèª
	/// </summary>
	/// <param name="keyNumber"></param>
	bool PushKey(BYTE keyNumber);
	/// <summary>
	/// ã‚­ãƒ¼ãŒæŠ¼ã•ã‚ŒãŸç¬é–“ã‚’åˆ¤å®š
	/// </summary>
	/// <param name="keyNumber"></param>
	/// <returns></returns>
	bool TriggerKey(BYTE keyNumber);
	template <class T>using ComPtr = Microsoft::WRL::ComPtr<T>;
private:

	ComPtr<IDirectInputDevice8> keyboard;
	ComPtr<IDirectInput8>directInput = nullptr;
	BYTE key[256] = {};
	BYTE keyPre[256] = {};

	//WindowsAPI
	WinAPI* winAPI = nullptr;

	
};



============================================================
File Path: engine/base/Logger.cpp
============================================================
#include "Logger.h"
#include <debugapi.h>
namespace Logger {
	void Logger::Log(const std::string& message) {
		OutputDebugStringA(message.c_str());
	}
}


============================================================
File Path: engine/base/Logger.h
============================================================
#pragma once
#include <string>
#include <Windows.h>
/// <summary>
/// stringãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
/// </summary>
//ãƒ­ã‚°å‡ºåŠ›
namespace Logger {
	/// <summary>
	/// ãƒ­ã‚°å‡ºåŠ›
	/// </summary>
	/// <param name="message"></param>
	void Log(const std::string& message);
}




============================================================
File Path: engine/base/SrvManager.cpp
============================================================
#include "SrvManager.h"
const uint32_t SrvManager::kMaxSRVCount = 512;

void SrvManager::Initialize(DirectXCommon* dxCommon)
{
	this->dxCommon = dxCommon;
	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—ã®ç”Ÿæˆ
	descriptorHeap = dxCommon->CreateDescriptorHeap(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV, kMaxSRVCount, true);
	// ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ï¼‘å€‹åˆ†ã®ã‚µã‚¤ã‚ºã‚’å–å¾—ã—ã¦è¨˜éŒ²
	descriptorSize = dxCommon->GetDevice()->GetDescriptorHandleIncrementSize(D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV);

}

uint32_t SrvManager::Allocate  ()
{
	// ä¸Šé™ã«é”ã—ã¦ã„ãªã„ã‹ç¢ºèª
	if (kMaxSRVCount<= useIndex) {
		// ä¸Šé™ã«é”ã—ã¦ã„ã‚‹ã®ã§ã‚¨ãƒ©ãƒ¼
		assert(0);
	}
	// returnã™ã‚‹ç•ªå·ã‚’ä¸€æ—¦è¨˜éŒ²
	uint32_t index = useIndex;
	// æ¬¡ã«ä½¿ç”¨ã™ã‚‹ç•ªå·ã‚’æ›´æ–°
	useIndex++;
	// ä¸Šã§è¨˜éŒ²ã—ãŸç•ªå·ã‚’retunr
	return index;
}

void SrvManager::CreateSRVforTexture2D(uint32_t srvIndex, ID3D12Resource* pResource, DXGI_FORMAT Format, UINT MipLevels)
{
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = Format;
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.Texture2D.MipLevels = MipLevels;
	// SRVã‚’ä½œæˆ
	dxCommon->GetDevice()->CreateShaderResourceView(pResource, &srvDesc, GetCPUDescriptorHandle(srvIndex));

}

void SrvManager::CreateSRVforStructuredBuffer(uint32_t srvIndex, ID3D12Resource* pResource, UINT numElements, UINT structureByteStride)
{
	// SRVã®è¨­å®š
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = DXGI_FORMAT_UNKNOWN; // æ§‹é€ åŒ–ãƒãƒƒãƒ•ã‚¡ã®å ´åˆã€ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã¯ UNKNOWN
	srvDesc.ViewDimension = D3D12_SRV_DIMENSION_BUFFER;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;
	srvDesc.Buffer.FirstElement = 0;
	srvDesc.Buffer.NumElements = numElements;
	srvDesc.Buffer.StructureByteStride = structureByteStride;
	srvDesc.Buffer.Flags = D3D12_BUFFER_SRV_FLAG_NONE;

	// SRVã‚’ä½œæˆ
	dxCommon->GetDevice()->CreateShaderResourceView(pResource, &srvDesc, GetCPUDescriptorHandle(srvIndex));
}

void SrvManager::PreDraw()
{
#pragma region SRVç”¨ã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ¼ãƒ’ãƒ¼ãƒ—ã‚’æŒ‡å®š
	// æç”»ç”¨ã®DescriptorHeapã®è¨­å®š
	ID3D12DescriptorHeap* descriptorHeaps[] = { descriptorHeap.Get()};
	dxCommon->GetCommandList()->SetDescriptorHeaps(1, descriptorHeaps);
#pragma endregion
}

void SrvManager::SetGraphicsDescriptorTable(UINT RootParameterIndex, uint32_t srvIndex)
{
	dxCommon->GetCommandList()->SetGraphicsRootDescriptorTable(RootParameterIndex, GetGPUDescriptorHandle(srvIndex));
}

bool SrvManager::IsAllocate()
{
	if (kMaxSRVCount > useIndex) {
		return true;
	}
	else {
		return false;
	}
}

D3D12_CPU_DESCRIPTOR_HANDLE SrvManager::GetCPUDescriptorHandle(uint32_t index)
{
	D3D12_CPU_DESCRIPTOR_HANDLE handleCPU = descriptorHeap->GetCPUDescriptorHandleForHeapStart();
	handleCPU.ptr += (descriptorSize * index);
	return handleCPU;
}

D3D12_GPU_DESCRIPTOR_HANDLE SrvManager::GetGPUDescriptorHandle(uint32_t index)
{
	D3D12_GPU_DESCRIPTOR_HANDLE handleGPU = descriptorHeap->GetGPUDescriptorHandleForHeapStart();
	handleGPU.ptr += (descriptorSize * index);
	return handleGPU;
}

Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> SrvManager::GetSRVHeap() const
{
	return descriptorHeap;
}


============================================================
File Path: engine/base/SrvManager.h
============================================================
#pragma once
#include "DirectXCommon.h"
/// <summary>
/// SRVç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
/// <remarks>
/// SRVã®ç”Ÿæˆã€ç®¡ç†ã‚’è¡Œã†
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹
/// </remarks>
class SrvManager
{
public:
	// æœ€å¤§SRVæ•°(æœ€å¤§ãƒ†ã‚¯ã‚¹ãƒãƒ£æšæ•°)
	static const uint32_t kMaxSRVCount;
public:
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon"></param>
	void Initialize(DirectXCommon* dxCommon);
	/// <summary>
	/// ã‚¢ãƒ­ã‚±ãƒ¼ã‚¿ãƒ¼
	/// </summary>
	/// <returns></returns>
	uint32_t Allocate();
	/// <summary>
	/// SRVç”Ÿæˆ(ãƒ†ã‚¯ã‚¹ãƒãƒ£2Dç”¨)
	/// </summary>
	/// <param name="srvIndex"></param>
	/// <param name="pResource"></param>
	/// <param name="Format"></param>
	/// <param name="MipLevels"></param>
	void CreateSRVforTexture2D(uint32_t srvIndex, ID3D12Resource* pResource, DXGI_FORMAT Format, UINT MipLevels);
	/// <summary>
	/// SRVç”Ÿæˆ(ãƒãƒƒãƒ•ã‚¡ç”¨)
	/// </summary>
	/// <param name="srvIndex"></param>
	/// <param name="pResource"></param>
	/// <param name="numElements"></param>
	/// <param name="structureByteStrude"></param>
	void CreateSRVforStructuredBuffer(uint32_t srvIndex, ID3D12Resource* pResource, UINT numElements, UINT structureByteStrude);
	/// <summary>
	/// æç”»å‰å‡¦ç†
	/// </summary>
	void PreDraw();
	/// <summary>
	/// SRVã‚»ãƒƒãƒˆã‚³ãƒãƒ³ãƒ‰
	/// </summary>
	/// <param name="RootParameterIndex"></param>
	/// <param name="srvIndex"></param>
	void SetGraphicsDescriptorTable(UINT RootParameterIndex, uint32_t srvIndex);
	
	/// <summary>
	/// æœ€å¤§æ•°ã«é”ã—ã¦ã„ã‚‹ã‹
	/// </summary>
	/// <returns></returns>
	bool IsAllocate();
public:// Getter,Setter
	/// <summary>
	/// CPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
	/// </summary>
	D3D12_CPU_DESCRIPTOR_HANDLE GetCPUDescriptorHandle(uint32_t index);
	/// <summary>
	/// GPUãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
	/// </summary>
	D3D12_GPU_DESCRIPTOR_HANDLE GetGPUDescriptorHandle(uint32_t index);
	/// <summary>
	/// SRVãƒ’ãƒ¼ãƒ—ã®å–å¾—
	/// </summary>
	Microsoft::WRL::ComPtr<ID3D12DescriptorHeap> GetSRVHeap()const;
private:
	// çµ¶å¯¾ã«newã—ãªã„
	DirectXCommon* dxCommon;
	// SRVã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ã‚µã‚¤ã‚º
	uint32_t descriptorSize;
	// SRVã®ãƒ‡ã‚£ã‚¹ã‚¯ãƒªãƒ—ã‚¿ãƒ’ãƒ¼ãƒ—
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> descriptorHeap;
	// æ¬¡ã«ä½¿ç”¨ã™ã‚‹SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
	uint32_t useIndex = 0;

};



============================================================
File Path: engine/base/StringUtility.cpp
============================================================
#include "StringUtility.h"
#include <Windows.h>
namespace StringUtility {

	std::wstring StringUtility::ConvertString(const std::string& str)
	{
		if (str.empty()) {
			return std::wstring();
		}

		auto sizeNeeded = MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), NULL, 0);
		if (sizeNeeded == 0) {
			return std::wstring();
		}
		std::wstring result(sizeNeeded, 0);
		MultiByteToWideChar(CP_UTF8, 0, reinterpret_cast<const char*>(&str[0]), static_cast<int>(str.size()), &result[0], sizeNeeded);
		return result;
	}

	std::string StringUtility::ConvertString(const std::wstring& str)
	{
		if (str.empty()) {
			return std::string();
		}

		auto sizeNeeded = WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), NULL, 0, NULL, NULL);
		if (sizeNeeded == 0) {
			return std::string();
		}
		std::string result(sizeNeeded, 0);
		WideCharToMultiByte(CP_UTF8, 0, str.data(), static_cast<int>(str.size()), result.data(), sizeNeeded, NULL, NULL);
		return result;
	}

}


============================================================
File Path: engine/base/StringUtility.h
============================================================
#pragma once
#include <string>
/// <summary>
/// stringãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
/// </summary>
namespace StringUtility {

	/// <summary>
	/// stringã‚’wstringã«å¤‰æ›ã™ã‚‹
	/// </summary>
	/// <param name="str"></param>
	/// <returns></returns>
	std::wstring ConvertString(const std::string& str);
	/// <summary>
	/// wstringã‚’stringã«å¤‰æ›ã™ã‚‹
	/// </summary>
	/// <param name="str"></param>
	/// <returns></returns>
	std::string ConvertString(const std::wstring& str);
}

============================================================
File Path: engine/base/TextureManager.cpp
============================================================
#include "TextureManager.h"
#include "DirectXCommon.h"
#include "StringUtility.h"
#include "DirectXCommon.h"
TextureManager* TextureManager::instance = nullptr;
// ImGuiã§0ã‚’ä½¿ç”¨ã—ã¦ã„ã‚‹ãŸã‚ï¼‘ã‹ã‚‰é–‹å§‹
uint32_t TextureManager::kSRVIndexTop = 1;
TextureManager* TextureManager::GetInstance()
{

	if (instance == nullptr) {
		instance = new TextureManager();
	}
	return instance;
}

void TextureManager::DeleteInstance()
{
	if (instance != nullptr) {
		delete instance;
		instance = nullptr;
	}
}

const DirectX::TexMetadata& TextureManager::GetMetadata(const std::string& filePath)

{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢
	auto it = textureDatas.find(filePath);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ã‚¨ãƒ©ãƒ¼
	assert(it != textureDatas.end());

	// è¦‹ã¤ã‹ã£ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’è¿”ã™
	return it->second.metadata;
}


uint32_t TextureManager::GetSrvIndex(const std::string& filePath)
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
	auto it = textureDatas.find(filePath);
	if (it == textureDatas.end()) {
		// ãªã‹ã£ãŸã‚‰ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
		throw std::runtime_error("Texture not found for filePath: " + filePath);
	}
	//if (it != textureDatas.end()) {
	//	// èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰è¦ç´ ç•ªå·ã‚’è¿”ã™
	//	uint32_t textureIndex = static_cast<uint32_t>(std::distance(textureDatas.begin(), it));
	//	return textureIndex;
	//}
	//assert(0);
	return it->second.srvIndex;
}

//D3D12_GPU_DESCRIPTOR_HANDLE TextureManager::GetSrvHandleGPU(const std::string& filePath)
//{
//	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
//	auto it = textureDatas.find(filePath);
//	if (it == textureDatas.end()) {
//		// ãªã‹ã£ãŸã‚‰ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
//		
//		throw std::runtime_error("Texture not found for filePath: " + filePath);
//	}
//
//	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®å‚ç…§ã‚’å–å¾—
//	TextureData& textureData = it->second;
//	return textureData.srvHandleGPU;
//}

D3D12_GPU_DESCRIPTOR_HANDLE TextureManager::GetSrvHandleGPU(const std::string& filePath)
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢
	auto it = textureDatas.find(filePath);

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ä¾‹å¤–ã‚’æŠ•ã’ã‚‹
	if (it == textureDatas.end()) {
		throw std::runtime_error("Texture not found for filePath: " + filePath);
	}
	// è¦‹ã¤ã‹ã£ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®GPUãƒãƒ³ãƒ‰ãƒ«ã‚’è¿”ã™
	return it->second.srvHandleGPU;
}

Microsoft::WRL::ComPtr<ID3D12Resource> TextureManager::GetTextureResource(const std::string& filePath)
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢
	auto it = textureDatas.find(filePath);
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ä¾‹å¤–ã‚’æŠ•ã’ã‚‹
	if (it == textureDatas.end()) {
		throw std::runtime_error("Texture not found for filePath: " + filePath);
	}
	// è¦‹ã¤ã‹ã£ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®ãƒªã‚½ãƒ¼ã‚¹ã‚’è¿”ã™
	return it->second.resource;
}

D3D12_GPU_DESCRIPTOR_HANDLE TextureManager::GetGpuDescriptorHandle(const std::string& filePath) 
{

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã‚’æ¤œç´¢
	auto it = textureDatas.find(filePath);
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯ä¾‹å¤–ã‚’æŠ•ã’ã‚‹
	if (it == textureDatas.end()) {
		throw std::runtime_error("Texture not found for filePath: " + filePath);
	}
	// è¦‹ã¤ã‹ã£ãŸãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®GPUãƒãƒ³ãƒ‰ãƒ«ã‚’è¿”ã™
	return it->second.srvHandleGPU;
}




void TextureManager::Initialize(DirectXCommon* dxCommon, SrvManager* srvManager)
{
	this->dxCommon = dxCommon;
	this->srvManager = srvManager;
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®æœ€å¤§æšæ•°ã‚’å–å¾—/SRVã®æœ€å¤§æ•°ã‚’å–å¾—
	textureDatas.reserve(SrvManager::kMaxSRVCount);
}

void TextureManager::Finalize()
{
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®ã‚¯ãƒªã‚¢
	textureDatas.clear();
}

void TextureManager::LoadTexture(const std::string& filePath)
{
	// èª­ã¿è¾¼ã¿æ¸ˆã¿ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯
	if (textureDatas.contains(filePath)) {
		// èª­ã¿è¾¼ã¿æ¸ˆã¿ãªã‚‰ä½•ã‚‚ã—ãªã„
		return;
	}

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£æšæ•°ä¸Šé™ã‚’è¶…ãˆã¦ã„ã‚‹å ´åˆ
	assert(srvManager->IsAllocate());

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã‚“ã§ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã§æ‰±ãˆã‚‹ã‚ˆã†ã«ã™ã‚‹
	DirectX::ScratchImage image{};
	std::wstring filePathW = StringUtility::ConvertString(filePath);
	// DDSã‚„WICå½¢å¼ã®ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚€
	HRESULT hr;
	if (filePathW.ends_with(L".dds")) {
		// .ddsã§çµ‚äº†ã—ã¦ã„ã‚‹å ´åˆèª­ã¿è¾¼ã‚€ã‚ˆã†ã«ã™ã‚‹
		hr = DirectX::LoadFromDDSFile(filePathW.c_str(), DirectX::DDS_FLAGS_NONE, nullptr, image);
	} else {
		hr = DirectX::LoadFromWICFile(filePathW.c_str(), DirectX::WIC_FLAGS_FORCE_SRGB, nullptr, image);
	}

	assert(SUCCEEDED(hr));

	// ãƒŸãƒƒãƒ—ãƒãƒƒãƒ—ã®ä½œæˆ
	DirectX::ScratchImage mipImages{};
	// åœ§ç¸®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã‹èª¿ã¹ã‚‹
	if (DirectX::IsCompressed(image.GetMetadata().format)) {
		// åœ§ç¸®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆã§ã‚ã‚Œã°ãã®ã¾ã¾ä½¿ç”¨ã™ã‚‹ã®ã§move
		mipImages = std::move(image);
	} else {
		hr = DirectX::GenerateMipMaps(image.GetImages(), image.GetImageCount(), image.GetMetadata(), DirectX::TEX_FILTER_SRGB, 0, mipImages);
	}


	assert(SUCCEEDED(hr));

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®è¿½åŠ 
	TextureData textureData;
	textureData.metadata = mipImages.GetMetadata();
	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	textureData.resource = dxCommon->CreateTextureResource(textureData.metadata);
	// ä¸­é–“ãƒªã‚½ãƒ¼ã‚¹ã®ç”Ÿæˆ
	Microsoft::WRL::ComPtr<ID3D12Resource> intermediateResource = dxCommon->UploadTextureData(textureData.resource, mipImages);
	// ã‚³ãƒãƒ³ãƒ‰ã®ã‚­ãƒƒã‚¯ã‚’å¾…ã¤
	dxCommon->WaitCommand();

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿ã®è¦ç´ æ•°ç•ªå·ã‚’SRVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã¨ã™ã‚‹
	uint32_t srvIndex = static_cast<uint32_t>(textureDatas.size()) + kSRVIndexTop;

	// SRVç¢ºä¿
	textureData.srvIndex = srvManager->Allocate();
	textureData.srvHandleCPU = srvManager->GetCPUDescriptorHandle(textureData.srvIndex);
	textureData.srvHandleGPU = srvManager->GetGPUDescriptorHandle(textureData.srvIndex);

	// SRVã®è¨­å®š
	D3D12_SHADER_RESOURCE_VIEW_DESC srvDesc{};
	srvDesc.Format = textureData.metadata.format;
	srvDesc.Shader4ComponentMapping = D3D12_DEFAULT_SHADER_4_COMPONENT_MAPPING;

	if (textureData.metadata.IsCubemap()) {
		// textureCubeã§ã¯ã‚ã‚‹ãŒtexture2Dã¨ã‹ã‚ã‚‰ãªã„
		srvDesc.TextureCube.MostDetailedMip = 0;
		srvDesc.TextureCube.MipLevels = UINT_MAX;
		srvDesc.TextureCube.ResourceMinLODClamp = 0.0f;
		srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURECUBE;
	} else {
		srvDesc.ViewDimension = D3D12_SRV_DIMENSION_TEXTURE2D; // 2Dãƒ†ã‚¯ã‚¹ãƒãƒ£
		srvDesc.Texture2D.MipLevels = UINT(textureData.metadata.mipLevels);

	}

	// SRVã‚’ä½œæˆ
	dxCommon->GetDevice()->CreateShaderResourceView(textureData.resource.Get(), &srvDesc, textureData.srvHandleCPU);

	// textureDatasã«è¿½åŠ 
	textureDatas.emplace(filePath, std::move(textureData));

}

============================================================
File Path: engine/base/TextureManager.h
============================================================
#pragma once
#include <string>
#include <wrl/client.h>
#include <d3d12.h>
#include "DirectXCommon.h"
#include "externals/DirectXTex/DirectXTex.h"
#include "SrvManager.h"
#include <unordered_map>
#include <cstdint>

/// <summary>
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç®¡ç†ã‚¯ãƒ©ã‚¹
/// </summary>
/// <remarks>
/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®èª­ã¿è¾¼ã¿ã€è§£æ”¾ã‚’è¡Œã†
/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¯ãƒ©ã‚¹
/// </remarks>
class srvManager;
class TextureManager
{
	// SRVã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã®é–‹å§‹ç•ªå·
	static uint32_t kSRVIndexTop;
public:		// ãƒ¡ãƒ³ãƒé–¢æ•°
	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	/// <param name="dxCommon"></param>
	/// <param name="srvManager"></param>
	void Initialize(DirectXCommon* dxCommon, SrvManager* srvManager);
	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();
	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ã®èª­ã¿è¾¼ã¿
	/// <param name ="filePath"ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ•ã‚¡ã‚¤ãƒ«ã®ãƒ‘ã‚¹>
	/// </summary>
	void LoadTexture(const std::string& filePath);

public:	// Getter,Setter
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®å–å¾—
	/// </summary>
	static TextureManager* GetInstance();
	/// <summary>
	/// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã®è§£æ”¾
	/// </summary>
	static void DeleteInstance();

	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£æƒ…å ±ã®å–å¾—
	/// </summary>
	/// <param name="filePath"></param>
	/// <returns></returns>
	const DirectX::TexMetadata& GetMetadata(const std::string& filePath);
	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç•ªå·ã®å–å¾—
	/// </summary>
	/// <param name="filePath"></param>
	/// <returns></returns>
	uint32_t GetSrvIndex(const std::string& filePath);
	/// <summary>
	/// ãƒ†ã‚¯ã‚¹ãƒãƒ£ç•ªå·ã‹ã‚‰GPUãƒãƒ³ãƒ‰ãƒ«ã‚’å–å¾—
	/// </summary>
	D3D12_GPU_DESCRIPTOR_HANDLE GetSrvHandleGPU(const std::string& filePath);

	Microsoft::WRL::ComPtr<ID3D12Resource> GetTextureResource(const std::string& filePath);

	D3D12_GPU_DESCRIPTOR_HANDLE GetGpuDescriptorHandle(const std::string& filePath);
	

private: // ãƒ¡ãƒ³ãƒé–¢æ•°/æ§‹é€ ä½“


	//ãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼‘æšåˆ†ã®æƒ…å ±
	struct TextureData
	{
		//std::string filePath;	// ãƒ•ã‚¡ã‚¤ãƒ«å
		DirectX::TexMetadata metadata;						// ãƒ†ã‚¯ã‚¹ãƒãƒ£ã®æƒ…å ±(å¹…ã€é«˜ã•)
		Microsoft::WRL::ComPtr<ID3D12Resource> resource;	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒªã‚½ãƒ¼ã‚¹
		uint32_t srvIndex;									// SRVã®ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹
		D3D12_CPU_DESCRIPTOR_HANDLE srvHandleCPU;			// ã‚·ã‚§ãƒ¼ãƒ€ãƒªã‚½ãƒ¼ã‚¹ãƒ“ãƒ¥ãƒ¼ã®CPUãƒãƒ³ãƒ‰ãƒ«
		D3D12_GPU_DESCRIPTOR_HANDLE srvHandleGPU;			// æç”»ã‚³ãƒãƒ³ãƒ‰ã«å¿…è¦ãªGPUãƒãƒ³ãƒ‰ãƒ«
	};

private:	// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ 
	static TextureManager* instance;
	TextureManager() = default;
	~TextureManager() = default;
	TextureManager(TextureManager&) = delete;
	TextureManager& operator=(TextureManager&) = delete;

private:	// ãƒ¡ãƒ³ãƒå¤‰æ•°
	DirectXCommon* dxCommon = nullptr;

	// ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒ‡ãƒ¼ã‚¿
	std::unordered_map<std::string, TextureData> textureDatas;	// 
	// SRVãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼
	SrvManager* srvManager = nullptr;

};



============================================================
File Path: engine/base/WinAPI.cpp
============================================================
#include "WinAPI.h"
#include <cstdint>
#pragma comment(lib,"winmm.lib")
#ifdef USE_IMGUI
#include "externals/imgui/imgui.h"
#include "externals/imgui/imgui_impl_win32.h"
extern IMGUI_IMPL_API LRESULT ImGui_ImplWin32_WndProcHandler(HWND hwndm, UINT msg, WPARAM wParam, LPARAM lParam);
#endif
LRESULT WinAPI::WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam)
{
#ifdef USE_IMGUI
	if (ImGui_ImplWin32_WndProcHandler(hwnd, msg, wparam, lparam)) {
		return true;
	}
#endif
	// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã«å¿œã˜ã¦ã‚²ãƒ¼ãƒ å›ºæœ‰ã®å‡¦ç†ã‚’è¡Œã†
	switch (msg) {
		// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãŒç ´æ£„ã•ã‚ŒãŸ
	case WM_DESTROY:
		// OSã«å¯¾ã—ã¦ã‚¢ãƒ—ãƒªã®çµ‚äº†ã‚’ä¼ãˆã‚‹
		PostQuitMessage(0);
		return 0;
	}
	// æ¨™æº–ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å‡¦ç†ã‚’è¡Œã†
	return DefWindowProc(hwnd, msg, wparam, lparam); 
}

void WinAPI::Finalize()
{
	CloseWindow(hwnd);
	CoUninitialize();
}

void WinAPI::Initialize()
{
	// ã‚·ã‚¹ãƒ†ãƒ ã‚¿ã‚¤ãƒãƒ¼ã®åˆ†è§£èƒ½ã‚’ä¸Šã’ã‚‹
	timeBeginPeriod(1);
	HRESULT hr = CoInitializeEx(0, COINIT_MULTITHREADED);
#pragma region Windowã®ç”Ÿæˆ

	
	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒ—ãƒ­ã‚·ãƒ¼ã‚¸ãƒ£
	wc.lpfnWndProc = WindowProc;//ä¸Šã®é–¢æ•°ã‚’æ¸¡ã—ã¦ã„ã‚‹
	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹å
	wc.lpszClassName = L"CG2";
	//ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«
	wc.hInstance = GetModuleHandle(nullptr);
	//ã‚«ãƒ¼ã‚½ãƒ«
	wc.hCursor = LoadCursor(nullptr, IDC_ARROW);


	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã‚’ç™»éŒ²
	RegisterClass(&wc);

	
	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚ºã‚’è¡¨ã™æ§‹é€ ä½“ã«ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’å…¥ã‚Œã‚‹
	RECT wrc = { 0,0,WinAPI::kClientWidth,WinAPI::kClientHeight };//RECT ãƒ¬ã‚¯ã‚¿ãƒ³ã‚°ãƒ«(çŸ©å½¢)
	//ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã‚’ã‚‚ã¨ã«å®Ÿéš›ã®ã‚µã‚¤ã‚ºã«wrcã‚’å¤‰æ›´ã—ã¦ã‚‚ã‚‰ã†
	AdjustWindowRect(&wrc, WS_OVERLAPPEDWINDOW, false);

	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã®ç”Ÿæˆ
	hwnd = CreateWindow(
		wc.lpszClassName,        //åˆ©ç”¨ã™ã‚‹ã‚¯ãƒ©ã‚¹ãƒ¡ã‚¤ãƒ³
		L"MyEngine",                  //ã‚¿ã‚¤ãƒˆãƒ«ãƒãƒ¼ã®æ–‡å­—
		WS_OVERLAPPEDWINDOW,     //ã‚ˆãè¦‹ã‚‹ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¹ã‚¿ã‚¤ãƒ«
		CW_USEDEFAULT,           //è¡¨ç¤ºXåº§æ¨™
		CW_USEDEFAULT,           //è¡¨ç¤ºYåº§æ¨™ 
		wrc.right - wrc.left,    //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦æ¨ªå¹…
		wrc.bottom - wrc.top,    //ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ç¸¦å¹…
		nullptr,                 //è¦ªã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
		nullptr,                 //ãƒ¡ãƒ‹ãƒ¥ãƒ¼ãƒãƒ³ãƒ‰ãƒ«
		wc.hInstance,            //ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«
		nullptr                  //ã‚ªãƒ—ã‚·ãƒ§ãƒ³
	);//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚’è¡¨ç¤ºã™ã‚‹
	ShowWindow(hwnd, SW_SHOW);
#pragma endregion
}

bool WinAPI::ProcessMessage()
{
	MSG msg{};
	//Windowã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒæ¥ã¦ãŸã‚‰æœ€å„ªå…ˆã§å‡¦ç†ã•ã›ã‚‹
	if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE)) {
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	if (msg.message == WM_QUIT) {
		return true;
	}
	return false;
}



============================================================
File Path: engine/base/WinAPI.h
============================================================
#pragma once
#include <Windows.h>
#include <cstdint>
/// <summary>
/// WindowsAPIã®ãƒ©ãƒƒãƒ‘ãƒ¼ã‚¯ãƒ©ã‚¹
/// </summary>
class WinAPI
{
public:
	/// <summary>
	/// ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿
	/// </summary>
	/// <param name="hwnd"></param>
	/// <param name="msg"></param>
	/// <param name="wparam"></param>
	/// <param name="lparam"></param>
	/// <returns></returns>
	static LRESULT CALLBACK WindowProc(HWND hwnd, UINT msg, WPARAM wparam, LPARAM lparam);
	//å®šæ•°
	//ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆé ˜åŸŸã®ã‚µã‚¤ã‚º
	static const int32_t kClientWidth = 1280;
	static const int32_t kClientHeight = 720;

public:

	/// <summary>
	/// åˆæœŸåŒ–
	/// </summary>
	void Initialize();


	/// <summary>
	/// çµ‚äº†å‡¦ç†
	/// </summary>
	void Finalize();
	
	
	/// <summary>
	/// ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†
	/// </summary>
	bool ProcessMessage();

	//getter
	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
	/// </summary>
	HWND GetHwnd() const { return hwnd; }
	/// <summary>
	/// ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ãƒãƒ³ãƒ‰ãƒ«ã®å–å¾—
	/// </summary>
	HINSTANCE GetHInstance()const { return wc.hInstance; }
private:
	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒãƒ³ãƒ‰ãƒ«
	HWND hwnd = nullptr;

	//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚¯ãƒ©ã‚¹ã®è¨­å®š
	WNDCLASS wc{};

};



============================================================
File Path: engine/math/MakeMatrix.cpp
============================================================
#include"MakeMatrix.h"

#include<cmath>
#include <cassert>


Matrix4x4 MakePerspectiveFovMatrix(float fovY, float aspectRatio, float nearClip, float farClip) {
    Matrix4x4 result;
    result.m[0][0] = 1 / aspectRatio * (1 / std::tan(fovY / 2));   result.m[0][1] = 0;                        result.m[0][2] = 0;                                                               result.m[0][3] = 0;
    result.m[1][0] = 0;                                            result.m[1][1] = 1 / std::tan(fovY / 2);   result.m[1][2] = 0;                                                               result.m[1][3] = 0;
    result.m[2][0] = 0;                                            result.m[2][1] = 0;                        result.m[2][2] = farClip / (farClip - nearClip);                                  result.m[2][3] = 1;
    result.m[3][0] = 0;                                            result.m[3][1] = 0;                        result.m[3][2] = (-nearClip * farClip * std::cos(0.0f)) / (farClip - nearClip);   result.m[3][3] = 0;

    return result;
}

Matrix4x4 MakeTranslateMatrix(const Vector3& translate) {
	Matrix4x4 ans;

	ans.m[0][0] = 1;
	ans.m[0][1] = 0;
	ans.m[0][2] = 0;
	ans.m[0][3] = 0;

	ans.m[1][0] = 0;
	ans.m[1][1] = 1;
	ans.m[1][2] = 0;
	ans.m[1][3] = 0;

	ans.m[2][0] = 0;
	ans.m[2][1] = 0;
	ans.m[2][2] = 1;
	ans.m[2][3] = 0;

	ans.m[3][0] = translate.x;
	ans.m[3][1] = translate.y;
	ans.m[3][2] = translate.z;
	ans.m[3][3] = 1;

	return ans;
}

Matrix4x4 MakeScaleMatrix(const Vector3& scale) {
	Matrix4x4 ans;

	ans.m[0][0] = scale.x;
	ans.m[0][1] = 0;
	ans.m[0][2] = 0;
	ans.m[0][3] = 0;

	ans.m[1][0] = 0;
	ans.m[1][1] = scale.y;
	ans.m[1][2] = 0;
	ans.m[1][3] = 0;

	ans.m[2][0] = 0;
	ans.m[2][1] = 0;
	ans.m[2][2] = scale.z;
	ans.m[2][3] = 0;

	ans.m[3][0] = 0;
	ans.m[3][1] = 0;
	ans.m[3][2] = 0;
	ans.m[3][3] = 1;
	return ans;
}



Matrix4x4 MakeRotateXMatrix(float radian) {

	Matrix4x4 ans;
	ans.m[0][0] = 1;
	ans.m[0][1] = 0;
	ans.m[0][2] = 0;
	ans.m[0][3] = 0;

	ans.m[1][0] = 0;
	ans.m[1][1] = std::cos(radian);
	;
	ans.m[1][2] = std::sin(radian);
	;
	ans.m[1][3] = 0;

	ans.m[2][0] = 0;
	ans.m[2][1] = -std::sin(radian);
	;
	ans.m[2][2] = std::cos(radian);
	;
	ans.m[2][3] = 0;

	ans.m[3][0] = 0;
	ans.m[3][1] = 0;
	ans.m[3][2] = 0;
	ans.m[3][3] = 1;

	return ans;
}

Matrix4x4 MakeRotateYMatrix(float radian) {

	Matrix4x4 ans;
	ans.m[0][0] = std::cos(radian);
	ans.m[0][1] = 0;
	ans.m[0][2] = -std::sin(radian);
	ans.m[0][3] = 0;

	ans.m[1][0] = 0;
	ans.m[1][1] = 1;
	ans.m[1][2] = 0;
	ans.m[1][3] = 0;

	ans.m[2][0] = std::sin(radian);
	;
	ans.m[2][1] = 0;
	ans.m[2][2] = std::cos(radian);
	;
	ans.m[2][3] = 0;

	ans.m[3][0] = 0;
	ans.m[3][1] = 0;
	ans.m[3][2] = 0;
	ans.m[3][3] = 1;

	return ans;
}

Matrix4x4 MakeRotateZMatrix(float radian) {
	Matrix4x4 ans;
	ans.m[0][0] = std::cos(radian);
	ans.m[0][1] = std::sin(radian);
	ans.m[0][2] = 0;
	ans.m[0][3] = 0;

	ans.m[1][0] = -std::sin(radian);
	ans.m[1][1] = std::cos(radian);
	ans.m[1][2] = 0;
	ans.m[1][3] = 0;

	ans.m[2][0] = 0;
	ans.m[2][1] = 0;
	ans.m[2][2] = 1;
	ans.m[2][3] = 0;

	ans.m[3][0] = 0;
	ans.m[3][1] = 0;
	ans.m[3][2] = 0;
	ans.m[3][3] = 1;

	return ans;
}


Matrix4x4 Add(const Matrix4x4& mt1, const Matrix4x4& mt2) {

	Matrix4x4 ans;

	ans.m[0][0] = mt1.m[0][0] + mt2.m[0][0];
	ans.m[0][1] = mt1.m[0][1] + mt2.m[0][1];
	ans.m[0][2] = mt1.m[0][2] + mt2.m[0][2];
	ans.m[0][3] = mt1.m[0][3] + mt2.m[0][3];

	ans.m[1][0] = mt1.m[1][0] + mt2.m[1][0];
	ans.m[1][1] = mt1.m[1][1] + mt2.m[1][1];
	ans.m[1][2] = mt1.m[1][2] + mt2.m[1][2];
	ans.m[1][3] = mt1.m[1][3] + mt2.m[1][3];

	ans.m[2][0] = mt1.m[2][0] + mt2.m[2][0];
	ans.m[2][1] = mt1.m[2][1] + mt2.m[2][1];
	ans.m[2][2] = mt1.m[2][2] + mt2.m[2][2];
	ans.m[2][3] = mt1.m[2][3] + mt2.m[2][3];

	ans.m[3][0] = mt1.m[3][0] + mt2.m[3][0];
	ans.m[3][1] = mt1.m[3][1] + mt2.m[3][1];
	ans.m[3][2] = mt1.m[3][2] + mt2.m[3][2];
	ans.m[3][3] = mt1.m[3][3] + mt2.m[3][3];

	return ans;
}

Matrix4x4 Subtract(const Matrix4x4& mt1, const Matrix4x4& mt2) {

	Matrix4x4 ans;

	ans.m[0][0] = mt1.m[0][0] - mt2.m[0][0];
	ans.m[0][1] = mt1.m[0][1] - mt2.m[0][1];
	ans.m[0][2] = mt1.m[0][2] - mt2.m[0][2];
	ans.m[0][3] = mt1.m[0][3] - mt2.m[0][3];

	ans.m[1][0] = mt1.m[1][0] - mt2.m[1][0];
	ans.m[1][1] = mt1.m[1][1] - mt2.m[1][1];
	ans.m[1][2] = mt1.m[1][2] - mt2.m[1][2];
	ans.m[1][3] = mt1.m[1][3] - mt2.m[1][3];

	ans.m[2][0] = mt1.m[2][0] - mt2.m[2][0];
	ans.m[2][1] = mt1.m[2][1] - mt2.m[2][1];
	ans.m[2][2] = mt1.m[2][2] - mt2.m[2][2];
	ans.m[2][3] = mt1.m[2][3] - mt2.m[2][3];

	ans.m[3][0] = mt1.m[3][0] - mt2.m[3][0];
	ans.m[3][1] = mt1.m[3][1] - mt2.m[3][1];
	ans.m[3][2] = mt1.m[3][2] - mt2.m[3][2];
	ans.m[3][3] = mt1.m[3][3] - mt2.m[3][3];

	return ans;
}

Matrix4x4 Multiply(const Matrix4x4& mt1, const Matrix4x4& mt2) {

	Matrix4x4 ans = {};
	for (int i = 0; i < 4; i++) {
		for (int j = 0; j < 4; j++) {
			for (int k = 0; k < 4; k++) {

				ans.m[i][j] += mt1.m[i][k] * mt2.m[k][j];
			}
		}
	}
	return ans;
}

//é€†è¡Œåˆ—
Matrix4x4 Inverse(const Matrix4x4& m) {
	float A = m.m[0][0] * m.m[1][1] * m.m[2][2] * m.m[3][3] + m.m[0][0] * m.m[1][2] * m.m[2][3] * m.m[3][1] + m.m[0][0] * m.m[1][3] * m.m[2][1] * m.m[3][2]
		- m.m[0][0] * m.m[1][3] * m.m[2][2] * m.m[3][1] - m.m[0][0] * m.m[1][2] * m.m[2][1] * m.m[3][3] - m.m[0][0] * m.m[1][1] * m.m[2][3] * m.m[3][2]
		- m.m[0][1] * m.m[1][0] * m.m[2][2] * m.m[3][3] - m.m[0][2] * m.m[1][0] * m.m[2][3] * m.m[3][1] - m.m[0][3] * m.m[1][0] * m.m[2][1] * m.m[3][2]
		+ m.m[0][3] * m.m[1][0] * m.m[2][2] * m.m[3][1] + m.m[0][2] * m.m[1][0] * m.m[2][1] * m.m[3][3] + m.m[0][1] * m.m[1][0] * m.m[2][3] * m.m[3][2]
		+ m.m[0][1] * m.m[1][2] * m.m[2][0] * m.m[3][3] + m.m[0][2] * m.m[1][3] * m.m[2][0] * m.m[3][1] + m.m[0][3] * m.m[1][1] * m.m[2][0] * m.m[3][2]
		- m.m[0][3] * m.m[1][2] * m.m[2][0] * m.m[3][1] - m.m[0][2] * m.m[1][1] * m.m[2][0] * m.m[3][3] - m.m[0][1] * m.m[1][3] * m.m[2][0] * m.m[3][2]
		- m.m[0][1] * m.m[1][2] * m.m[2][3] * m.m[3][0] - m.m[0][2] * m.m[1][3] * m.m[2][1] * m.m[3][0] - m.m[0][3] * m.m[1][1] * m.m[2][2] * m.m[3][0]
		+ m.m[0][3] * m.m[1][2] * m.m[2][1] * m.m[3][0] + m.m[0][2] * m.m[1][1] * m.m[2][3] * m.m[3][0] + m.m[0][1] * m.m[1][3] * m.m[2][2] * m.m[3][0];

	Matrix4x4 result = {};
	result.m[0][0] = 1 / A * (m.m[1][1] * m.m[2][2] * m.m[3][3] + m.m[1][2] * m.m[2][3] * m.m[3][1] + m.m[1][3] * m.m[2][1] * m.m[3][2] - m.m[1][3] * m.m[2][2] * m.m[3][1] - m.m[1][2] * m.m[2][1] * m.m[3][3] - m.m[1][1] * m.m[2][3] * m.m[3][2]);
	result.m[0][1] = 1 / A * (-m.m[0][1] * m.m[2][2] * m.m[3][3] - m.m[0][2] * m.m[2][3] * m.m[3][1] - m.m[0][3] * m.m[2][1] * m.m[3][2] + m.m[0][3] * m.m[2][2] * m.m[3][1] + m.m[0][2] * m.m[2][1] * m.m[3][3] + m.m[0][1] * m.m[2][3] * m.m[3][2]);
	result.m[0][2] = 1 / A * (m.m[0][1] * m.m[1][2] * m.m[3][3] + m.m[0][2] * m.m[1][3] * m.m[3][1] + m.m[0][3] * m.m[1][1] * m.m[3][2] - m.m[0][3] * m.m[1][2] * m.m[3][1] - m.m[0][2] * m.m[1][1] * m.m[3][3] - m.m[0][1] * m.m[1][3] * m.m[3][2]);
	result.m[0][3] = 1 / A * (-m.m[0][1] * m.m[1][2] * m.m[2][3] - m.m[0][2] * m.m[1][3] * m.m[2][1] - m.m[0][3] * m.m[1][1] * m.m[2][2] + m.m[0][3] * m.m[1][2] * m.m[2][1] + m.m[0][2] * m.m[1][1] * m.m[2][3] + m.m[0][1] * m.m[1][3] * m.m[2][2]);

	result.m[1][0] = 1 / A * (-m.m[1][0] * m.m[2][2] * m.m[3][3] - m.m[1][2] * m.m[2][3] * m.m[3][0] - m.m[1][3] * m.m[2][0] * m.m[3][2] + m.m[1][3] * m.m[2][2] * m.m[3][0] + m.m[1][2] * m.m[2][0] * m.m[3][3] + m.m[1][0] * m.m[2][3] * m.m[3][2]);
	result.m[1][1] = 1 / A * (m.m[0][0] * m.m[2][2] * m.m[3][3] + m.m[0][2] * m.m[2][3] * m.m[3][0] + m.m[0][3] * m.m[2][0] * m.m[3][2] - m.m[0][3] * m.m[2][2] * m.m[3][0] - m.m[0][2] * m.m[2][0] * m.m[3][3] - m.m[0][0] * m.m[2][3] * m.m[3][2]);
	result.m[1][2] = 1 / A * (-m.m[0][0] * m.m[1][2] * m.m[3][3] - m.m[0][2] * m.m[1][3] * m.m[3][0] - m.m[0][3] * m.m[1][0] * m.m[3][2] + m.m[0][3] * m.m[1][2] * m.m[3][0] + m.m[0][2] * m.m[1][0] * m.m[3][3] + m.m[0][0] * m.m[1][3] * m.m[3][2]);
	result.m[1][3] = 1 / A * (m.m[0][0] * m.m[1][2] * m.m[2][3] + m.m[0][2] * m.m[1][3] * m.m[2][0] + m.m[0][3] * m.m[1][0] * m.m[2][2] - m.m[0][3] * m.m[1][2] * m.m[2][0] - m.m[0][2] * m.m[1][0] * m.m[2][3] - m.m[0][0] * m.m[1][3] * m.m[2][2]);

	result.m[2][0] = 1 / A * (m.m[1][0] * m.m[2][1] * m.m[3][3] + m.m[1][1] * m.m[2][3] * m.m[3][0] + m.m[1][3] * m.m[2][0] * m.m[3][1] - m.m[1][3] * m.m[2][1] * m.m[3][0] - m.m[1][1] * m.m[2][0] * m.m[3][3] - m.m[1][0] * m.m[2][3] * m.m[3][1]);
	result.m[2][1] = 1 / A * (-m.m[0][0] * m.m[2][1] * m.m[3][3] - m.m[0][1] * m.m[2][3] * m.m[3][0] - m.m[0][3] * m.m[2][0] * m.m[3][1] + m.m[0][3] * m.m[2][1] * m.m[3][0] + m.m[0][1] * m.m[2][0] * m.m[3][3] + m.m[0][0] * m.m[2][3] * m.m[3][1]);
	result.m[2][2] = 1 / A * (m.m[0][0] * m.m[1][1] * m.m[3][3] + m.m[0][1] * m.m[1][3] * m.m[3][0] + m.m[0][3] * m.m[1][0] * m.m[3][1] - m.m[0][3] * m.m[1][1] * m.m[3][0] - m.m[0][1] * m.m[1][0] * m.m[3][3] - m.m[0][0] * m.m[1][3] * m.m[3][1]);
	result.m[2][3] = 1 / A * (-m.m[0][0] * m.m[1][1] * m.m[2][3] - m.m[0][1] * m.m[1][3] * m.m[2][0] - m.m[0][3] * m.m[1][0] * m.m[2][1] + m.m[0][3] * m.m[1][1] * m.m[2][0] + m.m[0][1] * m.m[1][0] * m.m[2][3] + m.m[0][0] * m.m[1][3] * m.m[2][1]);

	result.m[3][0] = 1 / A * (-m.m[1][0] * m.m[2][1] * m.m[3][2] - m.m[1][1] * m.m[2][2] * m.m[3][0] - m.m[1][2] * m.m[2][0] * m.m[3][1] + m.m[1][2] * m.m[2][1] * m.m[3][0] + m.m[1][1] * m.m[2][0] * m.m[3][2] + m.m[1][0] * m.m[2][2] * m.m[3][1]);
	result.m[3][1] = 1 / A * (m.m[0][0] * m.m[2][1] * m.m[3][2] + m.m[0][1] * m.m[2][2] * m.m[3][0] + m.m[0][2] * m.m[2][0] * m.m[3][1] - m.m[0][2] * m.m[2][1] * m.m[3][0] - m.m[0][1] * m.m[2][0] * m.m[3][2] - m.m[0][0] * m.m[2][2] * m.m[3][1]);
	result.m[3][2] = 1 / A * (-m.m[0][0] * m.m[1][1] * m.m[3][2] - m.m[0][1] * m.m[1][2] * m.m[3][0] - m.m[0][2] * m.m[1][0] * m.m[3][1] + m.m[0][2] * m.m[1][1] * m.m[3][0] + m.m[0][1] * m.m[1][0] * m.m[3][2] + m.m[0][0] * m.m[1][2] * m.m[3][1]);
	result.m[3][3] = 1 / A * (m.m[0][0] * m.m[1][1] * m.m[2][2] + m.m[0][1] * m.m[1][2] * m.m[2][0] + m.m[0][2] * m.m[1][0] * m.m[2][1] - m.m[0][2] * m.m[1][1] * m.m[2][0] - m.m[0][1] * m.m[1][0] * m.m[2][2] - m.m[0][0] * m.m[1][2] * m.m[2][1]);

	return result;
}

Matrix4x4 Transpose(const Matrix4x4& mt1) {

	Matrix4x4 ans;

	ans.m[0][0] = mt1.m[0][0];
	ans.m[0][1] = mt1.m[1][0];
	ans.m[0][2] = mt1.m[2][0];
	ans.m[0][3] = mt1.m[3][0];

	ans.m[1][0] = mt1.m[0][1];
	ans.m[1][1] = mt1.m[1][1];
	ans.m[1][2] = mt1.m[2][1];
	ans.m[1][3] = mt1.m[3][1];

	ans.m[2][0] = mt1.m[0][2];
	ans.m[2][1] = mt1.m[1][2];
	ans.m[2][2] = mt1.m[2][2];
	ans.m[2][3] = mt1.m[3][2];

	ans.m[3][0] = mt1.m[0][3];
	ans.m[3][1] = mt1.m[1][3];
	ans.m[3][2] = mt1.m[2][3];
	ans.m[3][3] = mt1.m[3][3];

	return ans;
}

Matrix4x4 MakeIdentity4x4() {

	Matrix4x4 ans;

	ans.m[0][0] = 1;
	ans.m[0][1] = 0;
	ans.m[0][2] = 0;
	ans.m[0][3] = 0;

	ans.m[1][0] = 0;
	ans.m[1][1] = 1;
	ans.m[1][2] = 0;
	ans.m[1][3] = 0;

	ans.m[2][0] = 0;
	ans.m[2][1] = 0;
	ans.m[2][2] = 1;
	ans.m[2][3] = 0;

	ans.m[3][0] = 0;
	ans.m[3][1] = 0;
	ans.m[3][2] = 0;
	ans.m[3][3] = 1;

	return ans;
}

Matrix4x4 MakeAffineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate) {
	Matrix4x4 rotateXYZ = Multiply(Multiply(MakeRotateXMatrix(rotate.x), MakeRotateYMatrix(rotate.y)), MakeRotateZMatrix(rotate.z));
	return Multiply(Multiply(MakeScaleMatrix(scale), rotateXYZ), MakeTranslateMatrix(translate));
}

Matrix4x4 MakeOrthographicMatrix(float left, float top, float right, float bottom, float nearClip, float farClip) {
	Matrix4x4 result;
	result.m[0][0] = 2 / right; result.m[0][1] = 0;						result.m[0][2] = 0;						 result.m[0][3] = 0;
	result.m[1][0] = 0;			result.m[1][1] = 2 / (top - bottom);		result.m[1][2] = 0;						 result.m[1][3] = 0;
	result.m[2][0] = 0;			result.m[2][1] = 0;						result.m[2][2] = 1 / (farClip - nearClip); result.m[2][3] = 0;
	result.m[3][0] = (left + right) / (left - right); result.m[3][1] = (top + bottom) / (bottom - top); result.m[3][2] = nearClip / (nearClip - farClip); result.m[3][3] = 1;
	return result;
}

============================================================
File Path: engine/math/MakeMatrix.h
============================================================
#pragma once
#include <assert.h>
#include <cmath>
#include <stdio.h>
#include"MyMath.h"


Matrix4x4 Add(const Matrix4x4& mt1, const Matrix4x4& mt2);

Matrix4x4 Subtract(const Matrix4x4& mt1, const Matrix4x4& mt2);

Matrix4x4 Multiply(const Matrix4x4& mt1, const Matrix4x4& mt2);

Matrix4x4 Inverse(const Matrix4x4& mt1);

//Matrix4x4 Transpose(const Matrix4x4& mt1);

Matrix4x4 MakeIdentity4x4();
// å›è»¢
Matrix4x4 MakeTranslateMatrix(const Vector3& translate);
// æ‹¡å¤§
Matrix4x4 MakeScaleMatrix(const Vector3& scale);
// åŒæ™‚åº§æ¨™å¤‰æ›

// å›è»¢X 
Matrix4x4 MakeRotateXMatrix(float radian);
// å›è»¢Y
Matrix4x4 MakeRotateYMatrix(float radian);
// å›è»¢Z
Matrix4x4 MakeRotateZMatrix(float radian);

Matrix4x4 MakeAffineMatrix(const Vector3& scale, const Vector3& rotate, const Vector3& translate);


//æ­£å°„å½±è¡Œåˆ—
Matrix4x4 MakeOrthographicMatrix(float left, float top, float right, float bottom, float nearClip, float farClip);

Matrix4x4 MakePerspectiveFovMatrix(float fovY, float aspectRatio, float nearClip, float farClip);
	

============================================================
File Path: engine/math/MyMath.h
============================================================
#pragma once
#include<vector>
#include<cmath>
#include<string>
#pragma region ãƒ™ã‚¯ãƒˆãƒ«
struct Vector2 {
	float x;
	float y;
};
struct Vector3 {
    float x;
    float y;
    float z;

    // åŠ ç®—æ¼”ç®—å­
    Vector3 operator+(const Vector3& other) const {
        return { x + other.x, y + other.y, z + other.z };
    }

    // æ¸›ç®—æ¼”ç®—å­
    Vector3 operator-(const Vector3& other) const {
        return { x - other.x, y - other.y, z - other.z };
    }

    // ã‚¹ã‚«ãƒ©ãƒ¼ä¹—ç®—æ¼”ç®—å­
    Vector3 operator*(float scalar) const {
        return { x * scalar, y * scalar, z * scalar };
    }

    // ã‚¹ã‚«ãƒ©ãƒ¼é™¤ç®—æ¼”ç®—å­
    Vector3 operator/(float scalar) const {
        return { x / scalar, y / scalar, z / scalar };
    }

    // åŠ ç®—ä»£å…¥æ¼”ç®—å­
    Vector3& operator+=(const Vector3& other) {
        x += other.x;
        y += other.y;
        z += other.z;
        return *this;
    }

    // æ¸›ç®—ä»£å…¥æ¼”ç®—å­
    Vector3& operator-=(const Vector3& other) {
        x -= other.x;
        y -= other.y;
        z -= other.z;
        return *this;
    }

    // ã‚¹ã‚«ãƒ©ãƒ¼ä¹—ç®—ä»£å…¥æ¼”ç®—å­
    Vector3& operator*=(float scalar) {
        x *= scalar;
        y *= scalar;
        z *= scalar;
        return *this;
    }

    // ã‚¹ã‚«ãƒ©ãƒ¼é™¤ç®—ä»£å…¥æ¼”ç®—å­
    Vector3& operator/=(float scalar) {
        x /= scalar;
        y /= scalar;
        z /= scalar;
        return *this;
    }

    // ç­‰ä¾¡æ¼”ç®—å­
    bool operator==(const Vector3& other) const {
        return x == other.x && y == other.y && z == other.z;
    }

    // ä¸ç­‰ä¾¡æ¼”ç®—å­
    bool operator!=(const Vector3& other) const {
        return !(*this == other);
    }

    // ãƒãƒ«ãƒ ï¼ˆé•·ã•ï¼‰ã‚’å–å¾—
    float Length() const {
        return std::sqrt(x * x + y * y + z * z);
    }

    // æ­£è¦åŒ–ã—ãŸãƒ™ã‚¯ãƒˆãƒ«ã‚’è¿”ã™ï¼ˆé•·ã•1ã«ã™ã‚‹ï¼‰
    Vector3 Normalized() const {
        float len = Length();
        if (len == 0.0f) {
            return { 0.0f, 0.0f, 0.0f }; // 0é™¤ç®—å›é¿
        }
        return { x / len, y / len, z / len };
    }
};

struct Vector4 {
	float x;
	float y;
	float z;
	float w;
};
#pragma endregion
#pragma region è¡Œåˆ—
struct Matrix3x3 {
	float m[3][3];
};
struct Matrix4x4 {
	float m[4][4];
};
#pragma endregion

struct MaterialData {
	std::string textureFilePath;
	uint32_t textureIndex = 0;
};
struct VertexData {
	Vector4 position;
	Vector2 texcoord;
	Vector3 normal;
};
struct ModelData {
	std::vector<VertexData>vertices;
	MaterialData material;
	std::vector<uint32_t> indices;
};
struct Material {
	Vector4 color;
	int32_t enableLighting;
	float padding[3];
	Matrix4x4 uvTransform;
};
struct TransformationMatrix {
	Matrix4x4 WVP;
	Matrix4x4 World;
};
struct DirectionalLight {
	Vector4 color; //ãƒ©ã‚¤ãƒˆã®è‰²
	Vector3 direction; //ãƒ©ã‚¤ãƒˆã®å‘ã
	float intensity;	//è¼åº¦
};
struct Transform {
	Vector3 scale;
	Vector3 rotate;
	Vector3 translate;
};
struct SpriteData {
	Vector2 pos;
	Vector2 size;
	float rotate;
	Vector4 color;
};
//struct AccelerationField {
//	Vector3 acceleration;
//	AABB area;
//};

struct TextureVertex {
    Vector4 position; 
	Vector2 texcoord;
};

struct CameraForGPU {
    Vector3 worldPosition;
};

#pragma region ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ§‹é€ ä½“
// ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«æ§‹é€ ä½“

struct Particle
{
	Transform transform;
	Vector3 velocity;
	Vector4 color;
	float lifeTime;
	float currentTime;
};
struct ParticleForGPU
{
	Matrix4x4 WVP;
	Matrix4x4 World;
	Vector4 color;
};
struct EffectInstance
{
    Transform transform;     // ä½ç½®ãƒ»å›è»¢ãƒ»ã‚¹ã‚±ãƒ¼ãƒ«
    Vector4 color;           // è‰²ã‚„é€æ˜åº¦ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ç”¨ï¼‰
    float lifeTime;          // å…¨ä½“ã®å¯¿å‘½
    float currentTime;       // çµŒéæ™‚é–“
    bool isActive = true;    // ã‚¢ã‚¯ãƒ†ã‚£ãƒ–
};


enum BlendMode {
    //!< ãƒ–ãƒ¬ãƒ³ãƒ‰ç„¡ã—
    kBlendModeNone,
    //!< é€šå¸¸Î±ãƒ–ãƒ¬ãƒ³ãƒ‰ ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ src * srcA + Dest * ( 1 - srcA )
    kBelendModeNormal,
    //!< åŠ ç®— src * srcA + Dest * 1;
    kBlendModeAdd,
    //!< æ¸›ç®— Dest * 1 - src * srcA 
    kBlendModeSubtract,
    //!< ä¹—ç®— src * 0 + Dest * src
    kBlendModeMultiply,
    //!< ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ src * ( 1 - Dest )+ Dest * 1
    kBlendModeScreen,
    //!< åˆ©ç”¨ã—ã¦ã¯ã„ã‘ãªã„
    kCountOfBlendMode,
};

#pragma endregion

============================================================
File Path: main.cpp
============================================================
// ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œå‡ºãƒã‚§ãƒƒã‚¯
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
#include "Game/Scene//MyGame.h"
//ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚ºã‚¢ãƒ—ãƒªã§ã®ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆ(mainé–¢æ•°)
int WINAPI WinMain(HINSTANCE, HINSTANCE, LPSTR, int) {

#ifdef _DEBUG
	// ãƒ‡ãƒãƒƒã‚°ãƒ¢ãƒ¼ãƒ‰ã®ã¨ããƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œå‡ºã‚’æœ‰åŠ¹ã«ã™ã‚‹
	// ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯æ¤œå‡º
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);

	// ãƒªãƒ¼ã‚¯ç•ªå·ã‚’æŒ‡å®šã—ã¦ãƒ–ãƒ¬ãƒ¼ã‚¯ã‚’ç™ºç”Ÿã•ã›ã‚‹
	//_CrtSetBreakAlloc();

	D3DResourceLeakChecker leakChecker;
#endif
	{
		MyGame game;
		game.Run();
	}

	return 0;
}

